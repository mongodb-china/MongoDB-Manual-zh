{"./":{"url":"./","title":"Introduction","keywords":"","body":"MongoDB官方文档中文版 项目介绍 MongoDB是专为可扩展性，高性能和高可用性而设计的数据库。它可以从单服务器部署扩展到大型、复杂的多数据中心架构。利用内存计算的优势，MongoDB能够提供高性能的数据读写操作。 MongoDB的本地复制和自动故障转移功能使您的应用程序具有企业级的可靠性和操作灵活性。 本项目为Mongodb官方文档的中文版,与官方文档保持同步。 维护地址Github在线阅读 项目协议 本项目为 CC BY-NC-SA 4.0。 报告问题 在我们的Github MongoDB-Manual-zh/issues上提 issue.发邮件到 Email:预留位置 贡献指南 请您勇敢地去翻译和改进翻译。虽然我们追求卓越，但我们并不要求您做到十全十美，因此请不要担心因为翻译上犯错——在大部分情况下，我们的服务器已经记录所有的翻译，因此您不必担心会因为您的失误遭到无法挽回的破坏。（改编自维基百科） 如何提交请点击 贡献者名单 links 其他 欢迎任何人参与和完善：一个人可以走的很快，但是一群人却可以走的更远。予人成功才是最大的成功 。 免责声明 锦木信息 纯粹出于学习目的与个人兴趣翻译本书，不追求任何经济利益。 本译文只供学习研究参考之用，不得用于商业用途。我方将保留对此版本译文的署名权及其它相关权利。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:43:05 "},"docs/The-Mongo-Shell.html":{"url":"docs/The-Mongo-Shell.html","title":"The mongo Shell","keywords":"","body":" The mongo Shell 在本页面 启动mongo Shell并连接到MongoDB 使用mongo Shell 制表符完成和其他键盘快捷键 mongorc.js文件 退出Shell mongo shell是MongoDB的交互式JavaScript接口。您可以使用mongo shell查询和更新数据以及执行管理操作。 mongo shell作为MongoDB Server安装的一部分包含在内。 MongoDB还提供mongo shell作为独立软件包。如何下载独立的mongo shell软件包： 1.打开下载中心。对于mongo Enterprise Shell，选择MongoDB Enterprise Server选项卡。 2.从下拉列表中选择您的首选版本和操作系统。 3.选择要根据您的系统下载的安装包： 系统 下载包 Win 选择ZIP以下载包含mongo shell的安装包 Mac 选择TGZ以下载包含mongo shell的安装包 Linux 选择shell以下载包含mongo shell的安装包 安装并启动MongoDB之后，将mongo shell连接到正在运行的MongoDB实例。 启动mongo Shell并连接到MongoDB 先决条件在尝试启动mongo shell之前，请确保MongoDB正在运行。 打开终端窗口（或Windows的命令提示符），然后转/bin 目录。 cd /bin 提示 将 / bin添加到PATH环境变量中，可以键入mongo，而不必转到 / bin目录或指定二进制文件的完整路径。 默认端口上的本地MongoDB实例 您可以在不使用任何命令行选项的情况下运行mongo shell，以使用默认端口27017连接到在本地主机上运行的MongoDB实例： mongo 非默认端口上的本地MongoDB实例 要显式指定端口，请包括--port命令行选项。例如，要使用非默认端口28015连接到在localhost上运行的MongoDB实例，请执行以下操作： mongo --port 28015 远程主机上的MongoDB实例 要明确指定主机名或端口： 您可以指定一个连接字符串。例如：要连接到在远程主机上运行的MongoDB实例，请执行以下操作： mongo \"mongodb://mongodb0.example.com:28015\" 您可以使用命令行选项--host :。例如，要连接到在远程主机上运行的MongoDB实例，请执行以下操作： mongo --host mongodb0.example.com:28015 您可以使用--host 和--port 命令行选项。例如，要连接到在远程主机上运行的MongoDB实例，请执行以下操作： mongo --host mongodb0.example.com --port 28015 具有身份验证的MongoDB实例要连接到MongoDB实例，需要进行身份验证：您可以在连接字符串中指定用户名，身份验证数据库以及可选的密码。例如：以alice用户身份连接并认证到远程MongoDB实例： 注意如果未在连接字符串中指定密码，则shell程序将提示您输入密码。 mongo \"mongodb://alice@mongodb0.examples.com:28015/?authSource=admin\" 您可以使用--username 和--password，--authenticationDatabase 命令行选项。 例如，以alice用户身份连接并认证到远程MongoDB实例： 注意如果您指定--password而不输入用户密码，则shell程序将提示您输入密码。 mongo --username alice --password --authenticationDatabase admin --host mongodb0.examples.com --port 28015 连接到MongoDB复制集集（Connect to a MongoDB Replica Set） 要连接到复制集： 您可以在连接字符串中指定复制集名称和成员 mongo \"mongodb://mongodb0.example.com.local:27017,mongodb1.example.com.local:27017,mongodb2.example.com.local:27017/?replicaSet=replA\" 如果使用DNS种子列表连接格式，则可以指定连接字符串： mongo \"mongodb+srv://server.example.com/\" 注意 对于连接，使用+ srv连接字符串修饰符会自动将ssl选项设置为true。 您可以从--host / ：，：，...命令行选项中指定复制集集名称和成员。 例如，要连接到名为replA的复制集集，请执行以下操作： mongo --host replA/mongodb0.example.com.local:27017,mongodb1.example.com.local:27017,mongodb2.example.com.local:27017 TLS/SSL 连接关于TLS/SS连接：您可以在连接字符串中指定ssl = true选项。 mongo \"mongodb://mongodb0.example.com.local:27017,mongodb1.example.com.local:27017,mongodb2.example.com.local:27017/?replicaSet=replA&ssl=true\" 如果使用DNS种子列表连接格式，则可以包括+ srv连接字符串修饰符： mongo \"mongodb+srv://server.example.com/\" 注意对于连接，使用+ srv连接字符串修饰符会自动将ssl选项设置为true。 您可以指定--ssl命令行选项。 例如，要连接到名为replA的复制集集，请执行以下操作： mongo --ssl --host replA/mongodb0.example.com.local:27017,mongodb1.example.com.local:27017,mongodb2.example.com.local:27017 另：有关连接示例中使用的选项以及其他选项的更多信息，请参阅mongo参考和启动mongo的示例（mongo reference and examples of starting up mongo）。 使用mongoShell 要显示您正在使用的数据库，请键入db：db 该操作应返回test 数据库名，这是默认数据库。 要切换数据库，请发出use 帮助器，如以下示例所示： use 另请参见db.getSiblingDB() 方法，以从当前数据库访问其他数据库，而无需切换当前数库上下文（即db）。 要列出用户可用的数据库，可使用： show dbs 您可以切换到不存在的数据库。首次将数据存储在数据库中（例如通过创建集合）时，MongoDB会创建数据库。 例如，以下代码在insertOne（）操作期间创建数据库myNewDatabase和集合myCollection： use myNewDatabase db.myCollection.insertOne( { x: 1 } ); db.myCollection.insertOne()是mongo shell中可用的方法之一。db是指当前数据库。myCollection是集合的名称。如果mongo shell不接受集合的名称，则可以使用替代的db.getCollection()语法。例如，如果集合名称包含空格或连字符，以数字开头或与内置函数冲突： db.getCollection(\"3 test\").find() db.getCollection(\"3-test\").find() db.getCollection(\"stats\").find() mongo shell提示符每行的限制为4095个字符（code points）。 如果您输入的行中包含4095个以上的字符（code points），则Shell将截断它。 有关mongo shell中MongoDB基本操作的更多文档，请参阅： Getting Started Guide Insert Documents Query Documents Update Documents Delete Documents mongo Shell Methods 如果部署使用访问控制运行，则该操作将根据用户权限返回不同的值。 有关详细信息，请参见listDatabases Behavior。 格式化打印结果 db.collection.find()方法是用于从集合中检索文档的JavaScript方法。 db.collection.find()方法将游标返回到结果。 但是，在mongo shell中，如果未使用var关键字将返回的游标分配给变量，则该游标会自动迭代最多20次，来打印与查询匹配的前20个文档。 mongo shell将提示 输入it以使其再次迭代20次。 要格式化打印结果，可以将.pretty()添加到操作中，如下所示： db.myCollection.find().pretty() 此外，您可以在mongo shell中使用以下显式打印方法： print() to print without formatting print(tojson()) to print with JSON formatting and equivalent to printjson() printjson() to print with JSON formatting and equivalent to print(tojson()) 有关在mongo shell中处理光标的更多信息和示例，请参阅terate a Cursor in the mongo。 另请参阅Cursor Help ，以获取mongo shell中的游标帮助列表。mongo Shell中的多行操作如果您以开括号（'（'），大括号（'{'）或开括号（'['）结束一行，则后续行以省略号（“ ...”）开头，直到您 输入相应的右括号（'）'，右括号（'}'）或右括号（']'）。 mongo shell在评估代码之前等待右括号，右括号或右括号，如以下示例所示： >if ( x > 0 ) { ... count++; ... print (x); ... } 如果输入两个空行，则可以退出行继续模式，如以下示例所示： > if (x > 0 ... ... > 制表符完成和其他键盘快捷键 mongo shell支持键盘快捷键。 例如： 使用向上/向下箭头键滚动浏览命令历史记录。 有关.dbshell文件的更多信息，请参见.dbshell 文档。 使用来自动完成或列出完成可能性，如以下示例中所示，该示例使用来完成以字母'c'开头的方法名称： db.myCollection.c 因为有许多以字母'c'开头的收集方法，所以将列出以'c'开头的各种方法。 有关快捷键的完整列表，请参见：Shell 快捷命令（Shell Keyboard Shortcuts）。 mongorc.js文件 启动时，mongo将在用户的HOME目录中检查名为.mongorc.js的JavaScript文件。 如果找到，mongo会在首次显示提示之前解释.mongorc.js的内容。如果您使用舍shell程序来评估JavaScript文件或表达式，或者通过在命令行上使用--eval选项，或者通过将.js文件指定给mongo，则mongo将在JavaScript完成处理后读取.mongorc.js文件。 您可以使用--norc选项防止加载.mongorc.js。 退出Shell 要退出shell，请键入quit（）或使用 快捷方式。 另可参考： Getting Started Guide mongo Reference Page Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/The-Mongo-Shell/Configure-the-mongo-shell.html":{"url":"docs/The-Mongo-Shell/Configure-the-mongo-shell.html","title":"Configure the mongo shell","keywords":"","body":"配置mongo Shell 在本页面 自定义提示 在mongo shell中使用外部编辑器 改变mongo shell(batchSize) 自定义提示 您可以通过在 mongo shell 中设置变量提示来修改提示的内容。 提示变量可以包含字符串以及JavaScript代码。 如果提示符包含返回字符串的函数，则mongo可以在每个提示符中显示动态信息。您可以在.mongorc.js文件中添加提示逻辑，以在每次启动mongo shell时设置提示。 自定义提示以显示操作数 例如，要使用当前会话中发出的操作数创建mongo shell提示，请在mongo shell中定义以下变量： cmdCount = 1; prompt = function() return (cmdCount++) + \"> \"; } 提示将展示类似于以下内容： 1> 2> 3> 自定义提示以显示数据库和主机名 要以 @ $的形式创建mongo shell提示，请定义以下变量： host = db.serverStatus().host; prompt = function() return db+\"@\"+host+\"$ \"; } 提示将类似于以下内容： test@myHost1$ 自定义提示以显示时间和文档计数 要创建一个包含系统正常运行时间和当前数据库中文档数的mongo shell提示，请在mongo shell中定义以下提示变量： prompt = function(){ return \"Uptime:\"+db.serverStatus().uptime+\" Documents:\"+db.stats().objects+\" > \"; } 提示符将类似于以下内容： Uptime:5897 Documents:6 > 在mongo shell中使用外部编辑器 您可以通过在启动mongo shell 之前设置EDITOR环境变量，这样就可以在 mongo shell中使用自己的编辑器。 export EDITOR=vim mongo 进入mongo shell后，您可以通过输入edit 或edit 使用指定的编辑器进行编辑，如以下示例所示： 1.定义一个函数myFunction： function myFunction () { } 2.使用编辑器编辑函数： edit myFunction 该命令将打开vim编辑会话。 完成编辑后，保存并退出vim编辑会话。 3.在mongo shell中，键入myFunction以查看函数定义： myFunction 展示的是已经保存编辑后的结果: function myFunction() { print(\"This was edited\"); } 注意 当mongo shell解释在外部编辑器中编辑的代码时，它可能会修改函数中的代码，具体取决于JavaScript编译器。 例如，mongo可以将1 + 1转换为2或删除注释。 实际更改仅影响代码的外观，并且会根据所使用的JavaScript版本而有所不同，但不会影响代码的语义。 改变mongo shell(batchSize) db.collection.find()方法是用于从集合中检索文档的JavaScript方法。 db.collection.find()方法将游标返回到结果。 但是，在mongo shell中，如果未使用var关键字将返回的游标分配给变量，则该游标会自动迭代最多20次，来打印与查询匹配的前20个文档。 mongo shell将提示 输入it以使其再次迭代20次。 您可以设置DBQuery.shellBatchSize属性，以更改文档数默认值20，如以下示例中将其设置为10： DBQuery.shellBatchSize = 10; Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/The-Mongo-Shell/Access-the-mongo-Shell Help.html":{"url":"docs/The-Mongo-Shell/Access-the-mongo-Shell Help.html","title":"Access the mongo Shell Help","keywords":"","body":"使用 mongo Shell帮助 在本页面 命令行帮助 shell帮助 数据库帮助 表级别帮助 游标级别帮助 包装对象帮助 除了《 MongoDB中文手册》中的文档外，mongo shell在其“联机”帮助系统中提供了一些其他信息。 本文档概述了访问此帮助信息的过程。 命令行帮助 要查看选项列表和启动mongo shell相关的帮助，请从命令行使用--help选项： mongo --help Shell帮助 当需要查看帮助列表时，请在mongo shell中键入help ： help 数据库帮助 在mongo shell中： 当需要查看服务器上的数据库列表，请使用show dbs命令： show dbs show database是show dbs的别名当需要查看可在db对象上使用的方法的帮助列表，请调用db.help()方法： db.help() 当需要查看在 shell中查看某些方法的具体实现，请键入不带括号（（））的db.，如以下示例所示，它将返回方法db.updateUser()的实现： db.updateUser 如果部署使用访问控制运行，则该操作将根据用户权限返回不同的值。 有关详细信息，请参见listDatabases行为。 表级别帮助 在mongo shell中： 要查看当前数据库中的集合列表，请使用show collections命令： show collections 另可参考：show collections 要查看收集对象上可用方法的帮助（例如db.），请使用db..help()方法： db.collection.help() 可以是存在的集合的名称，尽管您可以指定不存在的集合。 要查看收集方法的实现，请键入不带括号（（））的db..名称，如以下示例所示，它将返回save()方法的实现： db.collection.save 游标相关帮助 在mongo shell中使用find()方法执行读取操作时，可以使用各种游标方法来修改find()行为，并可以使用各种JavaScript方法来处理从find()方法返回的游标。 要列出可用的修饰符和游标处理方法，请使用db.collection.find().help()命令： db.collection.find().help() 可以是存在的集合的名称，尽管您可以指定不存在的集合。 要查看cursor方法的实现，请输入不带括号（（））的db..find().名称，如以下示例所示，它将返回toArray()方法的实现： db.collection.find().toArray 处理游标的一些有用方法是：·hasNext()检查光标是否还有更多文档要返回。·next()返回下一个文档，并将光标位置向前移动一个。·forEach（）迭代整个光标，并将应用于光标返回的每个文档。期望一个参数，该参数对应于每次迭代的文档。 有关迭代游标和从游标中检索文档的示例，请参见 cursor handling。有关所有可用的游标方法，另请参见Cursor。 包装对象帮助 要获取mongo shell中可用的包装器类的列表，例如BinData()，请在mongo shell中键入help misc： help misc 另可参考：mongo Shell Methods Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/The-Mongo-Shell/Write-Scripts-for-the-mongo-Shell.html":{"url":"docs/The-Mongo-Shell/Write-Scripts-for-the-mongo-Shell.html","title":"Write Scripts for the mongo Shell","keywords":"","body":"为mongo Shell编写脚本 在本页面 打开新连接 Interactive and Scripted mongo 这两种Mongodb交互的区别 脚本编写 您可以为mongo shell编写JavaScript 的脚本，来处理MongoDB中的数据或执行管理操作。 本章节介绍了通过mongo shell编写的JavaScript的方法 来访问 Mongodb的方式。 打开新连接 在mongo shell或JavaScript文件中，您可以使用Mongo()构造函数实例化数据库连接： Mongo() new Mongo() new Mongo() 请考虑以下示例，该示例实例化与在默认端口上的localhost上运行的MongoDB实例的新连接，并使用getDB()方法将全局db变量设置为myDatabase： conn = new Mongo(); db = conn.getDB(\"myDatabase\"); 如果连接到已经开启了访问控制的MongoDB实例，则可以使用db.auth()方法进行身份验证。此外，您可以使用connect()方法连接到MongoDB实例。 以下示例使用非默认端口27020连接到在localhost上运行的MongoDB实例，并设置全局db变量： db = connect(\"localhost:27020/myDatabase\"); 另可参考：mongo Shell Methods 交互式mongo与脚本mongo的区别: 注意 从4.2版开始，mongo shell提供了isInteractive()方法，该方法返回一个布尔值，该值指示mongo shell是在交互模式还是脚本模式下运行。 为mongo shell编写脚本时，请考虑以下事项： 要设置db全局变量，请使用getDB()方法或onnect()方法。您可以将数据库引用分配给db以外的其他变量。 mongo shell中的写操作默认情况下使用{w：1}的写入策略。 如果执行批量操作，请使用Bulk()方法。 有关更多信息，请参见：写入方法确认（Write Method Acknowledgements）。 您不能在JavaScript文件中使用任何shell帮助程序（例如，使用，show dbs等），因为它们不是有效的JavaScript。下表将最常见的mongo shell助手映射到其JavaScript等效项： Shell JavaScript 显示数据库（show dbs, show databases） db.adminCommand('listDatabases') 使用( use ) db = db.getSiblingDB('') 显示收藏（show collections） db.getCollectionNames() 显示用户（show users） db.getUsers() 显示角色（show roles） db.getRoles({showBuiltinRoles: true}) 显示日志名称（show log） db.adminCommand({ 'getLog' : '' }) 显示日志（show logs） db.adminCommand({ 'getLog' : '*' }) 迭代（it） cursor = db.collection.find()if ( cursor.hasNext() ){ cursor.next();} 在交互模式下，mongo打印操作结果，包括所有游标的内容。 在脚本中，使用JavaScript print()函数或mongo特定的printjson()函数，该函数返回格式化的JSON。例: 要在mongo shell脚本中打印结果游标中的所有项目，请使用以下惯用法： cursor = db.collection.find(); while ( cursor.hasNext() ) { printjson( cursor.next() ); } 脚本编写 在系统提示下，使用mongo评估JavaScript。 --eval选项 使用--eval选项 让Mongo来执行一个JavaScript片段，如下所示： mongo test --eval \"printjson(db.getCollectionNames())\" 这将使用连接到在本地主机接口上的端口27017上运行的mongod或mongos实例的mongo shell返回db.getCollectionNames()的输出。 执行一个JavaScript文件 您可以在mongo shell中指定.js文件，然后mongo将直接执行JavaScript。 考虑以下示例： mongo localhost:27017/test myjsfile.js 此操作在mongo shell中执行myjsfile.js脚本，该脚本连接到可通过端口27017上的localhost接口访问的mongod实例上的测试数据库。或者，您可以使用Mongo()构造函数在javascript文件中指定mongodb连接参数。 有关更多信息，请参见：打开新连接（Opening New Connections ）。 您可以使用load()函数从mongo shell中执行.js文件，如下所示： load(\"myjstest.js\") 此函数加载并执行myjstest.js文件。 load()方法接受相对路径和绝对路径。 如果mongo shell的当前工作目录为/ data / db，而myjstest.js位于/ data / db / scripts目录中，则mongo shell中的以下调用将是等效的： load(\"scripts/myjstest.js\") load(\"/data/db/scripts/myjstest.js\") 注意 load（）函数没有搜索路径。 如果所需的脚本不在当前工作目录或完整的指定路径中，则mongo将无法访问该文件。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/The-Mongo-Shell/Data-Types-in-the-mongo-Shell.html":{"url":"docs/The-Mongo-Shell/Data-Types-in-the-mongo-Shell.html","title":"Data Types in the mongo Shell","keywords":"","body":"mongo Shell中的数据类型 在本页面 类型 Date ObjectId NumberLong NumberInt NumberDecimal 在mongo Shell中检查类型 instanceof typeof MongoDB BSON支持除JSON本身支持类型之外的其他数据类型。 驱动程序以宿主语言为这些数据类型提供本机支持，而mongo shell还提供了一些帮助程序类来支持在mongo JavaScript shell中使用这些数据类型。 有关其他信息，请参见扩展JSON参考。 类型 Date mongo shell提供了多种返回日期的方法，这些方法可以是字符串，也可以是Date对象： Date() 方法，以字符串形式返回当前日期。 new Date() 构造函数，该构造函数使用ISODate()包装器返回Date对象。 ISODate() 构造函数，该构造函数使用ISODate()包装器返回Date对象。 在内部，Date对象存储为带符号的64位整数，表示自Unix纪元（1970年1月1日）以来的毫秒数。 并非所有的数据库操作和驱动程序都支持完整的64位范围。 您可以安全地处理年份，年份范围在0到9999之间。以字符串类型返回日期以字符串类型返回日期，要用到Data()方法，如下所示： var myDateString = Date(); 要打印变量的值，请在shell中键入变量名称，如下所示： myDateString myDataString值的结果如下： Wed Dec 19 2012 01:03:25 GMT-0500 (EST) 要验证类型，请使用typeof运算符，如下所示： typeof myDateString 该操作返回值为 String Return Date mongo shell使用ISODate帮助程序包装Date类型的对象； 但是，对象仍为日期类型。 下面的示例使用新的Date()构造函数和ISODate()构造函数来返回Date对象。 var myDate = new Date(); var myDateInitUsingISODateWrapper = ISODate(); 您也可以将new运算符与ISODate()构造函数一起使用。要打印变量的值，请在shell中键入变量名称，如下所示： myDate 结果是包装在ISODate() 帮助器中的myDate的Date值： ISODate(\"2012-12-19T06:01:17.171Z\") 要验证类型，请使用instanceof运算符，如下所示： myDate instanceof Date myDateInitUsingISODateWrapper instanceof Date 这两个操作均返回true ObjectID mongo shell提供了围绕ObjectId数据类型的ObjectId（）封装类。 要生成新的ObjectId，请在mongo shell中使用以下操作： new ObjectId 参考：ObjectId NumberLong mongo shell默认情况下会将所有数字视为浮点型。mongo shell提供了NumberLong() 包装器来处理64位整数。 NumberLong() 封装接受long作为字符串： NumberLong(\"2090845886852\") 以下示例使用NumberLong（）的封装写入集合： db.collection.insertOne( { _id: 10, calc: NumberLong(\"2090845886852\") } ) db.collection.updateOne( { _id: 10 }, { $set: { calc: NumberLong(\"2555555000000\") } } ) db.collection.updateOne( { _id: 10 }, { $inc: { calc: NumberLong(5) } } ) 检索文档以验证： db.collection.findOne( { _id: 10 } ) 在返回的文档中，calc字段包含一个NumberLong对象： { \"_id\" : 10, \"calc\" : NumberLong(\"2555555000005\") } 如果使用$inc 通过浮点数递增包含NumberLong对象的字段的值，则数据类型将更改为浮点值，如以下示例所示： 1.使用$inc 将calc字段增加 5，mongo shell将其视为浮点数： db.collection.updateOne( { _id: 10 }, { $inc: { calc: 5 } } ) 2.检索更新的文档： db.collection.findOne( { _id: 10 } ) 在更新的文档中，calc字段包含一个浮点值： { \"_id\" : 10, \"calc\" : 2555555000010 } NumberInt mongo shell默认情况下会将所有数字视为浮点值。 mongo shell提供NumberInt()构造函数来显式指定32位整数。 NumberDecimal 始于3.4版本mongo shell默认将所有数字视为64位浮点双精度值。 mongo shell提供了NumberDecimal()构造函数来显式指定基于128位的基于十进制的浮点值，该值能够精确地模拟十进制舍入。 此功能适用于处理货币数据的应用程序，例如金融、税收和科学计算。十进制BSON类型使用IEEE 754十进制128浮点编号格式，该格式支持34个十进制数字（即有效数字）和-6143至+6144的指数范围。NumberDecimal（）构造函数接受十进制值作为字符串： NumberDecimal(\"1000.55\") 该值存储在数据库中，如下所示： NumberDecimal(\"1000.55\") NumberDecimal()构造函数还接受mongo shell中的双精度值（即不带引号），尽管不建议这样做，因为这样做可能会丢失精度。 构造函数创建基于二进制的双精度表示形式的基于十进制的参数（可能会丢失精度），然后将该值转换为精度为15位数字的十进制值。 下面的示例隐式地将值作为双精度值传递，并显示如何以15位精度创建值： NumberDecimal(1000.55) 该值存储在数据库中，如下所示： NumberDecimal(\"1000.55000000000\") 下面的示例隐式地将该值作为双精度值传递，并说明如何发生精度损失： NumberDecimal(9999999.4999999999) 该值存储在数据库中，如下所示： NumberDecimal(\"9999999.50000000\") 注意要将十进制数据类型与MongoDB驱动程序一起使用，请确保使用支持该格式的驱动程序版本。 相等和排序 比较十进制类型的值，并根据其实际数字值与其他数字类型进行排序。 基于二进制的double类型的数值通常具有基于十进制值的近似表示，并且可能不完全等于其十进制表示，因此在检查十进制值的相等性时，请使用NumberDecimal()构造函数。 考虑以下示例以及带有数字集合中的以下文档： { \"_id\" : 1, \"val\" : NumberDecimal( \"9.99\" ), \"description\" : \"Decimal\" } { \"_id\" : 2, \"val\" : 9.99, \"description\" : \"Double\" } { \"_id\" : 3, \"val\" : 10, \"description\" : \"Double\" } { \"_id\" : 4, \"val\" : NumberLong(10), \"description\" : \"Long\" } { \"_id\" : 5, \"val\" : NumberDecimal( \"10.0\" ), \"description\" : \"Decimal\" } 将下表中的查询插入db.numbers.find（）方法时，将返回以下结果： 查询(Query) 结果（Results） { “val”: 9.99 } { “_id”: 2, “val”: 9.99, “description”: “Double” } { “val”: NumberDecimal( “9.99” ) } { “_id”: 1, “val”: NumberDecimal( “9.99” ), “description”: “Decimal” } { val: 10 } { “_id”: 3, “val”: 10, “description”: “Double” }{ “_id”: 4, “val”: NumberLong(10), “description”: “Long” }{ “_id”: 5, “val”: NumberDecimal( “10.0” ), “description”: “Decimal” } { val: NumberDecimal( “10” ) } { “_id”: 3, “val”: 10, “description”: “Double” }{ “_id”: 4, “val”: NumberLong(10), “description”: “Long” }{ “_id”: 5, “val”: NumberDecimal( “10.0” ), “description”: “Decimal” } 第一个查询 {“ val”：9.99} 隐式搜索9.99的双精度表示形式，该表示形式不等于该值的十进制表示形式。 NumberDecimal() 构造函数用于查询以9.99十进制表示的文档。 排除双精度类型的值，因为它们与9.99的十进制表示形式的确切值不匹配。 查询整数时，将返回所有数字类型的匹配值。 例如，查询10的双精度表示将在结果中包含10.0的十进制表示，反之亦然。 检查十进制类型 要测试十进制类型，请使用$type运算符，其字符串别名为“decimal”或19（十进制类型的数字代码）。 db.inventory.find( { price: { $type: \"decimal\" } } ) 在mongo Shell中检查类型 为了确定字段的类型，mongo shell提供了instanceof和typeof运算符。 instanceof instanceof返回一个布尔值，以测试值是否是某种类型的实例。 例如，以下操作测试_id字段是否为ObjectId类型的实例： mydoc._id instanceof ObjectId 该操作返回true。 typeof typeof返回字段的类型。 例如，以下操作返回_id字段的类型： typeof mydoc._id 在这种情况下，typeof将返回更通用的object 类型，而不是ObjectId类型。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/The-Mongo-Shell/mongo-Shell-Quick-Reference.html":{"url":"docs/The-Mongo-Shell/mongo-Shell-Quick-Reference.html","title":"mongo Shell Quick Reference","keywords":"","body":"mongo Shell 快速参考 在本页面 mongo Shell命令历史 命令行选项 命令助手 Shell基本JavaScript操作 键盘快捷键 查询 错误检查方法 行政命令助手 打开其他连接 多样式 其他资源 mongo Shell命令历史 您可以使用上下箭头键检索在mongo shell中发布的先前命令。 命令历史记录存储在〜/ .dbshell文件中。 有关更多信息，请参见.dbshell。 命令行选项 mongo shell可以使用许多选项启动。 有关所有可用选项的详细信息，请参见mongo shell页面。下表显示了mongo的一些常用选项： 选项 说明 --help 显示命令行选项 --nodb 在不连接数据库的情况下启动mongo shell。要稍后连接，请参阅Opening New Connections。 --shell 与JavaScript文件（即file.js>]）结合使用，以在运行JavaScript文件后在mongo shell中继续。有关示例，请参见 JavaScript file。 命令助手 mongo shell提供了各种帮助。下表显示了一些常见的帮助方法和命令： 帮助方法和命令 描述 help() 打印当前数据库的列表 db.help() 打印当前数据库的所有角色的列表，包括用户定义的角色和内置角色。 db..help() 打印耗时1毫秒或更长时间的五个最新操作。 有关更多信息，请参见数据库分析器上的文档。 show dbs 打印所有可用数据库的列表。该操作对应于listDatabases命令。 如果部署使用访问控制运行，则该操作将根据用户权限返回不同的值。 有关详细信息，请参见 listDatabases。 usedb> 将当前数据库切换到db>。 mongo shell变量db设置为当前数据库。 show collections 打印当前数据库的所有集合的列表。另可参考：show collections show users 打印当前数据库列表 show roles 打印当前数据库的所有角色的列表，包括用户定义角色和内置角色。 show profile 打印耗时1毫秒或更长时间的五个最新操作。 有关更多信息，请参见 database profiler。 show databases 打印所有可用数据库的列表。该操作对应于 listDatabases 命令。 如果部署使用访问控制运行，则该操作将根据用户权限返回不同的值。 有关详细信息，请参见 listDatabases。 load() 执行一个JavaScript文件。 有关更多信息，请参见 Write Scripts for the mongo Shell。 Shell基本JavaScript操作 mongo shell提供了用于数据库操作的JavaScript API。 在mongo shell中，db是引用当前数据库的变量。该变量自动设置为默认数据库测试，或者在use db>切换当前数据库时设置。下表显示了一些常见的JavaScript操作： JavaScript数据库操作 说明 db.auth() 如果以安全模式运行，请对用户进行身份验证。 coll = db.collection> 将当前数据库中的特定集合设置为变量coll，如以下示例所示：coll = db.myCollection;您可以使用变量在myCollection上执行操作，如以下示例所示：coll.find(); db.collection.find() 查找集合中的所有文档并返回一个游标。有关更多信息和示例，请参见db.collection.find（）和查询文档。有关在mongo shell中处理游标的信息，请参阅在mongo Shell中迭代游标。 db.collection.insertOne() 将新文档插入集合中。 db.collection.insertMany() 将多个新文档插入集合中。 db.collection.updateOne() 更新集合中的单个现有文档。 db.collection.updateMany() 更新集合中的多个现有文档。 db.collection.save() 插入新文档或更新集合中的现有文档。 db.collection.deleteOne() 从集合中删除单个文档。 db.collection.deleteMany() 从集合中删除多个文档 db.collection.drop() 完全删除或除去集合。 db.collection.createIndex() 如果索引不存在，则在集合上创建一个新索引；否则，该操作无效。 db.getSiblingDB() 使用相同的连接返回对另一个数据库的引用，而无需显式切换当前数据库。 这允许跨数据库查询。 有关在shell中执行操作的更多信息，请参见： MongoDB CRUD Operations mongo Shell Methods 键盘快捷键 mongo shell提供了大多数键盘快捷键，类似于bash shell或Emacs中的快捷键。 对于某些功能，mongo提供了多个键绑定，以适应几种熟悉的范例。下表列举了mongo shell支持的击键： 按键 功能 Up-arrow 以前的历史 Down-arrow 下一个历史 Home 行起点 End 行尾 Tab 自动完成 Left-arrow 后退字符 Right-arrow 向前字符 Ctrl-left-arrow 后向词 Ctrl-right-arrow 前向词 Meta-left-arrow 后向词 Meta-right-arrow 前向词 Ctrl-A 上线 Ctrl-B 向后字符 Ctrl-C 退出 Ctrl-D 删除字符（或退出） Ctrl-E 行结束 Ctrl-F 转发字符 Ctrl-G 中止 Ctrl-J 接受线 Ctrl-K 杀死线 Ctrl-L 清除屏幕 Ctrl-M 接受线 Ctrl-N 下一个历史记录 Ctrl-P 以前的历史记录 Ctrl-R 反向搜索历史 Ctrl-S 正向搜索历史 Ctrl-T 转置字符 Ctrl-U 丢弃Unix线 Ctrl-W Unix单词清除 Ctrl-Y 拉动 Ctrl-Z 挂起（作业控制在Linux中有效） Ctrl-H (i.e. Backspace) 向后删除字符 Ctrl-I (i.e. Tab) 完成 Meta-B 后退词 Meta-C 大写词 Meta-D 杀死命令 Meta-F 转发字 Meta-L 小写词 Meta-U 大写词 Meta-Y yank-pop Meta-[Backspace] 撤销杀死命令 Meta- 历史开始 Meta-> 历史结束 查询 在mongo shell中，使用find()和findOne()方法执行读取操作。find()方法返回一个游标对象，mongo shell对其进行迭代以在屏幕上打印文档。 默认情况下，mongo打印前20个结果。mongo shell将提示用户“输入”以继续迭代接下来的20个结果。下表提供了mongo shell中的一些常见读取操作： 读取操作 说明描述 db.collection.find() 在集合中找到符合条件的文档。 如果未指定条件或该条件为空（即{}），则读取操作将选择集合中的所有文档。以下示例在用户集合中选择name字段等于“ Joe”的文档：coll = db.users;coll.find( { name: \"Joe\" } );有关指定条件的更多信息，请参见：Specify Equality Condition. db.collection.find(, ) 查找符合条件的文档，并仅返回中的特定字段。以下示例从集合中选择所有文档，但仅返回名称字段和_id字段。 除非明确指定不返回，否则始终返回_id。coll = db.users;coll.find（{}，{name：true}）;有关指定的更多信息，请参见要从查询返回的项目字段。 db.collection.find().sort() 以指定的返回结果。以下示例从集合中选择所有文档，并返回按名称字段升序+1排序的结果。 使用-1降序：coll = db.users;coll.find（）。sort（{name：1}）; db.collection.find().sort() 以指定的返回符合条件的文档。 db.collection.find(`... ).limit( `) 将结果限制为n行。 如果只需要一定数量的行以获得最佳性能，则强烈建议使用。 db.collection.find(`... ).skip( `) 跳过n个结果。 db.collection.count() 返回集合中的文档总数。 db.collection.find().count() 返回与查询匹配的文档总数。count（）忽略limit（）和skip（）。例如，如果有100条记录匹配，但限制为10，则count（）将返回100。这比迭代自己的速度更快，但仍然需要时间。 db.collection.findOne() 查找并返回一个文档。 如果找不到，则返回null。以下示例在用户集合中选择一个名称与“ Joe”匹配的文档：coll = db.users;coll.findOne（{name：“ Joe”}）;在内部，findOne（）方法是带有limit（1）的find（）方法。 有关更多信息和示例，请参阅Query Documents 。 请参阅Query and Projection Operators。 错误检查方法 mongo shell write方法将Write Concern直接集成到方法执行中，并返回一个WriteResult()对象，该对象包含操作结果，包括所有写错误和写关注错误。 行政命令助手 下表列出了一些支持数据库管理的常用方法： JavaScript数据库管理 方法说明 db.fromColl.renameCollection() 将集合从fromColl重命名为。 请参阅Naming Restrictions。 db.getCollectionNames() 获取当前数据库中所有集合的列表。 db.dropDatabase() 删除当前数据库。 另请参见administrative database methods以获取方法的完整列表。 打开其他连接 您可以在mongo shell中创建新的连接。下表显示了创建连接的方法： JavaScript连接创建方法 说明 db = connect(\"/\") 打开一个新的数据库连接。 conn = new Mongo()db = conn.getDB(\"dbname\") 使用新的Mongo（）打开与新服务器的连接。使用连接的getDB（）方法选择数据库。 另请参阅 Opening New Connections以获取有关从mongo shell打开新连接的更多信息。 多样式 下表显示了一些其他方法： 方法 描述 Object.bsonsize(document>) Prints the BSON size of a document> in bytes Object.bsonsize（document>）打印document>的BSON大小（以字节为单位） 其他资源 考虑以下解决mongo shell及其接口的参考资料： mongo mongo Shell Methods Database Commands Aggregation Reference Getting Started Guide 另外，MongoDB源代码存储库包括一个jstests目录，该目录包含许多mongo shell脚本。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations.html":{"url":"docs/MongoDB-CRUD-Operations.html","title":"MongoDB CRUD Operations","keywords":"","body":"MongoDB CRUD Operations（增删改查） 在本页 创建操作 读取操作 更新操作 删除操作 批量写入 CRUD操作为增加、读取、更新、删除文档操作。 创建操作 创建或插入操作会将新文档添加到集合中。 如果该集合当前不存在，则插入操作将创建该集合。 MongoDB提供以下将文档插入集合的方法： db.collection.insertOne() 3.2版中的新功能 db.collection.insertMany() 3.2版中的新功能 在MongoDB中，插入操作针对单个集合。 MongoDB中的所有写操作都是单个文档级别的原子操作。 有关示例，请参见插入文档。 读取操作 读取操作从集合中检索文档； 即查询集合中的文档。 MongoDB提供了以下方法来从集合中读取文档： db.collection.find() 您可以指定查询过滤器或条件以标识要返回的文档。 有关示例，请参见： 查询文件 查询嵌入/嵌套文档 查询数组 查询嵌入式文档数组 更新操作 更新操作会修改集合中的现有文档。 MongoDB提供了以下更新集合文档的方法： db.collection.updateOne() 3.2版中的新功能 db.collection.updateMany() 3.2版中的新功能 db.collection.replaceOne() 3.2版中的新功能 在MongoDB中，更新操作针对单个集合。 MongoDB中的所有写操作都是单个文档级别的原子操作。 您可以指定标准或过滤器，以标识要更新的文档。 这些过滤器使用与读取操作相同的语法。 有关示例，请参见更新文档。 删除操作 删除操作从集合中删除文档。 MongoDB提供以下删除集合文档的方法： db.collection.deleteOne() 3.2版中的新功能 db.collection.deleteMany() 3.2版中的新功能 在MongoDB中，删除操作的目标是分离集合。MongoDB中的所有写操作都是多个文档级别的原子操作。 您可以指定标准或过滤器，以标识要删除的文档。这些过滤器使用与读取操作相同的语法。 有关示例，请参见删除文档。 批量写入 MongoDB提供了批量执行写入操作的功能。有关详细信息，请参见批量写入操作。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/Insert-Documents.html":{"url":"docs/MongoDB-CRUD-Operations/Insert-Documents.html","title":"Insert Document","keywords":"","body":"Insert Documents（插入文档） 该页面提供了MongoDB中插入操作的示例。 建立集合 如果该集合当前不存在，则插入操作将创建该集合。 插入一个文件 db.collection.insertOne()将一个文献插入集合中。 以下示例将一个新文档插入库存集合。 如果文档未指定_id字段，则MongoDB将具有ObjectId值的_id字段添加到新文档中。 请参阅插入行为（Insert Behavior）。 db.inventory.insertOne( { item: \"canvas\", qty: 100, tags: [\"cotton\"], size: { h: 28, w: 35.5, uom: \"cm\" } } ) 返回包含新插入的文档的_id字段值的文档。 有关返回文档的示例，请参见 db.collection.insertOne() reference参考。要检索刚刚插入的文档，请查询集合： db.inventory.find( { item: \"canvas\" } ) 插入多个文件 3.2版中的新功能db.collection.insertMany()可以将多个文档插入一个集合中。 将文档数组传递给该方法。下面的示例将三个新文档插入库存集合。 如果文档未指定_id字段，则MongoDB向每个文档添加带有ObjectId值的_id字段。 请参阅插入行为( Insert Behavior)。 db.inventory.insertMany([ { item: \"journal\", qty: 25, tags: [\"blank\", \"red\"], size: { h: 14, w: 21, uom: \"cm\" } }, { item: \"mat\", qty: 85, tags: [\"gray\"], size: { h: 27.9, w: 35.5, uom: \"cm\" } }, { item: \"mousepad\", qty: 25, tags: [\"gel\", \"blue\"], size: { h: 19, w: 22.85, uom: \"cm\" } } ]) 返回包含新插入的文档_id字段值的文档。 有关示例，请参见参考(reference)。要检索插入的文档，请查询集合： db.inventory.find( {} ) 插入行为 集合创建如果该集合当前不存在，则插入操作将创建该集合。 _id栏位在MongoDB中，存储在集合中的每个文档都需要一个唯一的_id字段作为主键。 如果插入的文档省略_id字段，则MongoDB驱动程序会自动为_id字段生成ObjectId。这也适用于通过upsert：true通过更新操作插入的文档。原子性MongoDB中的所有写操作都是单个文档级别的原子操作。 有关MongoDB和原子性的更多信息，请参见原子性和事务（Atomicity and Transactions）写确认书对于写入问题，您可以指定从MongoDB请求的写入操作的确认级别。 有关详细信息，请参见写关注（Write Concern）。另可参考： db.collection.insertOne() db.collection.insertMany() Additional Methods for Inserts Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/Insert-Documents/Insert-Methods.html":{"url":"docs/MongoDB-CRUD-Operations/Insert-Documents/Insert-Methods.html","title":"Insert Methods","keywords":"","body":"MongoDB 提供了以下方法将文件插入集合： db.collection.insertOne() 将单个文档插入到集合中。 db.collection.insertMany() db.collection.insertMany()将多个文件插入集合中。 db.collection.insert() db.collection.insert()将单个文档或多个文档插入到集合中。 插入的其他方法 以下方法还可以向集合中添加新文档： 与upsert: true选项一起使用时db.collection.update()。 与upsert: true选项一起使用时db.collection.updateOne()。 与upsert: true选项一起使用时db.collection.updateMany()。 与upsert: true选项一起使用时db.collection.findAndModify()。 与upsert: true选项一起使用时db.collection.findOneAndUpdate()。 与upsert: true选项一起使用时db.collection.findOneAndReplace()。 db.collection.save(). db.collection.bulkWrite(). 有关更多信息和示例，请参阅方法的各个 reference 页面。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/Query-Documents.html":{"url":"docs/MongoDB-CRUD-Operations/Query-Documents.html","title":"Query Document","keywords":"","body":"Query Documents（查询文件） 该页面提供了在mongo shell中使用db.collection.find()方法进行查询操作的示例。 此页面上的示例使用库存收集。 要填充库存收集，请运行以下命令： db.inventory.insertMany([ { item: \"journal\", qty: 25, size: { h: 14, w: 21, uom: \"cm\" }, status: \"A\" }, { item: \"notebook\", qty: 50, size: { h: 8.5, w: 11, uom: \"in\" }, status: \"A\" }, { item: \"paper\", qty: 100, size: { h: 8.5, w: 11, uom: \"in\" }, status: \"D\" }, { item: \"planner\", qty: 75, size: { h: 22.85, w: 30, uom: \"cm\" }, status: \"D\" }, { item: \"postcard\", qty: 45, size: { h: 10, w: 15.25, uom: \"cm\" }, status: \"A\" } ]); 选择集合中的所有文档 要选择集合中的所有文档，请将空文档作为查询过滤器参数传递给find方法。 查询过滤器参数确定选择条件： db.inventory.find( {} ) 此操作对应于以下SQL语句： SELECT * FROM inventory 有关该方法的语法的更多信息，请参见find()。 指定平等条件 要指定相等条件，请在查询过滤器文档中（query filter document）使用field>：value>表达式： { : , ... } 下面的示例从inventory中选择状态等于\" D\"的所有文档： db.inventory.find( { status: \"D\" } ) 此操作对应于以下SQL语句： SELECT * FROM inventory WHERE status = \"D\" 使用查询运算符指定条件 查询过滤器文档可以使用查询运算符以以下形式指定条件： { : { : }, ... } 下面的示例从状态为\" A\"或\" D\"等于\"库存\"的inventory中检索所有文档： db.inventory.find( { status: { $in: [ \"A\", \"D\" ] } } ) 注意使用比较运算符的查询会受到\"类型括弧\"的影响。 db.inventory.find( { status: \"A\", $or: [ { qty: { $lt: 30 } }, { item: /^p/ } ] } ) 该操作对应于以下SQL语句： SELECT * FROM inventory WHERE status = \"A\" AND ( qty 注意MongoDB支持正则表达式$ regex查询以执行字符串模式匹配。 附加查询教程 有关其他查询示例，请参见： Query on Embedded/Nested Documents Query an Array Query an Array of Embedded Documents Project Fields to Return from Query Query for Null or Missing Fields 行为 光标db.collection.find()方法将光标返回到匹配的文档。 读取隔离 3.2版中的新功能对于对副本集和副本集分片的读取，读取关注允许客户端为其读取选择隔离级别。 有关更多信息，请参见阅读关注。 附加方法 以下方法也可以从集合中读取文档： db.collection.findOne In aggregation pipeline, the $match pipeline stage provides access to MongoDB queries.( 在聚合管道中，$ match管道步骤提供对MongoDB查询的访问。) 注意db.collection.findOne()方法还执行读取操作以返回单个文档。 在内部，db.collection.findOne()方法是db.collection.find()方法，其限制为1。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/Query-Documents/Iterate-a-Cursor-in-the-mongo-Shell.html":{"url":"docs/MongoDB-CRUD-Operations/Query-Documents/Iterate-a-Cursor-in-the-mongo-Shell.html","title":"Iterate a Cursor in the mongo Shell","keywords":"","body":"Iterate a Cursor in the mongo Shell（在mongo Shell中迭代游标） 在本页面 手动迭代游标 迭代器索引 游标行为 游标信息 db.collection.find()方法返回一个游标。 要访问文档，您需要迭代游标。 但是，在mongo shell中，如果未使用var关键字将返回的游标分配给变量，则该游标将自动迭代多达20次，以打印结果中的前20个文档。以下示例描述了手动迭代游标以访问文档或使用迭代器索引的方法。 手动迭代游标 在mongo shell中，当使用var关键字将find()方法返回的游标分配给变量时，游标不会自动进行迭代。您可以在外壳程序中调用cursor变量以进行多达20次迭代并打印匹配的文档，如以下示例所示： var myCursor = db.users.find( { type: 2 } ); myCursor 您还可以使用游标方法next()来访问文档，如以下示例所示： var myCursor = db.users.find( { type: 2 } ); while (myCursor.hasNext()) printjson(myCursor.next()); } 作为一种替代的打印操作，请考虑使用printjson()辅助方法替换print(tojson())： var myCursor = db.users.find( { type: 2 } ); myCursor.forEach(printjson); 有关游标方法的更多信息，请参见JavaScript游标方法和驱动程序文档(JavaScript cursor methods )。 您可以使用DBQuery.shellBatchSize更改默认值20的迭代数。有关更多信息，请参见使用mongo Shell（Working with the mongo Shell） 迭代器索引 在mongo shell中，可以使用toArray()方法来迭代游标并以数组形式返回文档，如下所示： var myCursor = db.inventory.find( { type: 2 } ); var documentArray = myCursor.toArray(); var myDocument = documentArray[3]; toArray()方法将光标返回的所有文档加载到RAM中；toArray()方法耗尽光标。另外，某些驱动程序通过使用光标上的索引（即cursor [index]）来提供对文档的访问。 这是先调用toArray()方法，然后在结果数组上使用索引的快捷方式。考虑以下示例： var myCursor = db.users.find( { type: 2 } ); var myDocument = myCursor[1]; myCursor [1]等效于以下示例： myCursor.toArray() [1]; 游标行为 关闭非活动游标默认情况下，服务器将在闲置10分钟后或客户端用尽光标后自动关闭光标。 要在mongo shell中覆盖此行为，可以使用cursor.noCursorTimeout()方法： var myCursor = db.users.find().noCursorTimeout(); 设置noCursorTimeout选项后，您必须使用cursor.close()手动关闭游标，或者用尽游标的结果。有关设置noCursorTimeout选项的信息，请参见驱动程序文档。光标隔离当游标返回文档时，其他操作可能会与查询交错。光标批次MongoDB服务器批量返回查询结果。批处理中的数据量不会超过BSON文档的最大大小。若要覆盖批处理的默认大小，请参见batchSize()和limit()。3.4版中的新增功能：find()，aggregate()，listIndexes和listCollections类型的操作每批返回最多16 MB。 batchSize()可以强制使用较小的限制，但不能强制使用较大的限制。默认情况下，find()和aggregate()操作的初始批处理大小为101个文档。随后针对结果游标发出的getMore操作没有默认的批处理大小，因此它们仅受16 MB消息大小的限制。对于包含不带索引的排序操作的查询，服务器必须在返回任何结果之前将所有文档加载到内存中以执行排序。 当您遍历游标并到达返回批处理的末尾时，如果还有更多结果，cursor.next()将执行getMore操作以检索下一个批处理。要查看在迭代游标时批处理中剩余多少文档，可以使用objsLeftInBatch()方法，如以下示例所示： var myCursor = db.inventory.find(); var myFirstDocument = myCursor.hasNext() ? myCursor.next() : null; myCursor.objsLeftInBatch(); 游标信息 db.serverStatus()方法返回包含度量标准字段的文档。 指标字段包含一个带有以下信息的metrics.cursor字段： 自上次服务器重新启动以来超时的游标数 设置了选项DBQuery.Option.noTimeout的打开游标的数量，以防止一段时间不活动后发生超时 “固定”打开游标的数量 打开的游标总数 考虑以下示例，该示例调用db.serverStatus()方法并从结果中访问指标字段，然后从指标字段访问游标字段： db.serverStatus().metrics.cursor 结果是以下文档： { \"timedOut\" : \"open\" : { \"noTimeout\" : , \"pinned\" : , \"total\" : } } 另可参考：db.serverStatus() Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/Query-Documents/Project-Fields-to-Return-from-Query.html":{"url":"docs/MongoDB-CRUD-Operations/Query-Documents/Project-Fields-to-Return-from-Query.html","title":"Project Fields to Return from Query","keywords":"","body":"Project Fields to Return from Query（从查询返回的项目字段） 默认情况下，MongoDB中的查询返回匹配文档中的所有字段。 要限制MongoDB发送给应用程序的数据量，可以包含一个投影文档以指定或限制要返回的字段。本页提供使用mongo shell中的db.collection.find()方法进行投影的查询操作示例。 此页面上的示例使用库存收集。 要填充库存收集，请运行以下命令： db.inventory.insertMany( [ { item: \"journal\", status: \"A\", size: { h: 14, w: 21, uom: \"cm\" }, instock: [ { warehouse: \"A\", qty: 5 } ] }, { item: \"notebook\", status: \"A\", size: { h: 8.5, w: 11, uom: \"in\" }, instock: [ { warehouse: \"C\", qty: 5 } ] }, { item: \"paper\", status: \"D\", size: { h: 8.5, w: 11, uom: \"in\" }, instock: [ { warehouse: \"A\", qty: 60 } ] }, { item: \"planner\", status: \"D\", size: { h: 22.85, w: 30, uom: \"cm\" }, instock: [ { warehouse: \"A\", qty: 40 } ] }, { item: \"postcard\", status: \"A\", size: { h: 10, w: 15.25, uom: \"cm\" }, instock: [ { warehouse: \"B\", qty: 15 }, { warehouse: \"C\", qty: 35 } ] } ]); 返回匹配文档中的所有字段 如果未指定投影文档，则db.collection.find()方法将返回匹配文档中的所有字段。以下示例返回状态为“ A”的清单集合中所有文档的所有字段： db.inventory.find( { status: \"A\" } ) 该操作对应于以下SQL语句： SELECT * from inventory WHERE status = \"A\" 仅返回指定的字段和_id字段 通过将投影文档中的field>设置为1，投影可以显式包括多个字段。 以下操作返回与查询匹配的所有文档。 在结果集中，只有项，状态以及默认情况下id字段会返回到匹配的文档中。 db.inventory.find( { status: \"A\" }, { item: 1, status: 1 } ) 该操作对应于以下SQL语句： SELECT _id, item, status from inventory WHERE status = \"A\" 注意除_id字段外，您无法在投影文档中合并包含和排除语句. 返回除了被排除的字段之外的所有字段 您可以使用投影排除特定字段，而不是列出要在匹配文档中返回的字段。 以下示例返回匹配文档中状态和库存字段以外的所有字段： db.inventory.find( { status: \"A\" }, { status: 0, instock: 0 } ) 注意除_id字段外，您无法在投影文档中合并包含和排除语句。 返回嵌入式文档中的特定字段 您可以返回嵌入式文档中的特定字段。 使用点表示法引用嵌入式字段，并在投影文档中将其设置为1。以下示例返回： _id字段(默认情况下返回). 项目字段. 状态字段. 大小文档中的uom字段. uom字段仍嵌入在尺寸文档中 db.inventory.find( { status: \"A\" }, { item: 1, status: 1, \"size.uom\": 1 } ) 禁止嵌入文档中的特定字段 您可以隐藏嵌入式文档中的特定字段。 使用点表示法引用投影文档中的嵌入字段并将其设置为0。以下示例指定一个投影，以排除尺寸文档内的uom字段。 其他所有字段均在匹配的文档中返回： db.inventory.find( { status: \"A\" }, { \"size.uom\": 0 } ) 阵列中嵌入式文档的投影 使用点表示法可将特定字段投影在嵌入数组的文档中。以下示例指定要返回的投影： _id字段（默认情况下返回） 项目字段 状态字段 库存数组中嵌入的文档中的数量字段 db.inventory.find( { status: \"A\" }, { item: 1, status: 1, \"instock.qty\": 1 } ) 返回数组中的项目特定数组元素 对于包含数组的字段，MongoDB提供以下用于操纵数组的投影运算符:$ elemMatch，$slice和$。以下示例使用$slice投影运算符返回库存数组中的最后一个元素： db.inventory.find( { status: \"A\" }, { item: 1, status: 1, instock: { $slice: -1 } } ) $ elemMatch ，$slice和$是投影要包含在返回数组中的特定元素的唯一方法。 例如，您不能使用数组索引来投影特定的数组元素。 例如 {“ instock.0”：1}投影不会投影第一个元素的数组。 另请参考： Query Documents Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/Query-Documents/Query-an-Array-of-Embedded-Documents.html":{"url":"docs/MongoDB-CRUD-Operations/Query-Documents/Query-an-Array-of-Embedded-Documents.html","title":"Query an Array of Embedded Documents","keywords":"","body":"Query an Array of Embedded Documents（查询嵌入式文档数组） 本页提供使用mongo shell中的db.collection.find()方法对嵌套文档数组进行查询操作的示例。 此页面上的示例使用库存收集。 要填充库存收集，请运行以下命令： db.inventory.insertMany( [ { item: \"journal\", instock: [ { warehouse: \"A\", qty: 5 }, { warehouse: \"C\", qty: 15 } ] }, { item: \"notebook\", instock: [ { warehouse: \"C\", qty: 5 } ] }, { item: \"paper\", instock: [ { warehouse: \"A\", qty: 60 }, { warehouse: \"B\", qty: 15 } ] }, { item: \"planner\", instock: [ { warehouse: \"A\", qty: 40 }, { warehouse: \"B\", qty: 5 } ] }, { item: \"postcard\", instock: [ { warehouse: \"B\", qty: 15 }, { warehouse: \"C\", qty: 35 } ] } ]); 查询嵌套在数组中的文档 下面的示例选择库存数组中的元素与指定文档匹配的所有文档： db.inventory.find( { \"instock\": { warehouse: \"A\", qty: 5 } } ) 整个嵌入式/嵌套文档上的相等匹配要求与指定文档（包括字段顺序）完全匹配。 例如，以下查询与库存集中的任何文档都不匹配： db.inventory.find( { \"instock\": { qty: 5, warehouse: \"A\" } } ) 在文档数组中的字段上指定查询条件 在嵌入文档数组中的字段上指定查询条件 如果您不知道嵌套在数组中的文档的索引位置，请使用点（.）和嵌套文档中的字段名称来连接数组字段的名称。下面的示例选择所有库存数组中包含至少一个嵌入式文档的嵌入式文档，这些文档包含值小于或等于20的字段qty： db.inventory.find( { 'instock.qty': { $lte: 20 } } ) 使用数组索引来查询嵌入式文档中的字段 使用点符号，可以为文档中特定索引或数组位置的字段指定查询条件。 该数组使用基于零的索引。 注意 使用点符号查询时，字段和索引必须在引号内。 下面的示例选择所有库存文件，其中库存数组的第一个元素是包含值小于或等于20的字段qty的文档： db.inventory.find( { 'instock.0.qty': { $lte: 20 } } ) 为文档数组指定多个条件 在嵌套在文档数组中的多个字段上指定条件时，可以指定查询，以使单个文档满足这些条件，或者数组中文档的任何组合（包括单个文档）都满足条件。单个嵌套文档在嵌套字段上满足多个查询条件使用$elemMatch运算符可在一组嵌入式文档上指定多个条件，以使至少一个嵌入式文档满足所有指定条件。下面的示例查询库存数组中至少有一个嵌入式文档的文档，这些文档包含数量等于5的字段和数量等于A的字段仓库： db.inventory.find( { \"instock\": { $elemMatch: { qty: 5, warehouse: \"A\" } } } ) 下面的示例查询库存数组中至少有一个嵌入式文档的文档，该嵌入式文档的qty字段大于10且小于或等于20： db.inventory.find( { \"instock\": { $elemMatch: { qty: { $gt: 10, $lte: 20 } } } } ) 元素组合满足标准如果数组字段上的复合查询条件未使用$elemMatch运算符，则查询将选择其数组包含满足条件的元素的任意组合的那些文档。例如，以下查询匹配文档，其中嵌套在库存阵列中的任何文档的数量字段大于10，并且阵列中任何文档（但不一定是同一嵌入文档）的数量字段小于或等于20： db.inventory.find( { \"instock.qty\": { $gt: 10, $lte: 20 } } ) 以下示例查询库存数组中至少一个包含数量等于5的嵌入式文档和至少一个包含等于A的字段仓库的嵌入式文档（但不一定是同一嵌入式文档）的文档： db.inventory.find( { \"instock.qty\": 5, \"instock.warehouse\": \"A\" } ) 附加查询教程 有关其他查询示例，请参见： Query an Array Query Documents Query on Embedded/Nested Documents Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/Query-Documents/Query-an-Array.html":{"url":"docs/MongoDB-CRUD-Operations/Query-Documents/Query-an-Array.html","title":"Query an Array","keywords":"","body":"Query an Array(查询数组) 本页提供使用mongo shell中的db.collection.find()方法对数组字段进行查询操作的示例。 此页面上的示例使用库存收集。 要填充库存收集，请运行以下命令： db.inventory.insertMany([ { item: \"journal\", qty: 25, tags: [\"blank\", \"red\"], dim_cm: [ 14, 21 ] }, { item: \"notebook\", qty: 50, tags: [\"red\", \"blank\"], dim_cm: [ 14, 21 ] }, { item: \"paper\", qty: 100, tags: [\"red\", \"blank\", \"plain\"], dim_cm: [ 14, 21 ] }, { item: \"planner\", qty: 75, tags: [\"blank\", \"red\"], dim_cm: [ 22.85, 30 ] }, { item: \"postcard\", qty: 45, tags: [\"blue\"], dim_cm: [ 10, 15.25 ] } ]); 匹配数组 要在数组上指定相等条件，请使用查询文档{field>：value>}，其中value>是要匹配的精确数组，包括元素的顺序。下面的示例查询所有文档，其中字段标签值是按指定顺序恰好具有两个元素（红色和空白）的数组： db.inventory.find( { tags: [\"red\", \"blank\"] } ) 相反，如果您希望找到一个同时包含元素“ red”和“ blank”的数组，而不考虑顺序或该数组中的其他元素，请使用$all运算符： db.inventory.find( { tags: { $all: [\"red\", \"blank\"] } } ) 查询数组中的元素 要查询数组字段是否包含至少一个具有指定值的元素，请使用过滤器{field>：value>}，其中value>是元素值。以下示例查询所有文档，其中tag是一个包含字符串“ red”作为其元素之一的数组： db.inventory.find( { tags: \"red\" } ) 要在数组字段中的元素上指定条件，请在 query filter document中使用query operators ： { : { : , ... } } 例如，以下操作查询数组dim_cm包含至少一个值大于25的元素的所有文档。 db.inventory.find( { dim_cm: { $gt: 25 } } ) 为数组元素指定多个条件 在数组元素上指定复合条件时，可以指定查询，以使单个数组元素满足这些条件，或者数组元素的任何组合均满足条件。使用数组元素上的复合过滤条件查询数组以下示例查询文档，其中dim_cm数组包含某种组合满足查询条件的元素； 例如，一个元素可以满足大于15的条件，而另一个元素可以满足小于20的条件，或者单个元素可以满足以下两个条件： db.inventory.find( { dim_cm: { $gt: 15, $lt: 20 } } ) 查询满足多个条件的数组元素使用$elemMatch运算符可在数组的元素上指定多个条件，以使至少一个数组元素满足所有指定的条件。以下示例查询在dim_cm数组中包含至少一个同时大于（$gt）22和小于（$lt）30的元素的文档： db.inventory.find( { dim_cm: { $elemMatch: { $gt: 22, $lt: 30 } } } ) 通过数组索引位置查询元素使用点表示法，可以为元素在数组的特定索引或位置处指定查询条件。 该数组使用基于零的索引。 注意 使用点符号查询时，字段和嵌套字段必须在引号内。 以下示例查询数组dim_cm中第二个元素大于25的所有文档： db.inventory.find( { \"dim_cm.1\": { $gt: 25 } } ) 通过数组长度查询数组使用$size运算符可按元素数量查询数组。 例如，以下选择数组标签具有3个元素的文档. db.inventory.find( { \"tags\": { $size: 3 } } ) 附加查询教程 有关其他查询示例，请参见： Query Documents Query on Embedded/Nested Documents Query an Array of Embedded Documents Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/Query-Documents/Query-for-Null-or-Missing-Fields.html":{"url":"docs/MongoDB-CRUD-Operations/Query-Documents/Query-for-Null-or-Missing-Fields.html","title":"Query for Null or Missing Fields","keywords":"","body":"Query for Null or Missing Fields（查询空字段或缺少字段） MongoDB中的不同查询运算符对空值的处理方式不同。该页面提供了使用mongo shell中的db.collection.find()方法查询空值的操作示例。 此页面上的示例使用库存收集。 要填充库存收集，请运行以下命令： db.inventory.insertMany([ { _id: 1, item: null }, { _id: 2 } ]) 平等过滤器 {item：null}查询匹配包含值是null的item字段或不包含item字段的文档。 db.inventory.find( { item: null } ) 该查询返回集合中的两个文档 类型检查 {item：{$ type：10}}查询只匹配包含item字段值为null的文档； 即item字段的值为BSON Type为Null（类型编号10）： db.inventory.find( { item : { $type: 10 } } ) 该查询仅返回item字段值为null的文档。 存在检查 以下示例查询不包含字段的文档。{item：{$ exists：false}}查询与不包含item字段的文档匹配： db.inventory.find( { item : { $exists: false } } ) 该查询仅返回不包含项目字段的文档。 另请参考： $type和$exists运算符的参考文档。 从MongoDB 4.2开始，用户不能再使用查询过滤器$type：0作为$exists：false的同义词。 要查询空字段或缺少字段，请参阅查询空字段或缺少字段。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/Query-Documents/Query-on-Embedded-or-Nested.html":{"url":"docs/MongoDB-CRUD-Operations/Query-Documents/Query-on-Embedded-or-Nested.html","title":"Query on Embedded or Nested","keywords":"","body":"Query on Embedded/Nested(查询嵌入/嵌套文档) 本页提供使用mongo shell中的db.collection.find()方法对嵌入式/嵌套文档进行查询操作的示例。 此页面上的示例使用库存收集。 要填充库存收集，请运行以下命令： db.inventory.insertMany( [ { item: \"journal\", qty: 25, size: { h: 14, w: 21, uom: \"cm\" }, status: \"A\" }, { item: \"notebook\", qty: 50, size: { h: 8.5, w: 11, uom: \"in\" }, status: \"A\" }, { item: \"paper\", qty: 100, size: { h: 8.5, w: 11, uom: \"in\" }, status: \"D\" }, { item: \"planner\", qty: 75, size: { h: 22.85, w: 30, uom: \"cm\" }, status: \"D\" }, { item: \"postcard\", qty: 45, size: { h: 10, w: 15.25, uom: \"cm\" }, status: \"A\" } ]); 匹配嵌入/嵌套文档 要在作为嵌入/嵌套文档的字段上指定相等条件，请使用查询过滤器文档{field>：value>}，其中value>是要匹配的文档。例如，以下查询选择字段大小等于文档{h：14，w：21，uom：“ cm”}的所有文档： db.inventory.find( { size: { h: 14, w: 21, uom: \"cm\" } } ) 整个嵌入式文档上的相等匹配要求与指定的value>文档完全匹配，包括字段顺序。 例如，以下查询与库存集中的任何文档都不匹配： db.inventory.find( { size: { w: 21, h: 14, uom: \"cm\" } } ) 查询嵌套字段 要在嵌入式/嵌套文档中的字段上指定查询条件，请使用点符号（“ field.nestedField”）。 注意 使用点符号查询时，字段和嵌套字段必须在引号内。 在嵌套字段上指定相等匹配以下示例选择嵌套在size字段中的uom字段等于“ in”的所有文档： db.inventory.find( { \"size.uom\": \"in\" } ) 使用查询运算符指定匹配查询过滤器文档可以使用查询运算符以以下形式指定条件： { : { : }, ... } 以下查询在size字段中嵌入的字段h上使用小于运算符（$lt）： db.inventory.find( { \"size.h\": { $lt: 15 } } ) 指定AND条件以下查询选择嵌套字段h小于15，嵌套字段uom等于“ in”，状态字段等于“ D”的所有文档： db.inventory.find( { \"size.h\": { $lt: 15 }, \"size.uom\": \"in\", status: \"D\" } ) 附加查询教程 有关其他查询示例，请参见： Query Documents Query an Array Query an Array of Embedded Documents Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/Update-Documents.html":{"url":"docs/MongoDB-CRUD-Operations/Update-Documents.html","title":"Update Document","keywords":"","body":"Update Documents（更新文件） 此页面使用以下mongo shell方法： db.collection.updateOne(filter>, update>, options>) db.collection.updateMany(filter>, update>, options>) db.collection.replaceOne(filter>, update>, options>) 此页面上的示例使用库存收集。 要创建和/或填充清单集合，请运行以下命令： db.inventory.insertMany( [ { item: \"canvas\", qty: 100, size: { h: 28, w: 35.5, uom: \"cm\" }, status: \"A\" }, { item: \"journal\", qty: 25, size: { h: 14, w: 21, uom: \"cm\" }, status: \"A\" }, { item: \"mat\", qty: 85, size: { h: 27.9, w: 35.5, uom: \"cm\" }, status: \"A\" }, { item: \"mousepad\", qty: 25, size: { h: 19, w: 22.85, uom: \"cm\" }, status: \"P\" }, { item: \"notebook\", qty: 50, size: { h: 8.5, w: 11, uom: \"in\" }, status: \"P\" }, { item: \"paper\", qty: 100, size: { h: 8.5, w: 11, uom: \"in\" }, status: \"D\" }, { item: \"planner\", qty: 75, size: { h: 22.85, w: 30, uom: \"cm\" }, status: \"D\" }, { item: \"postcard\", qty: 45, size: { h: 10, w: 15.25, uom: \"cm\" }, status: \"A\" }, { item: \"sketchbook\", qty: 80, size: { h: 14, w: 21, uom: \"cm\" }, status: \"A\" }, { item: \"sketch pad\", qty: 95, size: { h: 22.85, w: 30.5, uom: \"cm\" }, status: \"A\" } ] ); 更新集合中的文档 为了更新文档，MongoDB提供了更新操作符（例如$set）来修改字段值。要使用更新运算符，请将以下形式的更新文档传递给更新方法： { : { : , ... }, : { : , ... }, ... } 如果字段不存在，则某些更新操作符（例如$set）将创建该字段。 有关详细信息，请参见各个更新操作员参考。 注意 从MongoDB 4.2开始，MongoDB可以接受聚合管道来指定要进行的修改而不是更新文档。 有关详细信息，请参见方法参考页。 更新单个文档 下面的示例在清单集合上使用db.collection.updateOne()方法更新项目等于“ paper”的第一个文档： db.inventory.updateOne( { item: \"paper\" }, { $set: { \"size.uom\": \"cm\", status: \"P\" }, $currentDate: { lastModified: true } } ) 更新操作： 使用$set运算符将size.uom字段的值更新为“ cm”，将状态字段的值更新为“ P”， 使用$currentDate运算符将lastModified字段的值更新为当前日期。 如果lastModified字段不存在，则$currentDate将创建该字段。 有关详细信息，请参见$currentDate。 更新多个文件 3.2版中的新功能 以下示例在清单集合上使用db.collection.updateMany()方法来更新数量小于50的所有文档： db.inventory.updateMany( { \"qty\": { $lt: 50 } }, { $set: { \"size.uom\": \"in\", status: \"P\" }, $currentDate: { lastModified: true } } ) 更新操作： 使用$set运算符将size.uom字段的值更新为“ in”，将状态字段的值更新为“ P”， 使用$currentDate运算符将lastModified字段的值更新为当前日期。如果lastModified字段不存在，则$currentDate将创建该字段。有关详细信息，请参见$currentDate。 更换文件要替换_id字段以外的文档的全部内容，请将一个全新的文档作为第二个参数传递给db.collection.replaceOne()。替换文档时，替换文档必须仅由字段/值对组成；即不包含更新运算符表达式。替换文档可以具有与原始文档不同的字段。在替换文档中，由于_id字段是不可变的，因此可以省略_id字段。但是，如果您确实包含_id字段，则它必须与当前值具有相同的值。以下示例替换了清单集合中项目“纸张”中的第一个文档： db.inventory.replaceOne( { item: \"paper\" }, { item: \"paper\", instock: [ { warehouse: \"A\", qty: 60 }, { warehouse: \"B\", qty: 40 } ] } ) 行为 原子性MongoDB中的所有写操作都是单个文档级别的原子操作。 有关MongoDB和原子性的更多信息，请参见原子性和事务。_id Field设置后，您将无法更新_id字段的值，也无法将现有文档替换为具有不同_id字段值的替换文档。字段顺序除以下情况外，MongoDB会在执行写操作后保留文档字段的顺序： _id字段始终是文档中的第一个字段。包含字段名称重命名的更新可能导致文档中字段的重新排序。 增补选项如果updateOne()，updateMany()或replaceOne()包含upsert：true，并且没有文档与指定的过滤器匹配，则该操作将创建一个新文档并将其插入。 如果存在匹配的文档，则该操作将修改或替换一个或多个匹配的文档。有关创建的新文档的详细信息，请参见各个方法的参考页。写确认书对于写入问题，您可以指定从MongoDB请求的写入操作的确认级别。 有关详细信息，请参见写关注（Write Concern）。 ​ 另请参考： Updates with Aggregation Pipeline db.collection.updateOne() db.collection.updateMany() db.collection.replaceOne() Additional Methods Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/Update-Documents/Update-Methods.html":{"url":"docs/MongoDB-CRUD-Operations/Update-Documents/Update-Methods.html","title":"Update Methods","keywords":"","body":"Update Methods（更新方法） MongoDB提供了以下方法来更新集合中的文档： db.collection.updateOne() 即使多个文档可能与指定的过滤器匹配，最多更新与指定的过滤器匹配的单个文档。3.2版中的新功能 db.collection.updateMany() 更新所有与指定过滤器匹配的文档。3.2版中的新功能 db.collection.replaceOne() 即使多个文档可能与指定过滤器匹配，也最多替换一个与指定过滤器匹配的文档。3.2版中的新功能 db.collection.update() 更新或替换与指定过滤器匹配的单个文档，或更新与指定过滤器匹配的所有文档。默认情况下，db.collection.update()方法更新单个文档。 要更新多个文档，请使用multi选项。 附加方法以下方法还可以更新集合中的文档： db.collection.findOneAndReplace(). db.collection.findOneAndUpdate(). db.collection.findAndModify(). db.collection.save(). db.collection.bulkWrite(). 有关更多方法和示例，请参见各个方法的参考页。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/Update-Documents/Updates-with-Aggregation-Pipeline.html":{"url":"docs/MongoDB-CRUD-Operations/Update-Documents/Updates-with-Aggregation-Pipeline.html","title":"Updates with Aggregation Pipeline","keywords":"","body":"Updates with Aggregation Pipeline（聚合管道更新） 从MongoDB 4.2开始，您可以将聚合管道用于更新操作。 通过更新操作，聚合管道可以包括以下阶段： $addFields $set $project $unset $replaceRoot $replaceWith 使用聚合管道可以实现更具表达力的更新语句，例如根据当前字段值表达条件更新，或使用另一个字段的值更新一个字段。 例1 创建一个示例students学生集合（如果该集合当前不存在，则插入操作将创建该集合）： db.students.insertMany([ { _id: 1, test1: 95, test2: 92, test3: 90, modified: new Date(\"01/05/2020\") }, { _id: 2, test1: 98, test2: 100, test3: 102, modified: new Date(\"01/05/2020\") }, { _id: 3, test1: 95, test2: 110, modified: new Date(\"01/04/2020\") } ]) 要验证，请查询集合： db.students.find() 以下db.collection.updateOne()操作使用聚合管道使用_id更新文档：3： db.students.updateOne( { _id: 3 }, [ { $set: { \"test3\": 98, modified: \"$$NOW\"} } ] ) 具体地说，管道包括$set阶段，该阶段将test3字段（并将其值设置为98）添加到文档中，并将修改后的字段设置为当前日期时间。 对于当前日期时间，该操作将聚合变量NOW用于（以访问变量，以$$为前缀并用引号引起来）。要验证更新，您可以查询集合： db.students.find().pretty() 例2 创建一个示例students2集合（如果该集合当前不存在，则插入操作将创建该集合）： db.students2.insertMany([ { \"_id\" : 1, quiz1: 8, test2: 100, quiz2: 9, modified: new Date(\"01/05/2020\") }, { \"_id\" : 2, quiz2: 5, test1: 80, test2: 89, modified: new Date(\"01/05/2020\") }, ]) 要验证，请查询集合： db.students2.find() 以下db.collection.updateMany()操作使用聚合管道来标准化文档的字段（即，集合中的文档应具有相同的字段）并更新修改后的字段： db.students2.updateMany( {}, [ { $replaceRoot: { newRoot: { $mergeObjects: [ { quiz1: 0, quiz2: 0, test1: 0, test2: 0 }, \"$$ROOT\" ] } } }, { $set: { modified: \"$$NOW\"} } ] ) 具体来说，管道包括： $replaceRoot阶段，带有$mergeObjects表达式，可为quiz1，quiz2，test1和test2字段设置默认值。 聚集变量ROOT指的是正在修改的当前文档（以访问变量，以$$为前缀并用引号引起来）。 当前文档字段将覆盖默认值。 阶段将修改后的字段更新为当前日期时间。 对于当前日期时间，该操作将聚合变量NOW用于（以访问变量，以$$为前缀并用引号引起来）。 要验证更新，您可以查询集合： db.students2.find() 例3 创建一个示例students3集合（如果该集合当前不存在，则插入操作将创建该集合）： db.students3.insert([ { \"_id\" : 1, \"tests\" : [ 95, 92, 90 ], \"modified\" : ISODate(\"2019-01-01T00:00:00Z\") }, { \"_id\" : 2, \"tests\" : [ 94, 88, 90 ], \"modified\" : ISODate(\"2019-01-01T00:00:00Z\") }, { \"_id\" : 3, \"tests\" : [ 70, 75, 82 ], \"modified\" : ISODate(\"2019-01-01T00:00:00Z\") } ]); 要验证，请查询集合： db.students3.find() 以下db.collection.updateMany()操作使用聚合管道以计算的平均成绩和字母成绩更新文档。 db.students3.updateMany( { }, [ { $set: { average : { $trunc: [ { $avg: \"$tests\" }, 0 ] }, modified: \"$$NOW\" } }, { $set: { grade: { $switch: branches: [ { case: { $gte: [ \"$average\", 90 ] }, then: \"A\" }, { case: { $gte: [ \"$average\", 80 ] }, then: \"B\" }, { case: { $gte: [ \"$average\", 70 ] }, then: \"C\" }, { case: { $gte: [ \"$average\", 60 ] }, then: \"D\" } ], default: \"F\" } } } } ] ) 具体来说，管道包括： $set阶段来计算测试数组元素的截断平均值，并将修改后的字段更新为当前日期时间。 要计算截断的平均值，此阶段使用$avg和$trunc表达式。 对于当前日期时间，该操作将聚合变量NOW用于（以访问变量，以$$为前缀并用引号引起来） 阶段，使用$switch表达式基于平均值添加等级字段。 要验证更新，您可以查询集合： db.students3.find() 例4 创建一个示例students4集合（如果该集合当前不存在，则插入操作将创建该集合）： db.students4.insertMany([ { \"_id\" : 1, \"quizzes\" : [ 4, 6, 7 ] }, { \"_id\" : 2, \"quizzes\" : [ 5 ] }, { \"_id\" : 3, \"quizzes\" : [ 10, 10, 10 ] } ]) 要验证，请查询集合： db.students4.find() 以下db.collection.updateOne()操作使用聚合管道将测验分数添加到具有_id的文档中：2： db.students4.updateOne( { _id: 2 }, [ { $set: { quizzes: { $concatArrays: [ \"$quizzes\", [ 8, 6 ] ] } } } ] ) 要验证，请查询集合： db.students4.find() 例5 创建一个示例温度集合，其中包含摄氏温度（如果该集合当前不存在，则插入操作将创建该集合）： db.temperatures.insertMany([ { \"_id\" : 1, \"date\" : ISODate(\"2019-06-23\"), \"tempsC\" : [ 4, 12, 17 ] }, { \"_id\" : 2, \"date\" : ISODate(\"2019-07-07\"), \"tempsC\" : [ 14, 24, 11 ] }, { \"_id\" : 3, \"date\" : ISODate(\"2019-10-30\"), \"tempsC\" : [ 18, 6, 8 ] } ]) 要验证，请查询集合： db.temperatures.find() 以下db.collection.updateMany()操作使用聚合管道以华氏度中的相应温度更新文档： db.temperatures.updateMany( { }, [ { $addFields: { \"tempsF\": { $map: { input: \"$tempsC\", as: \"celsius\", in: { $add: [ { $multiply: [\"$$celsius\", 9/5 ] }, 32 ] } } } } } ] ) 具体来说，管道由$addFields阶段组成，以添加一个新的数组字段tempsF，其中包含华氏温度。 要将tempsC数组中的每个摄氏温度转换为华氏温度，该阶段将$map表达式与$add和$multiply表达式一起使用。要验证更新，您可以查询集合： db.temperatures.find() 其他例子 有关其他示例，另请参见各种更新方法页面： db.collection.updateOne db.collection.updateMany db.collection.update() db.collection.findOneAndUpdate() db.collection.findAndModify() Bulk.find.update() Bulk.find.updateOne() Bulk.find.upsert() Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/Delete-Documents.html":{"url":"docs/MongoDB-CRUD-Operations/Delete-Documents.html","title":"Delete Document","keywords":"","body":"Delete Documents（删除文件） 此页面使用以下mongo shell方法 db.collection.deleteMany() db.collection.deleteOne() 此页面上的示例使用库存收集。 要填充库存收集，请运行以下命令： db.inventory.insertMany( [ { item: \"journal\", qty: 25, size: { h: 14, w: 21, uom: \"cm\" }, status: \"A\" }, { item: \"notebook\", qty: 50, size: { h: 8.5, w: 11, uom: \"in\" }, status: \"P\" }, { item: \"paper\", qty: 100, size: { h: 8.5, w: 11, uom: \"in\" }, status: \"D\" }, { item: \"planner\", qty: 75, size: { h: 22.85, w: 30, uom: \"cm\" }, status: \"D\" }, { item: \"postcard\", qty: 45, size: { h: 10, w: 15.25, uom: \"cm\" }, status: \"A\" }, ] ); 删除所有文件要删除集合中的所有文档，请将空的过滤器文档{}传递给db.collection.deleteMany()方法。以下示例从清单收集中删除所有文档： db.inventory.deleteMany({}) 该方法返回具有操作状态的文档。 有关更多信息和示例，请参见deleteMany()。删除所有符合条件的文档您可以指定标准或过滤器，以标识要删除的文档。 筛选器使用与读取操作相同的语法。要指定相等条件，请在查询过滤器文档中使用field>：value>表达式： { : ,...} 查询过滤器文档可以使用查询运算符以以下形式指定条件： { : { : }, ... } 要删除所有符合删除条件的文档，请将过滤器参数传递给deleteMany()方法。以下示例从状态字段等于“ A”的清单集合中删除所有文档： db.inventory.deleteMany({ status : \"A\" }) 该方法返回具有操作状态的文档。 有关更多信息和示例，请参见deleteMany()。 仅删除一个符合条件的文档 要删除最多一个与指定过滤器匹配的文档（即使多个文档可以与指定过滤器匹配），请使用db.collection.deleteOne()方法。下面的示例删除状态为“ D”的第一个文档： db.inventory.deleteOne( { status: \"D\" } ) 删除行为指标即使从集合中删除所有文档，删除操作也不会删除索引。原子性MongoDB中的所有写操作都是单个文档级别的原子操作。 有关MongoDB和原子性的更多信息，请参见原子性和事务（Atomicity and Transactions）。写确认书对于写入问题，您可以指定从MongoDB请求的写入操作的确认级别。 有关详细信息，请参见写关注（ Write Concern）。另请参考： db.collection.deleteMany() db.collection.deleteOne() Additional Methods Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/Delete-Documents/Delete-Methods.html":{"url":"docs/MongoDB-CRUD-Operations/Delete-Documents/Delete-Methods.html","title":"Delete Methods","keywords":"","body":"Delete Methods（删除方法） MongoDB提供以下删除集合文档的方法： db.collection.deleteOne() 即使多个文档可能与指定过滤器匹配，也最多删除一个与指定过滤器匹配的文档。3.2版中的新功能 db.collection.deleteMany() 删除所有与指定过滤器匹配的文档。3.2版中的新功能 db.collection.remove() 删除单个文档或与指定过滤器匹配的所有文档。 附加方法 以下方法也可以从集合中删除文档: db.collection.findOneAndDelete(). findOneAndDelete()提供排序选项。该选项允许删除按指定 order 排序的第一个文档。 db.collection.findAndModify(). db.collection.findAndModify()提供了一个排序选项。 该选项允许删除按指定顺序排序的第一个文档. db.collection.bulkWrite(). 有关更多方法和示例，请参见各个方法的参考页。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/Geospatial-Queries.html":{"url":"docs/MongoDB-CRUD-Operations/Geospatial-Queries.html","title":"Geospatial Queries","keywords":"","body":"Geospatial Queries（地理位置查询） 本页 ： Geospatial Data(地理空间数据) Geospatial Indexes(地理空间指数) Geospatial Queries(地理空间查询) Geospatial Models(地理空间模型) Example(例子)MongoDB支持对地理空间数据的查询操作。 本节介绍MongoDB的地理空间功能。 地理空间数据 在MongoDB中，您可以将地理空间数据存储为GeoJSON对象或旧式坐标对。GeoJSON对象要在类似地球的球体上计算几何形状，请将位置数据存储为GeoJSON对象。要指定GeoJSON数据，请使用具有以下内容的嵌入式文档： 一个名为type的字段，用于指定GeoJSON对象类型 一个名为坐标的字段，用于指定对象的坐标。 如果指定纬度和经度坐标，请先列出经度，然后再列出纬度： 有效的经度值在-180到180之间（包括两者）。 有效的纬度值在-90到90之间（包括两者之间）。 : { type: , coordinates: } 例如，要指定GeoJSON Point： location: { type: \"Point\", coordinates: [-73.856077, 40.848447] } 有关MongoDB支持的GeoJSON对象的列表以及示例，请参阅GeoJSON对象。对GeoJSON对象的MongoDB地理空间查询是在球体上计算的； MongoDB使用WGS84参考系统对GeoJSON对象进行地理空间查询。旧版坐标对要计算欧几里得平面上的距离，请将您的位置数据存储为旧坐标对并使用2d索引。 通过将数据转换为GeoJSON Point类型，MongoDB支持通过2dsphere索引对旧坐标对进行球面计算。要将数据指定为旧版坐标对，可以使用数组（首选）或嵌入式文档。通过数组指定（首选）： : [ , ] 如果指定纬度和经度坐标，请先列出经度，然后再列出纬度； 即： : [, ] 有效的经度值在-180到180之间（包括两者）。 有效的纬度值在-90到90之间（包括两者之间）。 通过嵌入式文档指定： : { : , : } 如果指定纬度和经度坐标，则第一个字段（无论字段名称如何）都必须包含经度值，第二个字段必须包含纬度值； 即： : { : , : } 有效的经度值在-180到180之间（包括两者）。 有效的纬度值在-90到90之间（包括两者之间）。 为了指定旧式坐标对，数组比嵌入式文档更可取，因为某些语言不能保证关联地图的排序。 地理空间索引 MongoDB提供以下地理空间索引类型以支持地理空间查询。2dsphere2dsphere索引支持查询，该查询可在类似地球的球体上计算几何形状。要创建2dsphere索引，请使用db.collection.createIndex()方法并指定字符串文字“ 2dsphere”作为索引类型： db.collection.createIndex( { : \"2dsphere\" } ) 其中location field>是其值为GeoJSON对象或旧式坐标对的字段。有关2dsphere索引的更多信息，请参见2dsphere索引。2d2d索引支持在二维平面上计算几何的查询。 尽管索引可以支持在球上进行计算的$nearSphere查询，但如果可能，请对球面查询使用2dsphere索引。要创建2d索引，请使用db.collection.createIndex()方法，将location字段指定为键，并将字符串文字“ 2d”指定为索引类型： db.collection.createIndex( { : \"2d\" } ) 其中location field>是一个值为旧式坐标对的字段。有关2d索引的更多信息，请参见2d索引（ 2d Indexes）。地理空间索引和分片集合分片集合时，不能将地理空间索引用作分片键。但是，可以通过使用不同的字段作为分片键在分片集合上创建地理空间索引。分片集合支持以下地理空间操作： $geoNear聚集阶段 $near和$nearSphere查询运算符（从MongoDB 4.0开始） 从MongoDB 4.0开始，分片集合支持$near和$nearSphere查询。在早期的MongoDB版本中，分片集合不支持$near和$nearSphere查询。相反，对于分片群集，必须使用$ geoNear聚合阶段或geoNear命令（在MongoDB 4.0及更低版本中可用）。您还可以使用$geoWithin和$geoIntersect查询分片群集的地理空间数据。涵盖查询地理空间索引无法涵盖查询。 地理空间查询 注意 对于球形查询，请使用2dsphere索引结果。将2d索引用于球形查询可能会导致错误的结果，例如将2d索引用于环绕两极的球形查询。 地理空间查询操作符MongoDB提供以下地理空间查询操作符： Name Description(说明) $geoIntersects 选择与GeoJSON几何形状相交的几何形状。 2dsphere索引支持$geoIntersects。 $geoWithin 返回点附近的地理空间对象。 需要地理空间索引。 2dsphere和2d索引支持 $near 返回球体上某个点附近的地理空间对象。 需要地理空间索引。 2dsphere和2d索引支持$nearSphere。 $nearSphere Returns geospatial objects in proximity to a point on a sphere. Requires a geospatial index. The 2dsphere and 2d indexes support $nearSphere. 有关更多详细信息（包括示例），请参见各个参考页。地理空间聚集阶段MongoDB提供以下地理空间聚合管道阶段： 步骤 说明 $geoNear 根据与地理空间点的接近程度返回有序的文档流。 合并了地理空间数据的$ match，$ sort和$ limit功能。 输出文档包括附加距离字段，并且可以包括位置标识符字段。$geoNear requires a geospatial index.$geoNear需要地理空间索引。 有关更多详细信息（包括示例），请参见$geoNear参考页。 地理空间模型 MongoDB地理空间查询可以解释平面或球体上的几何。2dsphere索引仅支持球形查询（即解释球形表面几何形状的查询）。2d索引支持平面查询（即解释平面上的几何图形的查询）和某些球形查询。 虽然2d索引支持某些球形查询，但是将2d索引用于这些球形查询可能会导致错误。 如果可能，请对球形查询使用2dsphere索引。下表列出了每个地理空间操作所使用的地理空间查询运算符，受支持的查询： 操作方式 球面/平面查询 笔记 $near (GeoJSON centroid point in this line and the following line, 2dsphere index) 球形 另请参见 $nearSphere 运算符，该运算符与GeoJSON和2dsphere索引一起使用时提供相同的功能。 $near (legacy coordinates, 2d index) 平面 $nearSphere (GeoJSON point, 2dsphere index) 球形 提供与使用GeoJSON点和2dsphere索引的$ near操作相同的功能。对于球形查询，最好使用$ nearSphere而不是$ near运算符，后者在名称中显式指定球形查询。 $nearSphere (legacy coordinates, 2d index) 球形 请改用GeoJSON 点。 $geoWithin : { $geometry: … } 球形 $geoWithin : { $box: … } 平面 $geoWithin : { $polygon: … } 平面 $geoWithin : { $center: … } 平面 $geoWithin : { $centerSphere: … } 球形 $geoIntersects 球形 $geoNear aggregation stage (2dsphere index) 球形 $geoNear aggregation stage (2d index) 平面 例子 使用以下文档创建收集场所： db.places.insert( { name: \"Central Park\", location: { type: \"Point\", coordinates: [ -73.97, 40.77 ] }, category: \"Parks\" } ); db.places.insert( { name: \"Sara D. Roosevelt Park\", location: { type: \"Point\", coordinates: [ -73.9928, 40.7193 ] }, category: \"Parks\" ); db.places.insert( { name: \"Polo Grounds\", location: { type: \"Point\", coordinates: [ -73.9375, 40.8303 ] }, category: \"Stadiums\"} ); 以下操作在location字段上创建2dsphere索引： db.places.createIndex( { location: \"2dsphere\" } ) 以下查询使用$near运算符返回距指定GeoJSON点至少1000米，最多5000米的文档，并按从最近到最远的顺序排序： db.places.find( { location: { $near: { $geometry: { type: \"Point\", coordinates: [ -73.9667, 40.78 ] }, $minDistance: 1000, $maxDistance: 5000 } } } ) 以下操作使用geoNear聚合操作返回与查询过滤器{category：“ Parks”}匹配的文档，这些文档按从最接近指定GeoJSON点的最近到最远的顺序排序： db.places.aggregate( [ { $geoNear: { near: { type: \"Point\", coordinates: [ -73.9667, 40.78 ] }, spherical: **true**, query: { category: \"Parks\" }, distanceField: \"calcDistance\" } } ]) Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/Geospatial-Queries/Find-Restaurants-with-Geospatial-Queries.html":{"url":"docs/MongoDB-CRUD-Operations/Geospatial-Queries/Find-Restaurants-with-Geospatial-Queries.html","title":"Find Restaurants with Geospatial Queries","keywords":"","body":"Find Restaurants with Geospatial Queries（用地理空间查询查找餐馆） 本页 Overview(概述) Distortion(失真) Searching for Restaurants(搜索餐厅) 总览 MongoDB的地理空间索引使您可以高效地对包含地理空间形状和点的集合执行空间查询。为了展示地理空间要素的功能并比较不同的方法，本教程将指导您完成为简单地理空间应用程序编写查询的过程。 本教程将简要介绍地理空间索引的概念，然后演示它们在$geoWithin，$geoIntersects和$nearSphere中的用法。假设您正在设计一个移动应用程序，以帮助用户找到纽约市的餐馆。该应用程序必须： 使用$geoIntersects确定用户当前所在的社区， 使用$geoWithin显示附近的餐馆数量，然后 使用$nearSphere在用户指定距离内查找餐馆。 本教程将使用2dsphere索引来查询有关球形几何的数据。有关球面和平面几何的更多信息，请参见Geospatial Models。 失真 由于将三维球体（例如地球）投影到平面上的性质，当在地图上可视化时，球形几何形状将显得失真。例如，以经度纬度点（0,0），（80,0），（80,80）和（0,80）定义的球形正方形的规格为例。下图描述了此区域覆盖的区域： 搜索餐厅 先决条件从 https://raw.githubusercontent.com/mongodb/docs-assets/geospatial/neighborhoods.json 和 https://raw.githubusercontent.com/mongodb/docs-assets/geospatial/restaurants.json下载示例数据集。 这些分别包含餐厅和社区集合。下载数据集后，将它们导入数据库： mongoimport -c=restaurants mongoimport -c=neighborhoods 地理空间索引，几乎总是可以提高$geoWithin和$geoIntersects查询的性能。由于此数据是地理数据，因此请使用mongo shell在每个集合上创建2dsphere索引： db.restaurants.createIndex({ location: \"2dsphere\" }) db.neighborhoods.createIndex({ geometry: \"2dsphere\" }) 探索数据从mongo shell中检查新创建的餐厅集合中的条目： db.restaurants.findOne() 该查询返回如下文档： { location: type: \"Point\", coordinates: [-73.856077, 40.848447] }, name: \"Morris Park Bake Shop\" } 该餐厅文档对应于下图所示的位置：由于本教程使用2dsphere索引，因此location字段中的几何数据必须遵循GeoJSON格式。现在检查neighborhoods集合中的条目： db.neighborhoods.findOne() 该查询将返回如下文档： { geometry: type: \"Polygon\", coordinates: [[ [ -73.99, 40.75 ], ... [ -73.98, 40.76 ], [ -73.99, 40.75 ] ]] }, name: \"Hell's Kitchen\" } 该几何形状对应于下图所示的区域：查找当前邻居假设用户的移动设备可以为用户提供合理准确的位置，则可以使用$geoIntersects查找用户当前的邻居。假设用户位于经度-73.93414657和纬度40.82302903。 要找到当前邻域，您将使用GeoJSON格式的特殊$geometry字段指定一个点： db.neighborhoods.findOne({ geometry: { $geoIntersects: { $geometry: { type: \"Point\", coordinates: [ -73.93414657, 40.82302903 ] } } } }) 该查询将返回以下结果： { \"_id\" : ObjectId(\"55cb9c666c522cafdb053a68\"), \"geometry\" : \"type\" : \"Polygon\", \"coordinates\" : [ [ [ -73.93383000695911, 40.81949109558767 ], ... ] ] }, \"name\" : \"Central Harlem North-Polo Grounds\" } 查找附近的所有餐厅 您还可以查询以查找给定社区中包含的所有餐馆。 在mongo shell中运行以下命令以查找包含用户的社区，然后计算该社区内的餐馆： var neighborhood = db.neighborhoods.findOne( { geometry: { $geoIntersects: { $geometry: { type: \"Point\", coordinates: [ -73.93414657, 40.82302903 ] } } } } ) db.restaurants.find( { location: { $geoWithin: { $geometry: neighborhood.geometry } } } ).count() 该查询将告诉您，所请求的社区中有127家餐厅，如下图所示：在远处寻找餐馆要查找点指定距离内的餐厅，可以将$geoWithin与$centerSphere一起按未排序的顺序返回结果，或者如果需要按距离对结果进行排序，则可以将NearSphere与$maxDistance一起返回。未排序$geoWithin要查找圆形区域内的餐厅，请将$geoWithin与$centerSphere一起使用。 $centerSpher是MongoDB特定的语法，它通过以弧度指定中心和半径来表示圆形区域。$geoWithin不会以任何特定顺序返回文档，因此它可能会首先向用户显示最远的文档。以下内容将查找距用户五英里范围内的所有餐馆： db.restaurants.find({ location: { $geoWithin: { $centerSphere: [ [ -73.93414657, 40.82302903 ], 5 / 3963.2 ] } } }) 的第二个参数接受以弧度为单位的半径，因此您必须将其除以以英里为单位的地球半径。 有关在距离单位之间进行转换的更多信息，请参见使用球面几何计算距离。用$nearSphere排序您也可以使用$nearSphere并以米为单位指定$maxDistance项。 这将按照从最近到最远的排序顺序返回用户五英里范围内的所有餐馆： var METERS_PER_MILE = 1609.34 db.restaurants.find({ location: { $nearSphere: { $geometry: { type: \"Point\", coordinates: [ -73.93414657, 40.82302903 ] }, $maxDistance: 5 * METERS_PER_MILE } } }) Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/Geospatial-Queries/GeoJSON-Objects.html":{"url":"docs/MongoDB-CRUD-Operations/Geospatial-Queries/GeoJSON-Objects.html","title":"GeoJSON Objects","keywords":"","body":"GeoJSON-Objects对象 在本页面 概观 点 线串 多边形 多点 MULTILINESTRING MultiPolygon GeometryCollection 概观 MongoDB 支持此页面上列出的 GeoJSON object 类型。 要指定 GeoJSON 数据，请使用嵌入式文档： 一个名为type的字段，用于指定GeoJSON object 类型和 一个名为coordinates的字段，用于指定 object 的坐标。 如果指定纬度和经度坐标，请首先列出经度，然后列出纬度： 有效的经度值介于-180和180之间(包括两者)。 有效纬度值介于-90和90之间(包括两者)。 : { type: , coordinates: } GeoJSON objects 上的 MongoDB 地理空间查询在球体上计算; MongoDB 使用WGS84 reference 系统对 GeoJSON objects 进行地理空间查询。 点 以下 example 指定了 GeoJSON 点： {type:\"Point\",coordinates:[40,5]} 线串 以下 example 指定了 GeoJSON 线串： { type: \"LineString\", coordinates: [ [ 40, 5 ], [ 41, 6 ] ] } 多边形 多边形由一组 GeoJSON LinearRing坐标数组组成。这些LinearRings已关闭LineStrings。 Closed LineStrings至少有四个坐标对，并指定与第一个和最后一个坐标相同的位置。 连接曲面上两个点的 line 可能包含也可能不包含在平面上连接这两个点的同一组 co-ordinates。连接曲面上两点的 line 将是一个测地线。仔细检查点以避免共享边缘的错误，以及重叠和其他类型的交叉点。 单环多边形 以下 example 指定具有外环并且没有内环(或孔)的 GeoJSON Polygon。第一个和最后一个坐标必须 order 在 order 中才能关闭多边形： { type: \"Polygon\", coordinates: [ [ [ 0 , 0 ] , [ 3 , 6 ] , [ 6 , 1 ] , [ 0 , 0 ] ] ] } 对于具有单个环的多边形，环不能 self-intersect。 具有多个环的多边形 对于具有多个环的多边形： 第一个描述的环必须是外环。 外圈不能 self-intersect。 任何内圈必须完全由外圈包含。 内圈不能相互交叉或重叠。内圈不能共享边缘。 以下 example 表示具有内部环的 GeoJSON 多边形： { type : \"Polygon\", coordinates : [ [ [ 0 , 0 ] , [ 3 , 6 ] , [ 6 , 1 ] , [ 0 , 0 ] ], [ [ 2 , 2 ] , [ 3 , 3 ] , [ 4 , 2 ] , [ 2 , 2 ] ] ] } 多点 version 中新增 2.6：需要版本 GeoJSON 多点嵌入式文档编码点列表。 { type: \"MultiPoint\", coordinates: [ [ -73.9580, 40.8003 ], [ -73.9498, 40.7968 ], [ -73.9737, 40.7648 ], [ -73.9814, 40.7681 ] ] } MULTILINESTRING version 中新增 2.6：需要版本 以下 example 指定了 GeoJSON MULTILINESTRING： { type: \"MultiLineString\", coordinates: [ [ [ -73.96943, 40.78519 ], [ -73.96082, 40.78095 ] ], [ [ -73.96415, 40.79229 ], [ -73.95544, 40.78854 ] ], [ [ -73.97162, 40.78205 ], [ -73.96374, 40.77715 ] ], [ [ -73.97880, 40.77247 ], [ -73.97036, 40.76811 ] ] ] } MultiPolygon version 中新增 2.6：需要版本 以下 example 指定了 GeoJSON MultiPolygon： { type: \"MultiPolygon\", coordinates: [ [ [ [ -73.958, 40.8003 ], [ -73.9498, 40.7968 ], [ -73.9737, 40.7648 ], [ -73.9814, 40.7681 ], [ -73.958, 40.8003 ] ] ], [ [ [ -73.958, 40.8003 ], [ -73.9498, 40.7968 ], [ -73.9737, 40.7648 ], [ -73.958, 40.8003 ] ] ] ] } GeometryCollection version 中新增 2.6：需要版本 以下 example store GeoJSON 类型GeometryCollection的坐标： { type: \"GeometryCollection\", geometries: [ { type: \"MultiPoint\", coordinates: [ [ -73.9580, 40.8003 ], [ -73.9498, 40.7968 ], [ -73.9737, 40.7648 ], [ -73.9814, 40.7681 ] ] }, { type: \"MultiLineString\", coordinates: [ [ [ -73.96943, 40.78519 ], [ -73.96082, 40.78095 ] ], [ [ -73.96415, 40.79229 ], [ -73.95544, 40.78854 ] ], [ [ -73.97162, 40.78205 ], [ -73.96374, 40.77715 ] ], [ [ -73.97880, 40.77247 ], [ -73.97036, 40.76811 ] ] ] } ] } ​ Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/Bulk-Write-Operations.html":{"url":"docs/MongoDB-CRUD-Operations/Bulk-Write-Operations.html","title":"Bulk Write Operations","keywords":"","body":"Bulk Write Operations（批量写入操作） 在本页面 总览 有序 VS 无序操作 bulkWrite()方法 批量插入分片集合的策略 总览 MongoDB使客户端能够批量执行写操作。 批量写入操作会影响单个集合。 MongoDB允许应用程序确定批量写入操作所需的可接受的确认级别。New in version 3.2. 3.2版本新增db.collection.bulkWrite()方法提供了执行批量插入，更新和删除操作的能力。对于批量插入而言，MongoDB也支持db.collection.insertMany()。 有序 VS 无序操作 批量写操作可以是有序的，也可以无序的。使用操作的有序列表，MongoDB串行地执行操作。 如果在某个单独的写操作的处理过程中发生错误，MongoDB将直接返回而不再继续处理列表中任何剩余的写操作。 请参考【有序的批量写入】 使用无序的操作列表，MongoDB可以并行地执行操作，但是不能保证此行为。 如果某个单独的写操作的处理过程中发生错误，MongoDB将继续处理列表中剩余的写操作。 请参考【无序的批量写入】。在分片集合上执行有序的批量写操作通常比执行无序批量写操作要慢。这是因为对于有序列表而言，每个操作都必须等待上一个操作完成后才能执行。默认情况下，bulkWrite()执行有序的写入。 要指定无序的写入，请在选项文档中设置ordered：false。请参考【操作的执行】 bulkWrite()方法 bulkWrite()支持如下操作： insertOne updateOne updateMany replaceOne deleteOne deleteMany 每个写操作都以数组中的文档形式被传递给bulkWrite()比如说，要执行下面这一系列写操作：characters集合包含以下文档： { \"_id\" : 1, \"char\" : \"Brisbane\", \"class\" : \"monk\", \"lvl\" : 4 }, { \"_id\" : 2, \"char\" : \"Eldon\", \"class\" : \"alchemist\", \"lvl\" : 3 }, { \"_id\" : 3, \"char\" : \"Meldane\", \"class\" : \"ranger\", \"lvl\" : 3 } 接下来的bulkWrite()将在此集合上执行批量写入的操作。 try { db.characters.bulkWrite( [ { insertOne : { \"document\" : { \"_id\" : 4, \"char\" : \"Dithras\", \"class\" : \"barbarian\", \"lvl\" : 4 } } }, { insertOne : { \"document\" : { \"_id\" : 5, \"char\" : \"Taeln\", \"class\" : \"fighter\", \"lvl\" : 3 } } }, { updateOne : { \"filter\" : { \"char\" : \"Eldon\" }, \"update\" : { $set : { \"status\" : \"Critical Injury\" } } } }, { deleteOne : { \"filter\" : { \"char\" : \"Brisbane\"} } }, { replaceOne : { \"filter\" : { \"char\" : \"Meldane\" }, \"replacement\" : { \"char\" : \"Tanys\", \"class\" : \"oracle\", \"lvl\" : 4 } } } ] ); } catch (e) { print(e); } 该操作将返回如下的结果： { \"acknowledged\" : true, \"deletedCount\" : 1, \"insertedCount\" : 2, \"matchedCount\" : 2, \"upsertedCount\" : 0, \"insertedIds\" : { \"0\" : 4, \"1\" : 5 }, \"upsertedIds\" : { } } 想了解更多例子，请参考【bulkWrite() 示例】 批量插入分片集合的策略 大量的插入操作（包括初始数据插入或者定时的数据导入）可能会影响分片集群的性能。对于批量插入，请考虑以下策略： 对分片集合进行预拆分 如果分片集合为空，则该集合只有一个存储在单个分片上的初始数据块，MongoDB必须花一些时间来接收数据，创建拆分并将拆分的块分发到其他分片上。为了避免这种性能开销，您可以对分片集合进行预拆分，请参考【分片集群中的数据块拆分】中的描述。 对mongos的无序写入 要提高对分片集群的写入性能，请使用带有可选参数ordered:false的bulkWrite()方法。mongos会尝试同时将写入发送到多个分片。对于空集合，请首先按照【在分片集群中拆分数据块】中描述的进行集合的预拆分。 避免单调插入带来的瓶颈 如果您的分片键再插入过程中时单调增加的，那么所有插入的数据都会插入到该分片集合的最后一个数据块中，也就是说会落到某单个分片上。因此，集群的插入能力将永远不会超过该单个跟片的插入性能（木桶的短板原理）。如果插入量大于单个分片可以处理的数据量，并且无法避免单调增加的分片键，那么可以考虑对应用程序进行如下修改： 翻转分片键的二进制位。这样可以保留信息的同时避免插入顺序与递增插入值之间的关联性。 交换第一个和最后16比特来实现“随机”插入。 示例下面的C++例子中，交换了生成BSON 对象id(ObjectIds)的前16和末尾16比特值，因此它不再是单调递增的。 using namespace mongo; OID make_an_id() { OID x = OID::gen(); const unsigned char *p = x.getData(); swap( (unsigned short&) p[0], (unsigned short&) p[10] ); return x; } void foo() { // create an object BSONObj o = BSON( \"_id\" 另请参考【分片键】来获得如何选择分片键的相关信息。另请参考【分片键】（尤其是其中【选择分片键】的相关章节） Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/Retryable-Writes.html":{"url":"docs/MongoDB-CRUD-Operations/Retryable-Writes.html","title":"Retryable Writes","keywords":"","body":"Retryable Writes（可重试写入） 在本页面 Prerequisites(前提条件) Retryable Writes and Multi-Document Transactions(可重试写入和多文档交易) Enabling Retryable Writes(启用可重试写入) Retryable Write Operations(可重试的写操作) Behavior(行为) 3.6版的新功能可重试写入允许MongoDB驱动程序在遇到网络错误或在副本集或分片群集中找不到正常的主操作时，一次自动重试某些写入操作。 前提条件 可重试写入具有以下要求： 支持的部署拓扑可重试写入需要副本集或分片群集，并且不支持独立实例。支持的存储引擎可重试写入需要支持文档级锁定的存储引擎，例如WiredTiger或内存中存储引擎。3.6+ MongoDB驱动程序客户端需要为MongoDB 3.6或更高版本更新的MongoDB驱动程序： Java 3.6+Python 3.6+C 1.9+ C# 2.5+Node 3.0+Ruby 2.5+ Perl 2.0+PHPC 1.4+Scala 2.2+ MongoDB版本集群中每个节点的MongoDB版本必须为3.6或更高，集群中每个节点的featureCompatibilityVersion必须为3.6或更高。有关featureCompatibilityVersion标志的更多信息，请参见setFeatureCompatibilityVersion。写确认书使用“写关注”为0的写入操作不可重试。 可重试写入和多文档交易 版本4.0中的新功能事务提交和中止操作是可重试的写操作。如果提交操作或中止操作遇到错误，则无论retryWrites是否设置为false，MongoDB驱动程序都会重试该操作一次。不管retryWrites的值如何，事务内的写操作都不能单独重试。有关交易的更多信息，请参见交易（Transactions）。 启用可重试写入 MongoDB驱动程序需要与MongoDB 3.6和4.0兼容的官方驱动程序，必须在连接字符串中包含retryWrites = true选项，才能为该连接启用可重试的写入。官方兼容MongoDB 4.2的驱动程序默认情况下启用可重试写入。升级到需要可重试写入的4.2兼容驱动程序的应用程序可以省略retryWrites = true选项。升级到需要禁用可重试写入功能的4.2兼容驱动程序的应用程序必须在连接字符串中包含retryWrites = false。 Mongo shell要在mongo shell中启用可重试写入，请使用--retryWrites命令行选项： mongo --retryWrites 可重试的写操作 当发出已确认的写入问题时，以下写入操作可以重试； 例如，Write Concern不能为{w：0}。 注意事务内的写操作不可单独重试 Methods（方法） Descriptions（说明） db.collection.insertOne()db.collection.insert()db.collection.insertMany() 插入操作 db.collection.updateOne()db.collection.replaceOne()db.collection.save()db.collection.update() where multi is false 单文档更新操作。 db.collection.deleteOne()db.collection.remove() where justOne is true 单个文档删除操作 db.collection.findAndModify()db.collection.findOneAndDelete()db.collection.findOneAndReplace()db.collection.findOneAndUpdate() 查找和定义操作。所有查找定义操作都是单个文档操作。 db.collection.bulkWrite() 具有以下写操作：. insertOne. updateOne. replaceOne. deleteOne 仅由单文档写操作组成的批量写操作。可重试的批量操作可以包括指定写操作的任何组合，但不能包括任何多文档写操作，例如updateMany。 Bulk operations for:. Bulk.find.removeOne(). Bulk.find.replaceOne(). Bulk.find.replaceOne() 仅由单文档写操作组成的批量写操作。可重试的批量操作可以包括指定写操作的任何组合，但不能包括任何多文档写操作，例如update，它为multi选项指定true。 分片键值更新从MongoDB 4.2开始，您可以通过发布可重试写入或事务处理中的单文档update / findAndModify操作来更新文档的分片键值（除非分片键字段是不可变的_id字段）。 有关详细信息，请参见更改文档的分片键值。 MongoDB 4.2将重试遇到重复密钥异常的某些单文档upsert（更新使用upsert：true和multi：false）。 有关条件，请参阅Upsert上的重复键错误。 在MongoDB 4.2之前，MongoDB不会重试遇到重复键错误的upsert操作。 行为 持续的网络错误MongoDB可重试写入仅进行一次重试尝试。 这有助于解决瞬态网络错误和副本集选择，但不能解决持久性网络错误。故障转移期如果驱动程序在目标副本集或分片的群集分片中找不到正常的主数据库，则驱动程序将等待serverSelectionTimeoutMS毫秒确定新的主数据库，然后重试。 可重试的写操作不会解决故障转移时间超过serverSelectionTimeoutMS的实例。 警告如果客户端应用程序localLogicalSessionTimeoutMinutes在发出写操作之后变得暂时不响应，而不是发出更多响应，则有可能当客户端应用程序开始响应（不重新启动）时，可以重试并再次应用写操作。 Upsert上的重复键错误仅当操作满足以下所有条件时，MongoDB 4.2才会重试由于重复键错误而失败的单文档upsert操作(即:upsert : true和multi : false): 目标集合具有导致重复键错误的唯一索引。 更新匹配条件为： 单个相等谓词{ \"fieldA\" : \"valueA\" }，or 相等谓词的逻辑与{ \"fieldA\" : \"valueA\", \"fieldB\" : \"valueB\" } 唯一索引键模式中的字段集与更新查询谓词中的字段集匹配。 更新操作不会修改查询谓词中的任何字段。下表包含服务器可以或不能在重复键错误时重试的upsert操作示例： 唯一索引键模式                更新操作                          可重试 { _id ： 1 } db.collName.updateOne( { _id : ObjectId(\"1aa1c1efb123f14aaa167aaa\") }, { $set : { fieldA : 25 } }, { upsert : true } ) 是 { fieldA ： 1 } db.collName.updateOne( { fieldA : { $in : [ 25 ] } }, { $set : { fieldB : \"someValue\" } }, { upsert : true } ) 是 { fieldA：1， fieldB ：1} db.collName.updateOne( { fieldA : 25, fieldB : \"someValue\" }, { $set : { fieldC : false } }, { upsert : true } ) 是 { fieldA ： 1 } db.collName.updateOne( { fieldA : { $lte : 25 } }, { $set : { fieldC : true } }, { upsert : true } ) 没有查询谓词fieldA不等于 { fieldA ： 1 } db.collName.updateOne( { fieldA : { $in : [ 25 ] } }, { $set : { fieldA : 20 } }, { upsert : true } ) 没有更新操作修改查询谓词中指定的字段。 { _id ： 1 } db.collName.updateOne( { fieldA : { $in : [ 25 ] } }, { $set : { fieldA : 20 } }, { upsert : true } ) 没有查询谓词字段集（fieldA）与索引关键字字段集（）不匹配_id。 { fieldA ： 1 } db.collName.updateOne( { fieldA : 25, fieldC : true }, { $set : { fieldD : false } }, { upsert : true } ) 没有这组查询谓词的字段（fieldA，fieldC）不匹配组索引键的字段（fieldA） 诊断程序 版本3.6.3中的新功能 serverStatus命令及其mongo shell帮助程序db.serverStatus()在Transactions节中包含有关可重试写入的统计信息。 针对本地数据库的可重试写入 官方的MongoDB 4.2系列驱动程序默认情况下启用重试写入。 除非明确禁止重试写入，否则写入本地数据库的应用程序在升级到4.2系列驱动程序时将遇到写入错误。要禁用可重试写入，请在MongoDB集群的连接字符串(connection string )中指定retryWrites = false。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/Retryable-Reads.html":{"url":"docs/MongoDB-CRUD-Operations/Retryable-Reads.html","title":"Retryable Reads","keywords":"","body":"Retryable Reads 在本页面 Prerequisites(前提条件) Enabling Retryable Reads(启用可重试读取) Retryable Read Operations(可重试的读取操作) Behavior(行为) 可重试读取允许MongoDB驱动程序在遇到某些网络或服务器错误时，可以一次自动重试某些读取操作。 前提条件 最低驱动程序版本 ​ 与MongoDB Server 4.2及更高版本兼容的官方MongoDB驱动程序支持可重试读取。 ​ 有关官方MongoDB驱动程序的更多信息，请参阅 MongoDB驱动程序。 最低服务器版本 ​ 如果连接到MongoDB Server 3.6或更高版本，驱动程序只能重试读取操作。 启用可重试读取 与MongoDB Server 4.2及更高版本兼容的官方MongoDB驱动程序默认情况下启用重试读取。要显式禁用可重试读取，请retryReads=false在部署的 连接字符串中指定。 在mongo外壳不支持重试读取。 可重试的读取操作 MongoDB驱动程序支持重试以下读取操作。该列表引用了每种方法的一般描述。有关特定的语法和用法，请参阅该方法的驱动程序文档。 方法 内容描述 Collection.aggregate Collection.count Collection.countDocuments Collection.distinct Collection.estimatedDocumentCount Collection.find Database.aggregate CRUD API读取操作. 对于Collection.aggregate和Database.aggregate，驱动程序只能重试不包括写阶段的聚合管道，如$out或$merge。 Collection.watch Database.watch MongoClient.watch 更改流操作 MongoClient.listDatabases Database.listCollections Collection.listIndexes 枚举操作 GridFS操作由Collection.find （例如GridFSBucket.openDownloadStream）支持 GridFS文件下载操作 MongoDB驱动程序可能包括对其他操作的可重试支持，例如辅助方法或包装可重试读操作的方法。根据驱动程序文档 确定方法是否显式支持可重试的读取。 也可以看看 可重试读取规范：支持的读取操作 不支持的读取操作 以下操作不支持可重试的读取： db.collection.mapReduce() getMore 传递给通用Database.runCommand帮助程序的任何读取命令，都与读取或写入命令无关。 行为 持久性网络错误 MongoDB可重试读取仅进行一次重试。这有助于解决瞬态网络错误或 副本集选择，但不能解决持久性网络错误。 故障转移期间 在重试读取操作之前，驱动程序将使用读取命令的原始读取首选项执行服务器选择。如果驱动程序无法使用原始读取首选项选择服务器进行重试，则驱动程序将返回原始错误。 驱动程序serverSelectionTimeoutMS在执行服务器选择之前会等待毫秒。可重试读取不能解决等待后不存在合格服务器的实例 serverSelectionTimeoutMS。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/SQL-to-MongoDB-Mapping-Chart.html":{"url":"docs/MongoDB-CRUD-Operations/SQL-to-MongoDB-Mapping-Chart.html","title":"SQL to MongoDB Mapping Chart","keywords":"","body":"SQL to MongoDB Mapping Chart（SQL到MongoDB的映射图表） 在本页面 Terminology and Concepts(术语和概念) Executables(可执行性文件) Examples(例子) Further Reading(进一步阅读)除了下面的图表，您可能还需要考虑“常见问题”部分，以选择有关MongoDB的常见问题。 术语和概念 下表介绍了各种SQL术语和概念以及相应的MongoDB术语和概念。 SQL术语/概念 MongoDB术语/概念 database database table collection row document or BSON document column field index index table joins $lookup, embedded documents（嵌入文档） primary key（指定任何唯一的列或列组合作为主键。） primary key（在MongoDB中，主键自动设置为_id字段。） aggregation (e.g. group by) aggregation pipelineSee the SQL to Aggregation Mapping Chart. SELECT INTO NEW_TABLE $outSee the SQL to Aggregation Mapping Chart. MERGE INTO TABLE $merge (Available starting in MongoDB 4.2)See the SQL to Aggregation Mapping Chart. Transactions transactions在许多情况下，非规范化数据模型（嵌入式文档和数组）将继续是您数据和用例的最佳选择，而不是多文档事务。也就是说，在许多情况下，对数据进行适当的建模将最大程度地减少对多文档交易的需求。 可执行文件 下表显示了一些数据库可执行文件和相应的MongoDB可执行文件。 该表并非详尽无遗。 MongoDB MySQL Oracle Informix DB2 Database Server mongod mysqld oracle IDS DB2 Server Database Client mongo mysql sqlplus DB-Access DB2 Client 例子 下表显示了各种SQL语句和相应的MongoDB语句。 表格中的示例假定以下条件： SQL示例假定一个名为people的表。 MongoDB示例假定一个名为people的集合，其中包含以下原型的文档： { _id: ObjectId(\"509a8fb2f3f4948bd2f983a0\"), user_id: \"abc123\", age: 55, status: 'A' } 创建和修改下表列出了与表级操作和相应的MongoDB语句相关的各种SQL语句。 SQL Schema Statements MongoDB Schema Statements CREATE TABLE people ( id MEDIUMINT NOT NULL AUTO_INCREMENT, user_id Varchar(30), age Number, status char(1), PRIMARY KEY (id)) Implicitly created on first insertOne() or insertMany() operation. The primary key _id is automatically added if _id field is not specified.db.people.insertOne( { user_id: \"abc123\", age: 55, status: \"A\" } )However, you can also explicitly create a collection:db.createCollection(\"people\") ALTER TABLE peopleADD join_date DATETIME 集合不描述或不强制其文件结构； 即在集合级别没有结构上的更改。但是，在文档级别，updateMany()操作可以使用$set运算符将字段添加到现有文档中。db.people.updateMany( { }, { $set: { join_date: new Date() } }) ALTER TABLE peopleDROP COLUMN join_date 集合不描述或不强制其文件结构； 即在集合级别没有结构上的更改。但是，在文档级别，updateMany()操作可以使用$unset运算符将字段添加到现有文档中。db.people.updateMany( { }, { $unset: { \"join_date\": \"\" } }) CREATE INDEX idx_user_id_ascON people(user_id) db.people.createIndex( { user_id: 1 } ) CREATE INDEX idx_user_id_asc_age_descON people(user_id, age DESC) db.people.createIndex( { user_id: 1, age: -1 } ) DROP TABLE people db.people.drop() 有关使用的方法和运算符的更多信息，请参见： db.collection.insertOne() db.collection.updateMany() $set db.collection.insertMany() db.collection.createIndex() $unset db.createCollection() db.collection.drop() 另看： Databases and Collections(数据库和馆藏) Documents(文件资料) Indexes(指标) Data Modeling Concepts(数据建模概念) 插入 下表显示了与将记录插入表和相应的MongoDB语句有关的各种SQL语句。 SQL INSERT Statements MongoDB insertOne() Statements INSERT INTO people(user_id, age, status)VALUES (\"bcd001\", 45, \"A\") db.people.insertOne( { user_id: \"bcd001\", age: 45, status: \"A\" }) 有关更多信息，请参见db.collection.insertOne()。 也可以看看： Insert Documents(插入文件) db.collection.insertMany() Databases and Collections(数据库和馆藏) Documents(文件资料) 选择下表显示了与从表中读取记录和相应的MongoDB语句有关的各种SQL语句。 注意除非通过投影明确排除，否则find()方法始终在返回的文档中包含_id字段。 下面的某些SQL查询可能包含一个_id字段来反映这一点，即使该字段未包含在相应的find()查询中也是如此。 SQL SELECT 语句 MongoDB find() 语句 SELECT *FROM people db.people.find() SELECT id, user_id, statusFROM people db.people.find( { }, { user_id: 1, status: 1 }) SELECT user_id, statusFROM people db.people.find( { }, { user_id: 1, status: 1, _id: 0 }) SELECT FROM people*WHERE status = \"A\" db.people.find( { status: \"A\" }) SELECT user_id, statusFROM peopleWHERE status = \"A\" db.people.find( { status: \"A\" }, { user_id: 1, status: 1, _id: 0 }) SELECT FROM people*WHERE status != \"A\" db.people.find( { status: { $ne: \"A\" } }) SELECT FROM peopleWHERE status = \"A\"*AND age = 50 db.people.find( { status: \"A\", age: 50 }) SELECT FROM peopleWHERE status = \"A\"*OR age = 50 db.people.find( { $or: [ { status: \"A\" } , { age: 50 } ] }) SELECT FROM people*WHERE age > 25 db.people.find( { age: { $gt: 25 } }) SELECT FROM people*WHERE age db.people.find( { age: { $lt: 25 } }) SELECT FROM peopleWHERE age > 25*AND age db.people.find( { age: { $gt: 25, $lte: 50 } }) SELECT FROM peopleWHERE user_id *like \"%bc%\" db.people.find( { userid: /bc/ } )_ordb.people.find( { user_id: { $regex: /bc/ } } ) SELECT FROM peopleWHERE user_id *like \"bc%\" db.people.find( { userid: /^bc/ } )_ordb.people.find( { user_id: { $regex: /^bc/ } } ) SELECT FROM peopleWHERE status = \"A\"ORDER BY user_id *ASC db.people.find( { status: \"A\" } ).sort( { user_id: 1 } ) SELECT FROM peopleWHERE status = \"A\"ORDER BY user_id *DESC db.people.find( { status: \"A\" } ).sort( { user_id: -1 } ) SELECT COUNT()*FROM people db.people.count()ordb.people.find().count() SELECT COUNT(user_id)FROM people db.people.count( { userid: { $exists: true } } )_ordb.people.find( { user_id: { $exists: true } } ).count() SELECT COUNT()FROM people*WHERE age > 30 db.people.count( { age: { $gt: 30 } } )ordb.people.find( { age: { $gt: 30 } } ).count() SELECT DISTINCT(status)FROM people db.people.aggregate( [ { $group : { _id : \"$status\" } } ] )or, for distinct value sets that do not exceed the BSON size limitdb.people.distinct( \"status\" ) SELECT FROM people*LIMIT 1 db.people.findOne()ordb.people.find().limit(1) SELECT FROM people*LIMIT 5SKIP 10 db.people.find().limit(5).skip(10) EXPLAIN SELECT FROM people*WHERE status = \"A\" db.people.find( { status: \"A\" } ).explain() 有关使用的方法和运算符的更多信息，请参见： .db.collection.find() .$ne .db.collection.distinct() .$and .db.collection.findOne() .$or .limit() .$gt .skip() .$lt .explain() .$exists .sort() .$lte .count() .$regex 另看： Query Documents(查看文件) Query and Projection Operators(查询和投影运算符) mongo Shell Methods(mongo Shell 运算符) 更新记录下表显示了与更新表中的现有记录和相应的MongoDB语句有关的各种SQL语句。 SQL Update Statements MongoDB updateMany() Statements UPDATE peopleSET status = \"C\"WHERE age > 25 db.people.updateMany( { age: { $gt: 25 } }, { $set: { status: \"C\" } }) UPDATE peopleSET age = age + 3WHERE status = \"A\" db.people.updateMany( { status: \"A\" } , { $inc: { age: 3 } }) 有关示例中使用的方法和运算符的更多信息，请参见： db.collection.updateMany() $gt $set $inc 另看： Update Documents(更新文件) Update Operators(更新运算符) db.collection.updateOne() db.collection.replaceOne() 删除记录下表显示了与从表中删除记录和相应的MongoDB语句有关的各种SQL语句。 SQL Delete Statements MongoDB deleteMany() Statements DELETE FROM peopleWHERE status = \"D\" db.people.deleteMany( { status: \"D\" } ) DELETE FROM people db.people.deleteMany({}) 获得更多信息，请参见：db.collection.deleteMany().另看： Delete Documents(删除文件) db.collection.deleteOne() 进一步阅读 如果您正在考虑将SQL应用程序迁移到MongoDB，请下载《 MongoDB应用程序现代化指南》。 下载内容包括以下资源： 演示使用MongoDB进行数据建模的方法 白皮书涵盖了从RDBMS数据模型迁移到MongoDB的最佳实践和注意事项 参考MongoDB模式及其等效RDBMS 应用程序现代化记分卡 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/Text-Search.html":{"url":"docs/MongoDB-CRUD-Operations/Text-Search.html","title":"Text Search","keywords":"","body":"Text Search（文本搜索） 在本页面 Overview(总览) Example(例子) Language Support(语言支持) MONGODB ATLAS搜索 利用Atlas Search，您可以轻松地在MongoDB数据之上构建快速的，基于相关性的搜索功能。 立即在MongoDB Atlas（我们完全托管的数据库即服务）上试用。 总览 MongoDB支持执行字符串内容的文本搜索的查询操作。 为了执行文本搜索，MongoDB使用文本索引和$text运算符。 注意视图不支持文本搜索。 例子 此示例演示了如何在仅指定文本字段的情况下构建文本索引并使用它来查找咖啡店。使用以下文档创建一个集合存储： db.stores.insert( [ { _id: 1, name: \"Java Hut\", description: \"Coffee and cakes\" }, { _id: 2, name: \"Burger Buns\", description: \"Gourmet hamburgers\" }, { _id: 3, name: \"Coffee Shop\", description: \"Just coffee\" }, { _id: 4, name: \"Clothes Clothes Clothes\", description: \"Discount clothing\" }, { _id: 5, name: \"Java Shopping\", description: \"Indonesian goods\" } ] ) 文字索引MongoDB提供文本索引以支持对字符串内容的文本搜索查询。 文本索引可以包含任何值为字符串或字符串元素数组的字段。 要执行文本搜索查询，您的集合上必须有一个文本索引。 一个集合只能有一个文本搜索索引，但是该索引可以涵盖多个字段。 例如，您可以在mongo shell中运行以下命令，以允许在名称和描述字段中进行文本搜索： db.stores.createIndex( { name: \"text\", description: \"text\" } ) $text操作符使用$text查询运算符可对具有文本索引的集合执行文本搜索。$text将使用空格和大多数标点符号作为分隔符来标记搜索字符串，并对搜索字符串中的所有此类标记执行逻辑或。例如，您可以使用以下查询从列表“ coffee”，“ shop”和“ java”中查找包含任何术语的所有商店： db.stores.find( { $text: { $search: \"java coffee shop\" } } ) 准确的短语您还可以通过将它们括在双引号中来搜索确切的短语。 如果$search字符串包含短语和单个词，则文本搜索将仅匹配包含该短语的文档。例如，以下将查找包含“咖啡店”的所有文档： db.stores.find( { $text: { $search: \"\\\"coffee shop\\\"\" } } ) 更多信息参见：Phrases.期限排除要排除一个单词，可以在前面加上一个“-”字符。 例如，要查找所有包含“ java”或“ shop”但不包含“ coffee”的商店，请使用以下命令： db.stores.find( { $text: { $search: \"java shop -coffee\" } } ) 排序默认情况下，MongoDB将以未排序的顺序返回结果。 但是，文本搜索查询将为每个文档计算相关性得分，以指定文档与查询的匹配程度。要按相关性得分的顺序对结果进行排序，必须显式投影$meta textScore字段并对其进行排序： db.stores.find( { $text: { $search: \"java coffee shop\" } }, { score: { $meta: \"textScore\" } } ).sort( { score: { $meta: \"textScore\" } } ) 聚合管道中也提供文本搜索。 语言支持 MongoDB支持多种语言的文本搜索。 有关支持的语言列表，请参见文本搜索语言。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/Text-Search/Text-indexes.html":{"url":"docs/MongoDB-CRUD-Operations/Text-Search/Text-indexes.html","title":"Test indexes","keywords":"","body":"Text Indexes（文本索引） MongoDB 提供文本索引以支持对 string 内容的文本搜索查询。 text索引可以包含 value 是 string 或 string 元素的 array 的任何字段。 要执行文本搜索查询，您的集合上必须具有text索引。一个集合只能有一个文本搜索索引，但该索引可以覆盖多个字段。 对于 example，您可以在mongo shell 中运行以下内容，以允许在name和description字段上进行文本搜索： db.stores.createIndex( { name: \"text\", description: \"text\" } ) 有关文本索引的完整参考，请参见 Text Indexes部分，包括行为，标记化和属性。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:35:01 "},"docs/MongoDB-CRUD-Operations/Text-Search/Text-Search-Operators.html":{"url":"docs/MongoDB-CRUD-Operations/Text-Search/Text-Search-Operators.html","title":"Text Search Operators","keywords":"","body":"Text Search Operators（文本搜索运算符） 在本页面 Query Framework(查询框架) Aggregation Framework(聚合框架) 注意视图不支持文本搜索。 查询框架 使用$text查询运算符可对具有文本索引的集合执行文本搜索。$ text将使用空格和大多数标点符号作为分隔符来标记搜索字符串，并对搜索字符串中的所有此类标记执行逻辑或。例如，您可以使用以下查询从列表“ coffee”，“ shop”和“ java”中查找包含任何术语的所有商店： db.stores.find( { $text: { $search: \"java coffee shop\" } } ) 使用$meta查询运算符可获取并匹配每个匹配文档的相关性得分。 例如，要按相关性顺序订购咖啡店列表，请运行以下命令： db.stores.find( { $text: { $search: \"coffee shop cake\" } }, { score: { $meta: \"textScore\" } } ).sort( { score: { $meta: \"textScore\" } } ) 有关$text和$meta operators 的更多信息，包括限制和行为，请参阅： $text 参考页面 $text 查询示例 $meta projection operator 聚合框架 在使用Aggregation框架时，请将$match与$text表达式一起使用以执行文本搜索查询。 要按相关性得分的顺序对结果进行排序，请在$ sort阶段使用$meta聚合运算符。有关聚合框架中文本搜索的更多信息和示例，请参阅 Text Search in the Aggregation Pipeline. $meta投影运算符的行为和要求与$meta聚合运算符的行为和要求不同。 有关$meta聚合运算符的详细信息，请参见$meta聚合运算符参考页。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/Text-Search/Text-Search-in-the-Aggregation-Pipeline.html":{"url":"docs/MongoDB-CRUD-Operations/Text-Search/Text-Search-in-the-Aggregation-Pipeline.html","title":"Text Search in the Aggregation Pipeline","keywords":"","body":"Text Search in the Aggregation Pipeline（聚合管道中的文本搜索） 在本页面： Restrictions(限制条件) Text Score(文字分数) Calculate the Total Views for Articles that Contains a Word(计算包含单词的文章的总浏览量) Return Results Sorted by Text Search Score(返回结果按文本搜索分数排序) Match on Text Score(文字分数匹配) Specify a Language for Text Search(指定用于文本搜索的语言) 在聚合管道中，可以在$match阶段使用$text查询运算符来进行文本搜索。 限制条件 有关常规的$text运算符限制，请参见运算符限制。此外，聚合管道中的文本搜索具有以下限制： 包含$text的$match阶段必须是管道中的第一阶段。 文本运算符在阶段只能出现一次。 文本运算符表达式不能出现在$or或$not表达式中。 默认情况下，文本搜索不会按匹配分数的顺序返回匹配的文档。在$sort阶段使用$meta聚合表达式。 文字分数 运算符为在索引字段中包含搜索词的每个文档分配一个分数。分数表示文档与给定文本搜索查询的相关性。分数可以是$sort管道规范的一部分，也可以是投影表达式的一部分。 {$ meta：“ textScore”}表达式提供有关$text操作处理的信息。有关访问投影或排序分数的详细信息，请参见$meta聚合。 元数据仅在包含$text操作的$match阶段之后可用。 例子 以下示例假定集合articles在字段subject上具有文本索引： db.articles.createIndex( { subject: \"text\" } ) 计算包含单词的文章的总浏览量 以下聚合在$match阶段搜索术语蛋糕，并在$group阶段计算匹配文档的总视图。 db.articles.aggregate( [ { $match: { $text: { $search: \"cake\" } } }, { $group: { _id: **null**, views: { $sum: \"$views\" } } } ] ) 返回结果按文本搜索分数排序 要按文本搜索分数排序，请在$sort阶段包含一个$meta表达式。 以下 example 匹配术语cake或tea，按降序 order 中的textScore排序，并仅返回结果集中的title字段。 db.articles.aggregate( [ { $match: { $text: { $search: \"cake tea\" } } }, { $sort: { score: { $meta: \"textScore\" } } }, { $project: { title: 1, _id: 0 } } ] ) 指定的元数据确定 sort order。对于 example，\"textScore\"元数据按降序 order 排序。有关元数据的更多信息，请参阅$meta，以及覆盖元数据的默认排序 order 的示例。 文字分数匹配 “ textScore”元数据可用于包含$text操作的$match阶段之后的投影，排序和条件。以下 example 匹配术语cake或tea，投影title和score字段，然后仅返回score大于1.0的文档。 db.articles.aggregate( [ { $match: { $text: { $search: \"cake tea\" } } }, { $project: { title: 1, _id: 0, score: { $meta: \"textScore\" } } }, { $match: { score: { $gt: 1.0 } } } ] ) 指定用于文本搜索的语言 以下聚合在西班牙语中搜索在$match阶段中包含术语saber但不包含术语claro的文档，并在$group阶段中计算匹配文档的总视图。 db.articles.aggregate( [ { $match: { $text: { $search: \"saber -claro\", $language: \"es\" } } }, { $group: { _id: null, views: { $sum: \"$views\" } } } ] ) ​ Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/Text-Search/Text-Search-Languages.html":{"url":"docs/MongoDB-CRUD-Operations/Text-Search/Text-Search-Languages.html","title":"Text Search Languages","keywords":"","body":"Text Search Languages（文本搜索语言） 文本索引和$text操作符可用于下列语言，并接受两个字母的ISO 639-1语言代码或语言名称的长形式 语言名称 ISO 639-1(双字母代码) danish da dutch nl english en finnish fi french fr german de hungarian hu italian it norwegian nb portuguese pt romanian ro russian ru spanish es swedish sv turkish tr 注意 如果您将语言值指定为“ none”，则文本搜索将使用简单的标记化，其中没有停用词列表，也没有词干。 另看： Specify a Language for Text Index Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/Read-Isolation-Read-Concern.html":{"url":"docs/MongoDB-CRUD-Operations/Read-Isolation-Read-Concern.html","title":"Read Isolation(Read Concern)","keywords":"","body":"阅读关注 在本页中 阅读关注级别 ReadConcern 支持 注意事项 阅读关注 选项允许你控制从副本集和分片集读取数据的一致性和隔离性。通过有效地使用写关注和读关注，你可以适当地调整一致性和可用性的保证级别，例如等待以保证更强的一致性，或放松一致性要求以提供更高的可用性。将MongoDB驱动程序更新到MongoDB 3.2或更高版本以支持读关注。 阅读关注级别 以下为可用的阅读关注级别： level Description \"local\" 查询并从实例返回数据，但不能保证该数据已被写入大多数副本集成员（即可能已经回滚）。默认为： 针对主节点读。 如果读取与因果一致的会话相关联，则针对副节点读。可用性：读关注local可用于有或没有因果关系一致的会话和事务中。更多的信息，请参考\"local\"页 \"available\" 查询并从实例返回数据，但不能保证该数据已被写入大多数副本集成员（即可能已经回滚）。默认为：如果读取与因果关系一致的会话没有关联，则针对副节点读可用性：读关注available无法用于有因果关系一致的会话和事务中。对于分片群集，\"available\"读关注提供了各种读关注中尽可能最低的延迟。但是，这是以牺牲一致性为代价的，因为从分片的集合中进行读取时，\"available\"读关注会返回孤立的文档。为了避免从分片的集合中读取时返回孤立文档的风险，可使用其他读关注，如\"local\"读关注。更多的信息，请参考\"available\"页3.6版本的新功能 \"majority\" 为了满足读关注“majority”，副本集成员从其内存视图中返回多数提交点提交的数据。这样，读关注\"majority\"在性能成本上可与其他读关注相媲美。可用性：读关注\"majority\"可用于有或没有因果关系一致的会话和事务中。对于具有三名成员的主从仲裁（PSA）架构的部署，可以禁用读关注\"majority\"；但是，这对change streams（仅在MongoDB 4.0和更早版本中）和分片群集上的事务有影响。有关更多信息，请参见禁用读关注Marjority.。要求：若要使用\"majority\"的读关注级别，副本集必须使用WiredTiger存储引擎。注意：对于多文档事务中的操作，仅当事务以写关注\"majority\"提交时，读关注\"majority\"才提供其保证。否则，\"majority\"读关注不能保证其在事务中读取的数据。更多的信息，请参考\"majority\"页 \"linearizable\" 该查询返回的数据表示了这些数据在操作开始之前已成功在大多数节点确认写入。查询可能会等待并发执行的写操作传播到大多数副本集成员，然后返回结果。如果大多数副本集成员崩溃并在读操作后重新启动，则如果将writeConcernMajorityJournalDefault设置为默认状态true，则读操作返回的文档将还是有效的。将writeConcernMajorityJournalDefault设置为false时，MongoDB不会等待w: \"majority\"在确认写入之前先要写入磁盘日志。这样，如果给定副本集中大多数节点的瞬时丢失（例如崩溃和重新启动），majority写操作可能会回滚。可用性：读关注\"linearizable\"不适用于因果一致的会话和事务。你可以仅对主节点上的读操作指定为线性读关注。你不能将$out或$merge操作与读关注\"linearizable\"结合使用。也就是说，如果为db.collection.aggregate()指定为\"linearizable\"读关注，则不能在管道中使用任何的操作。要求：linearizable读关注仅保证在读操作指定了唯一标识单个文档的查询过滤器时可用。请始终将maxTimeMS与linearizable读关注一起使用，以防止大多数数据承载成员不可用。maxTimeMS确保操作不会无限期地阻塞，而是确保如果无法满足读取要求，则操作将返回错误。更多的信息，请参考\"linearizable\"页 \"snapshot\" 如果事务不是因果一致会话的一部分，写关注为\"majority\"且在事务提交后，可以确保事务操作已从多数提交数据的快照中读取。如果事务是因果一致会话的一部分，写关注为\"majority\"且在事务提交后，可以确保事务操作已从多数提交数据的快照中读取，该快照提供了与紧接事务开始之前的操作的因果一致性。读关注\"snapshot\"仅可用于多文档事务。对于分片群集上的事务，如果事务中的任何操作涉及已被禁用读关注“majority”的分片，那你就不能对该事务使用读关注\"snapshot\"。你只能对事务使用读关注\"local\"或\"majority\"。 无论读关注级别如何，节点上的最新数据都可能无法反映系统中数据的最新版本 有关每个阅读关注级别的更多信息，请参见： 读关注 \"local\" 读关注 \"available\" 读关注 \"majority\" 读关注 \"linearizable\" 读关注 \"snapshot\" ReadConcern 支持 阅读关注选项 对于不在多文档事务中的操作，你可以将 readConcern 级别指定为一个命令和方法的选项： readConcern: { level: } 要为 mongo shell方法 db.collection.find() 指定阅读关注级别，请使用 cursor.readConcern() 方法： db.collection.find().readConcern() 事务和可用的读关注 对于多文档事务，应在事务级别而不是在单个操作级别设置读关注。事务中的操作将使用事务级别的读关注。事务内部将忽略在集合和数据库级别设置的任何读关注。如果显式指定了事务级别的读关注点，则在事务内部也将忽略客户端级别的读关注点。 重要 不要为各个操作明确设置读关注。要设置事务的读关注，请参阅读 Read Concern/Write Concern/Read Preference。你可以在事务开始时设置读关注： 对于多文档事务，读关注级别\"snapshot\", \"local\" 和 \"majority\"是可用的。 多文档事务中的写命令可以支持事务级别的读关注。 如果未在事务开始时指定，则事务将使用会话级的读关注，或者如果未设置，则使用客户端级的读关注。有关等多信息，请参考 事务的读关注. 因果一致的会话和阅读相关的担忧 对于在因果一致的会话中的操作，\"local\" h和 \"majority\"级别可用。但是，为了保证因果一致性，你必须使用 \"majority\"。有关详细信息，请参见 因果一致性。如果多文档事务与因果一致的会话相关联，则\"snapshot\" 也可用于该事务。 支持读关注的操作 下列的操作支持读关注： 重要 在为事务中的操作设置读关注时，请在事务级别而不是在单个操作级别设置读关注。不要在事务中明确的设置单独操作的读关注。更多信息，查看事务和读关注 命令/方法 \"local\" \"available\" \"majority\" \"snapshot\" \"linearizable\" count ✓ ✓ ✓ ✓ distinct ✓ ✓ ✓ ✓ ✓ find ✓ ✓ ✓ ✓ ✓ db.collection.find() via cursor.readConcern() ✓ ✓ ✓ ✓ ✓ geoSearch ✓ ✓ ✓ ✓ ✓ getMore ✓ ✓ aggregate db.collection.aggregate() ✓ ✓ ✓ ✓ ✓ Session.startTransaction() ✓ ✓ ✓ [1] 你不能将$out 或者 $merge阶段与读关注的\"linearizable\"结合使用。也就是说，如果为db.collection.aggregate()指定\"linearizable\"读关注，则不能在管道中包括任何一个阶段。 [2] 读关注\"snapshot\"仅适用于多文档事务。在事务中，不能在分片集合上使用distinct命令或其协助命令。 下列的写操作页能接受读关注，但必须是多文档事务的一部分：重要在为事务中的操作设置读关注时，请在事务级别而不是在单个操作级别设置读关注 Command 命令 \"local\" \"available\" \"majority\" \"snapshot\" \"linearizable\" deletedb.collection.deleteMany()db.collection.deleteOne()db.collection.remove() ✓ ✓ findAndModifydb.collection.findAndModify()db.collection.findOneAndDelete()db.collection.findOneAndReplace()db.collection.findOneAndUpdate() ✓ ✓ insertdb.collection.insert()db.collection.insertOne()db.collection.insertMany() ✓ ✓ updatedb.collection.update()db.collection.updateMany()db.collection.updateOne()db.collection.replaceOne() ✓ ✓ [3] (1, 2)读关注“SNAPSHOT”仅适用于多文档事务，并且对于事务，您可以在事务级别设置读关注。支持“SNAPSHOT”的操作对应于事务中可用的CRUD操作。有关更多信息，请参见事务和读关注 注意事项 读自己的文章 在版本3.6中更改从MongoDB 3.6版本开始，如果写请求确认，你可以使用因果一致的会话读你自己写入的内容。在MongoDB 3.6之前，您必须使用 { w: \"majority\" } 写关注发出写操作，然后对读操作使用 \"majority\" 或者 \"linearizable\"读关注，以确保单个线程可以读取自己的写入内容 实时顺序 结合\"majority\" 写关注，\"linearizable\" 读关注使多个线程可以在单个文档上执行读写操作，就好像单个线程实时地执行了这些操作一样。 也就是说，这些读写的对应的计划被认为是线性的。 性能比较 与\"majority\"不同，\"linearizable\" 的读关注通过从节点确认读操作正在从主节点读，该操作能够以{ w: \"majority\" }写关注来确认写入。 [4]因此，具有线性化读关注的读取可能比具有\"majority\" 或 \"local\"读关注的读慢得多。为了避免万一大多数数据承载成员不可用，请始终将 maxTimeMS 与可线性化的读确认一起使用。maxTimeMS 确保操作不会无限期地阻塞，而是确保如果无法满足读取要求，则操作将返回错误。例如： db.restaurants.find( { _id: 5 } ).readConcern(\"linearizable\").maxTimeMS(10000) db.runCommand( { find: \"restaurants\", filter: { _id: 5 }, readConcern: { level: \"linearizable\" }, maxTimeMS: 10000 } ) [4] 在某些情况下，副本集中的两个节点可能会短暂地认为它们是主节点，但至多，其中一个节点将能够以{ w: \"majority\" }写关注完成。 可以完成{ w: \"majority\" }写入的节点是当前主节点，另一个节点是前主节点，由于网络分区的原因，该主节点尚未意识到其降级。 发生这种情况时，尽管请求的读优先级为主节点，但连接到前主界定啊的客户端仍可能会读到过时的数据，并且最终将对前主节点新写入的进行回滚。 读操作和afterClusterTime 3.6 版本新加入MongoDB 3.6引入了对因果一致会话的支持。 对于与因果一致的会话相关联的读操作，MongoDB 3.6引入了 afterClusterTime 读关注选项，驱动程序会自动将afterClusterTime 读关注选项设置为与因果一致的会话相关联的操作。重要不要手动为读操作设置 afterClusterTime 。 MongoDB驱动程序会针对与因果一致的会话相关联的操作自动设置此值。 但是，您可以提前会话的操作时间和群集时间，以便与另一个客户端会话的操作保持一致。 有关示例，请参见示例。为了满足 afterClusterTime 值为T的读请求， mongod 必须在其oplog到达时间T之后执行请求。如果其oplog尚未达到时间T，则 mongod 必须等待服务该请求。使用指定的 afterClusterTime 的读操作将返回满足读关注级别要求和指定的 afterClusterTime 要求的数据。对于与因果一致会话无关的读操作，未设置 afterClusterTime。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/Read-Isolation-Read-Concern/Read-Concern-local.html":{"url":"docs/MongoDB-CRUD-Operations/Read-Isolation-Read-Concern/Read-Concern-local.html","title":"Read Concern \"local\"","keywords":"","body":"阅读关注“local” 具有读取关注点的查询local从实例返回数据，但不保证数据已写入大多数副本集成员(即：可能会回滚)。 读取关注local是默认值： 读取针对主要的操作 如果读取与因果关系一致关联，则读取针对辅助节点的操作。 不管读关注级别如何，节点上的最新数据都可能无法反映系统中数据的最新版本。 可用性 读关注local可用于有或没有因果关系一致的会话和事务。 阅读关注”local“和交易 您可以在事务级别上而不是在单个操作级别上设置读取关注。要设置事务的已读关注点，请参见事务和已读关注点。 例子 考虑写入操作 Write0 到三个成员副本集的以下时间轴： 注意 Write0 之前的所有写操作都已成功复制到所有成员。 Writeprev 是 Write0之前的写入。 在 Write0之后没有发生其他写操作。 时间 事件 最新写 最新的多数写 t0 主要适用于Write0 主要：Write0次要1：Writeprev次要2：Writeprev 主要：Writeprev次要1：Writeprev次要2：Writeprev t1 Secondary1适用于Write0 主要：Write0次要1：Write0次要2：Writeprev 主要：Writeprev次要1：Writeprev次要2：Writeprev t2 Secondary2适用于Write0 主要：Write0次要1：Write0次要2：Write0 主要：Writeprev次要1：Writeprev次要2：Writeprev t3 Primary知道到Secondary1的复制成功，并向客户端发送确认 主要：Write0次要1：Write0次要2：Write0 主要：Write0次要1：Writeprev次要2：Writeprev t4 Primary 知道成功复制到 Secondary2 主要：Write0次要1：Write0次要2：Write0 主要：Write0次要1：Writeprev次要2：Writeprev t5 Secondary1接收通知(通过常规复制机制)以更新其最近 w：“多数”写入的快照 主要：Write0次要1：Write0次要2：Write0 主要：Write0次要1：Write0次要2：Writeprev t6 Secondary2接收通知(通过常规复制机制)以更新其最近 w：“多数”写入的快照 主要：Write0次要1：Write0次要2：Write0 主要：Write0次要1：Write0次要2：Write0 然后，下表总结了具有“local”读关注的读操作在T时刻看到的数据状态。 阅读目标 Time T 数据状态 主 在t0之后 数据反映了 Write0 Secondary1 在t1之前 数据反映了 Writeprev Secondary1 在t1之后 数据反映了 Write0 Secondary2 在t2之前 数据反映了 Writeprev Secondary2 在t2之后 数据反映了 Write0 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/Read-Isolation-Read-Concern/Read-Concern-available.html":{"url":"docs/MongoDB-CRUD-Operations/Read-Isolation-Read-Concern/Read-Concern-available.html","title":"Read Concern \"available\"","keywords":"","body":"阅读关注“available” version 3.6 中的新内容。 读取关注“可用”的查询返回实例中的数据，但不保证数据已写入大多数副本集成员(i.e.可能会回滚)。 如果读取与因果关系一致无关，则读取关注“可用”是对二级读取的缺省值。 对于分片 cluster，“可用”读取问题为分区提供了更大的容忍度，因为它不会等待以确保一致性保证。但是，如果分片正在进行大块迁移，那么带有“可用”读取问题的查询可能会 return 孤立文档，因为“本地”读取问题与“本地”读取问题不同，它不会联系分片的主服务器或配置服务器以更新元数据。 对于未加密的集合(包括独立部署或副本集部署中的集合)，“本地”和“可用”读取问题的行为相同。 无论阅读关注 level 如何，节点上的最新数据可能无法反映系统中数据的最新 version。 也可以看看 orphanCleanupDelaySecs 可用行 阅读关注available无法与因果一致的会话一起使用。 例子 考虑写入操作 Write0 到三个成员副本集的以下时间轴： 注意 Write0 之前的所有写操作都已成功复制到所有成员。 Writeprev 是 Write0之前的写入。 在 Write0之后没有发生其他写操作。 时间 事件 最新写 最新的多数写 t0 主要适用于Write0 主要：Write0次要1：Writeprev次要2：Writeprev 主要：Writeprev次要1：Writeprev次要2：Writeprev t1 Secondary1适用于Write0 主要：Write0次要1：Write0次要2：Writeprev 主要：Writeprev次要1：Writeprev次要2：Writeprev t2 Secondary2适用于Write0 主要：Write0次要1：Write0次要2：Write0 主要：Writeprev次要1：Writeprev次要2：Writeprev t3 Primary知道到Secondary1的复制成功，并向客户端发送确认 主要：Write0次要1：Write0次要2：Write0 主要：Write0次要1：Writeprev次要2：Writeprev t4 Primary 知道成功复制到 Secondary2 主要：Write0次要1：Write0次要2：Write0 主要：Write0次要1：Writeprev次要2：Writeprev t5 Secondary1接收通知(通过常规复制机制)以更新其最近 w：“多数”写入的快照 主要：Write0次要1：Write0次要2：Write0 主要：Write0次要1：Write0次要2：Writeprev t6 Secondary2接收通知(通过常规复制机制)以更新其最近 w：“多数”写入的快照 主要：Write0次要1：Write0次要2：Write0 主要：Write0次要1：Write0次要2：Write0 然后，下表总结了 time读取关注的读操作在 time T处将看到的数据的 state。 阅读目标Time `T`数据状态 主在 t0 之后数据反映了 Write0。 Secondary1在 t1 之前数据反映了 Writeprev Secondary1在 t1 之后数据反映了 Write0 Secondary2在 t2 之前数据反映了 Writeprev Secondary2在 t2 之后数据反映了 Write0 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/Read-Isolation-Read-Concern/Read-Concern-majority.html":{"url":"docs/MongoDB-CRUD-Operations/Read-Isolation-Read-Concern/Read-Concern-majority.html","title":"Read Concern \"majority\"","keywords":"","body":"阅读关注“majority” 在本页面 性能 可用性 例子 存储引擎支持 阅读关注\"majority\"和交易 阅读关注\"majority\"和汇总 阅读你自己的写作 禁用阅读关注多数 对于与多文档事务无关的读操作，阅读问题“majority”保证所读的数据得到了大多数副本集成员的认可(即，所读的文档是持久的，并且保证不会回滚)。 对于多文档事务中的操作，只有当事务以写关注点“多数”提交时，读关注点“多数”才提供保证。否则，“多数”读取关注不能保证在事务中读取的数据。 不管读关注级别是什么，节点上的最新数据都可能不能反映系统中数据的最新版本。 性能 每个副本集成员在内存中维护多数提交点处的数据视图。多数提交点是由初级计算的。为了满足读取关注\"majority\"，该节点从该视图返回数据，并且性能成本与其他读取关注相当。 可用性 读关注\"majority\"可用于有或没有因果关系一致的会话和事务。 您可以\"majority\"为具有三名成员的主次仲裁器（PSA）架构的部署禁用读关注。但是，这会影响分片群集上的变更流（仅在MongoDB 4.0和更早版本中）和事务。有关更多信息，请参见禁用多数阅读关注。 例子 考虑写入操作 Write0 到三个成员副本集的以下时间轴： 注意 Write0 之前的所有写操作都已成功复制到所有成员。 Writeprev 是 Write0之前的写入。 在 Write0之后没有发生其他写操作。 时间 事件 最新写 最新的多数写 t0 主要适用于Write0 主要：Write0次要1：Writeprev次要2：Writeprev 主要：Writeprev次要1：Writeprev次要2：Writeprev t1 Secondary1适用于Write0 主要：Write0次要1：Write0次要2：Writeprev 主要：Writeprev次要1：Writeprev次要2：Writeprev t2 Secondary2适用于Write0 主要：Write0次要1：Write0次要2：Write0 主要：Writeprev次要1：Writeprev次要2：Writeprev t3 Primary知道到Secondary1的复制成功，并向客户端发送确认 主要：Write0次要1：Write0次要2：Write0 主要：Write0次要1：Writeprev次要2：Writeprev t4 Primary 知道成功复制到 Secondary2 主要：Write0次要1：Write0次要2：Write0 主要：Write0次要1：Writeprev次要2：Writeprev t5 Secondary1接收通知(通过常规复制机制)以更新其最近 w：“多数”写入的快照 主要：Write0次要1：Write0次要2：Write0 主要：Write0次要1：Write0次要2：Writeprev t6 Secondary2接收通知(通过常规复制机制)以更新其最近 w：“多数”写入的快照 主要：Write0次要1：Write0次要2：Write0 主要：Write0次要1：Write0次要2：Write0 然后，下表总结了具有\"majority\"读取关注的读取操作在时间将看到的数据状态T。 阅读目标 Time T 数据状态 主 在t3之前 数据反映了 Writeprev 主 在t3之后 数据反映了 Write0 Secondary1 在t5之前 数据反映了 Writeprev Secondary1 在t5之后 数据反映了 Write0 Secondary2 在t6之前 数据反映了 Writeprev Secondary2 在t6之后 数据反映了 Write0 存储引擎支持 读取关注“多数”可用于 WiredTiger 存储引擎。 提示 serverStatus命令返回storageEngine.supportsCommittedReads字段，该字段指示存储引擎是否支持”majority“读取问题。 阅读关注\"majority\"和交易 注意 您可以在事务级别上而不是在单个操作级别上设置读取关注。要设置事务的已读关注点，请参见事务和已读关注点。 对于多文档事务中的操作，\"majority\"仅当事务以写关注“多数”提交时，读关注才提供其保证。否则， \"majority\"读取关注点不能保证事务中读取的数据。 阅读关注\"majority\"和汇总 从MongoDB 4.2开始，您可以为包含阶段的聚合指定读取关注级别。\"majority\"$out 在MongoDB 4.0和更早版本中，您不能包括将读取关注用于聚合的$out 阶段\"majority\"。 阅读你自己的写作 更改了 version 3.6. 从 MongoDB 3.6 开始，如果写请求确认，则可以使用因果关系一致来读取您自己的写入。 在MongoDB 3.6之前，您必须发出具有写入关注点的写入操作， 然后 对读取操作使用或关注读取，以确保单个线程可以读取自己的写入。{ w: \"majority\" }\"majority\"\"linearizable\" 禁用阅读关注多数 适用于3成员主-副-仲裁器体系结构 \"majority\"如果您具有具有主要-次要仲裁器（PSA）体系结构的三成员副本集或具有三成员PSA分片的分片群集，则可以禁用读关注。 注意 如果您使用的是 3-member PSA 以外的部署，则无需禁用多数读取关注。 对于三成员PSA架构，缓存压力将增加，如果任何承载数据的节点是关闭的。为了防止存储缓存压力使PSA架构的部署无法被锁定，您可以通过设置以下任一项来禁用read concern: --enableMajorityReadConcern的命令行选项false。 replication.enableMajorityReadConcern配置文件设置为false。 要检查是否已禁用“大多数”的阅读关注，您可以db.serverStatus()在mongod实例上运行 并检查该storageEngine.supportsCommittedReads字段。如果为false，则禁用“大多数”关注。 重要 通常，除非必要，否则请避免禁用“多数”读取问题。但是，如果您的 three-member 副本集具有 primary-secondary-arbiter(PSA)architecture 或带有 three-member PSA 分片的分片 cluster，请禁用以防止存储缓存压力导致部署无法运行。 禁用“多数”读取问题会禁用对改变流的支持。 更改流 禁用\"majority\"读取关注会禁用对MongoDB 4.0及更早版本的变更流的支持。对于MongoDB 4.2+，禁用读取关注\"majority\"不会影响更改流的可用性。 交易次数 禁用\"majority\"读取关注会影响对分片群集上事务的支持 。特别： \"snapshot\"如果事务涉及已禁用读取关注“多数”的分片，则该事务不能使用读取关注。 如果事务的任何读或写操作写入多个分片错误，则该事务涉及已禁用读取关注的分片\"majority\"。 但是，它不影响 副本集上的事务。对于副本集上的事务，即使禁用了读取关注，也可以为多文档事务指定读取关注\"majority\"（或\"snapshot\" 或\"local\"）\"majority\"。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/Read-Isolation-Read-Concern/Read-Concern-linearizable.html":{"url":"docs/MongoDB-CRUD-Operations/Read-Isolation-Read-Concern/Read-Concern-linearizable.html","title":"Read Concern \"linearizable\"","keywords":"","body":"阅读关注“linearizable” version 3.4 中的新功能。 查询返回反映在读取操作开始之前完成的所有成功 majority-acknowledged 写入的数据。在返回结果之前，查询可以等待并发执行写入以传播到大多数副本集成员。 如果大多数副本集成员在读取操作后崩溃并重新启动，则如果writeConcernMajorityJournalDefault设置为true的默认 state，则读取操作返回的文档是持久的。 当writeConcernMajorityJournalDefault设置为false时，MongoDB 不会等待w：“多数”写入在确认写入之前写入 on-disk 日志。因此，majority写操作可能会在给定副本集中的大多数节点的瞬时丢失(e.g. 崩溃和重启)的事件中回滚。 您可以仅为主指定读取操作的线性化读取问题。 可线性化读取关注保证仅在读取操作指定唯一标识单个文档的查询过滤器时才适用。 提示 如果大多数数据承载成员不可用，请始终使用带有线性化读取问题的maxTimeMS。 maxTimeMS确保操作不会无限期地阻塞，而是确保在无法满足读取关注时操作返回错误。 因果一致的会话 对于因果一致会话，Read concern linearizable不可用。 聚集限制 不能将$out或$merge阶段与read关注点“线性化”结合使用。也就是说，如果您为db.collection.aggregate()指定了“linearizable”read concern，则不能在管道中包含这两个阶段。 实时订单 结合\"majority\"写关注， \"linearizable\"读关注使多个线程可以在单个文档上执行读写操作，就好像单个线程实时执行了这些操作一样。也就是说，这些读写的相应计划被认为是线性的。 阅读你自己的写作 更改了 version 3.6. 从 MongoDB 3.6 开始，如果写请求确认，则可以使用因果关系一致来读取您自己的写入。 在MongoDB 3.6之前，您必须发出具有写入关注点的写入操作， 然后 对读取操作使用或关注读取，以确保单个线程可以读取自己的写入。{ w: \"majority\" }\"majority\"\"linearizable\" 性能比较 与“多数”不同，“可线性化”的读关注点向辅助成员确认读操作是从能够用 { w: \"majority\" } 写关注点确认写操作的主成员读取的。这样，线性化的读取可能比“多数”或“局部”读取要慢得多。 如果大多数数据承载成员不可用，请始终使用带有线性化读取问题的maxTimeMS。 maxTimeMS确保操作不会无限期地阻塞，而是确保在无法满足读取关注时操作返回错误。 例如： db.restaurants.find( { _id: 5 } ).readConcern(\"linearizable\").maxTimeMS(10000) db.runCommand( { find: \"restaurants\", filter: { _id: 5 }, readConcern: { level: \"linearizable\" }, maxTimeMS: 10000 } ) 在某些情况下，一个副本集中的两个节点可能暂时认为它们是主节点，但它们中的一个最多能够完成{ w: \"majority\" }写关注点的写操作。能够完成{ w: \"majority\" }写操作的节点是当前主节点，而另一个节点是前主节点，它还没有意识到降级，通常是由于网络分区。当发生这种情况时，连接到前主服务器的客户机可能会观察到陈旧的数据，尽管已经请求了读首选项主服务器，并且对前主服务器的新写操作最终将回滚。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/Read-Isolation-Read-Concern/Read-Concern-snapshot.html":{"url":"docs/MongoDB-CRUD-Operations/Read-Isolation-Read-Concern/Read-Concern-snapshot.html","title":"Read Concern \"snapshot\"","keywords":"","body":"阅读关注点\"snapshot\" 版本4.0中的新功能。 读取关注“snapshot”只对多文档事务可用。 如果事务不是因果一致会话的一部分，那么在事务提交时，写关注点为\"majority\"，事务操作就保证已经从多数提交数据的快照中读取了数据。 如果事务是因果一致会话的一部分，那么在事务提交时，write concern为\"majority\"，事务操作保证已经从多数提交数据的快照中读取，该快照提供了与事务开始前的操作因果一致的数据。 操作 有关接受阅读关注的所有操作的列表，请参阅 支持阅读关注的操作。 阅读关注和交易 多文档事务支持阅读关注 \"snapshot\"以及\"local\"和 \"majority\"。 注意 您可以在事务级别上而不是在单个操作级别上设置读取关注。要设置事务的已读关注点，请参见事务和已读关注点。 对于分片群集上的事务，如果事务中的任何操作涉及已禁用读关注度“多数”的分片，则不能\"snapshot\"对事务使用读关注度。您只能使用已读关注\"local\"或\"majority\"用于事务。如果使用读取关注\"snapshot\"，则事务错误并中止。有关更多信息，请参见 禁用阅读关注多数。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/Write-Acknowledgement-Write-concern.html":{"url":"docs/MongoDB-CRUD-Operations/Write-Acknowledgement-Write-concern.html","title":"Write Acknowledgement(Write concern)","keywords":"","body":"写关注 在本页面 编写关注规范 确认行为 因果一致的会话和写问题 计算关注的多数 写关注描述了MongoDB请求对独立mongod或副本集或分片群集进行写操作的确认级别。在分片群集中，mongos实例会将写关注事项传递给分片。 注意 对于多文档事务，可以在事务级别而不是在单个操作级别设置写关注。不要为事务中的各个写操作显式设置写关注点。 编写关注规范 写关注可包括以下字段： { w ： ， j ： ， wtimeout ： } 使用w选项来请求确认写入操作已传播到指定数量的mongod 实例或mongod具有指定标签的实例。 该Ĵ选项要求确认写操作已被写入到磁盘上的杂志，和 该wtimeout选项来指定一个时间限制，以防止无限期阻塞写操作。 w 选项 w选项请求确认写操作已传播到指定数量的mongod实例或具有指定标记的mongod实例。 使用w选项，可以使用以下w:value>写入问题： 值 描述 请求确认写操作已传播到指定数量的mongod实例。例如：w: 1请求确认写入操作已传播到mongod副本集中的独立副本或主副本。是MongoDB的默认写关注点。 如果在写操作已复制到任何辅助数据库之前主数据库已降级，则可以回滚数据。w: 1``w: 0不要求确认写入操作。但是，可能会将有关套接字异常和网络错误的信息返回给应用程序。如果在写操作已复制到任何辅助数据库之前主数据库已降级，则可以回滚数据 。w: 0如果指定但包括j：true，则优先使用 j：true来请求独立或副本集主副本的确认。w: 0mongodw大于1则需要来自主数据库的确认以及满足指定写入问题所需的尽可能多的数据承载辅助数据库的确认。例如，考虑一个具有一个主要成员和两个次要成员的3成员副本集。指定将需要主数据库和辅助数据库之一的确认。指定将需要主要和次要确认。w: 2``w: 3注意Hidden， delayed和 priority 0 成员可以确认 写操作。w:延迟的辅助副本可以在不早于configure的情况下返回写确认slaveDelay。有关实例何时确认写入的信息，请参见确认行为mongod。 \"majority\" 请求确认写入操作已传播到所计算的大多数含数据投票成员（即具有的members[n\\].votes大于的主要和次要成员 0）。例如，考虑一个具有3个投票成员的副本集，即Primary-Secondary-Secondary（PSS）。对于此副本集， 计算出的多数为2，并且写入必须传播到主要对象和一个辅助对象，以向客户端确认写入问题。注意隐藏， 延迟和优先级为0的 成员（members[n\\].votes大于0 可以确认\"majority\"写入操作）。延迟的辅助副本可以在不早于configure的情况下返回写确认slaveDelay。在写操作返回确认给客户端之后，客户端可以使用readConcern 读取该写操作的结果 。w: \"majority\"\"majority\"有关实例何时确认写入的信息，请参见确认行为mongod。 请求确认写操作已传播到tagged满足中定义的自定义写关注点的成员 settings.getLastErrorModes。有关示例，请参阅“ 自定义多数据中心写入问题”。如果自定义写入问题仅需要在写入操作复制到任何辅助数据库之前先要求主要数据库和主要数据库降级的确认，则可以回滚数据。有关 实例何时确认写入的信息，请参见确认行为mongod。 也可以看看 默认的MongoDB读问题/写问题 副本集协议版本 j 选项 该j选项要求MongoDB确认写入操作已写入磁盘日志中。 j 如果为，则请求确认w：中指定的 实例已写入磁盘日志中。本身并不能保证不会因副本集主故障转移而回滚写操作。j: truemongodj: true在版本3.2中进行了更改：使用时，MongoDB仅在请求数量的成员（包括主要成员）写入日志后才返回。不管w：写入关注点如何，副本集中以前的写入关注点只要求主记录写到日志。j: truej: true 注意 指定一个写入关注点，该关注点包含到正在运行且没有日志记录的 实例中会产生错误。j: truemongod 如果启用日记功能，则可能暗示。的 副本集配置设置确定的行为。有关详细信息，请参见 确认行为。w: \"majority\"j: truewriteConcernMajorityJournalDefault wtimeout 此选项指定写入问题的 time 限制(以毫秒为单位)。 wtimeout仅适用于大于1的w值。 wtimeout导致写入操作返回到指定限制后的错误，即使所需的写入关注最终会成功。当这些写操作 return 时，MongoDB 不会撤消在写入关注超过wtimeout time 限制之前执行的成功数据修改。 如果未指定wtimeout选项且写入关注的 level 无法实现，则写入操作将无限期阻止。指定0的wtimeout value 等同于没有wtimeout选项的写入问题。 确认行为 w选项和j选项确定mongod实例何时承认写操作。 独立 独立mongod应用程序在应用了内存中的写入之后或写入磁盘日志后会确认写入操作。下表列出了独立服务器的确认行为以及相关的写入问题： j 未指定 j:true j:false w: 1 在记忆中 磁盘日志 在内存中 w: \"majority\" 磁盘日志（如果与日志一起运行） 磁盘日志 在内存中 注意 随着writeConcernMajorityJournalDefault设置为false，MongoDB的不等待 写入承认写之前被写入到磁盘上的日志。这样，在给定副本集中的大多数节点出现瞬时丢失（例如崩溃和重新启动）的情况下，写操作可能会回滚。w: \"majority\"majority 副本集 指定给w的值确定返回成功之前必须确认写入的副本集成员的数量。对于每个合格的副本集成员，j 选项确定成员是在内存中应用写操作之后还是在写到磁盘日志上之后是否确认写。 w: \"majority\" 副本集的任何带有数据的投票成员都可以对\"majority\"写操作进行写确认。 下表列出了成员何时可以基于j值确认写入： j` 未指定 确认取决于以下值 writeConcernMajorityJournalDefault：如果为true，则确认需要将操作写入磁盘日志（）。j: truewriteConcernMajorityJournalDefault 默认为 true如果为false，则确认需要在存储器（）中进行写操作。j: false j: true 确认需要将操作写入磁盘日志。 j: false 确认需要在内存中进行写操作。 注意 随着writeConcernMajorityJournalDefault设置为false，MongoDB的不等待 写入承认写之前被写入到磁盘上的日志。这样，在给定副本集中的大多数节点出现瞬时丢失（例如崩溃和重新启动）的情况下，写操作可能会回滚。w: \"majority\"majority 注意 隐藏， 延迟和优先级为0的 成员（members[n].votes大于0 可以确认\"majority\"写入操作）。延迟的辅助副本可以在不早于configure的情况下返回写确认slaveDelay。 w: 副本集的任何承载数据的成员都可以对w：写操作进行写确认。 下表列出了成员何时可以基于j值确认写入： j 未指定 确认需要在内存（）中进行写操作。j: false j: true 确认需要将操作写入磁盘日志。 j: false 确认需要在内存中进行写操作。 注意 隐藏， 延迟和优先级为0 成员可以确认 写操作。w:延迟的辅助副本可以在不早于configure的情况下返回写确认slaveDelay。 因果一致的会话和写问题 使用因果一致的客户机会话，客户机会话仅在以下情况下保证因果一致性： 相关的读取操作使用\"majority\"读取关注，并且 相关的写操作使用\"majority\" 写关注。 有关详细信息，请参见因果一致性。 计算关注的多数 提示 从版本4.2.1开始，rs.status()返回writeMajorityCount包含计算出的多数数的 字段。 写入关注的多数\"majority\"由以下值中的较小者计算得出： 所有投票成员（包括仲裁员）中的大多数 所有带有数据的投票成员的数量。 警告 如果计算出的多数数等于所有带有数据的投票成员的人数（例如，由3个成员组成的主要-次要仲裁员部署），则写关注 \"majority\"可能会超时，或者如果有数据的投票成员则永远不会得到承认掉线或无法到达。如果可能，请使用带有数据的投票成员而不是仲裁者。 例如，考虑： 具有3个投票成员的副本集，主要-次要（PSS）： 所有投票成员中大多数为2。 所有有数据投票的成员人数为3。 计算得出的多数为2，最小值为2和3。写入必须传播到主要对象和辅助对象之一，\"majority\"以向客户端确认写入问题。 副本集包含3个投票成员，主要-次要仲裁员（PSA） 所有投票成员中大多数为2。 所有有数据投票的成员人数为2。 计算得出的多数为2，为2和2的最小值。由于该写操作只能应用于数据承载成员，因此该写操作必须传播到主要对象和辅助对象，\"majority\"以向客户端确认写问题。 提示 避免在a (p - a)或其他拓扑结构中使用“多数”写关注点，这些拓扑结构要求所有支持数据的投票成员都可用来确认写操作。想要使用“majority”写关注点的持久性保证的客户应该部署不需要所有数据承载投票成员可用的拓扑(例如P-S-S)。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/MongoDB-CRUD-Concepts.html":{"url":"docs/MongoDB-CRUD-Operations/MongoDB-CRUD-Concepts.html","title":"MongoDB CRUD Concepts","keywords":"","body":"MongoDB CRUD Concepts 本部分包含有关与MongoDB中的CRUD操作相关的其他概念的信息。 原子性，一致性和分布式操作 原子性和交易 阅读隔离度，一致性和新近度 分布式查询 通过findAndModify进行线性化读取 查询计划，性能和分析 查询计划 查询优化 分析查询性能 写操作性能 其它 Tailable 游标 也可以看看： 交易次数 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/MOngoDB-CRUD-Concepts/Atomicity-and-Transactions.html":{"url":"docs/MongoDB-CRUD-Operations/MOngoDB-CRUD-Concepts/Atomicity-and-Transactions.html","title":"Atomicity and Transactions","keywords":"","body":"原子性和事务 在本页面 原子性 多文档交易 并发控制 原子性 在MongoDB中，写操作在单个文档级别上是原子的，即使该操作修改了单个文档中嵌入的多个文档。 多文档交易 当单个写入操作（例如 db.collection.updateMany()）修改多个文档时，每个文档的修改都是原子的，但整个操作不是原子的。 当执行多文档写操作时，无论是通过单个写操作还是通过多个写操作，其他操作都可能会交错。 对于需要原子性地读写多个文档（在单个或多个集合中）的情况，MongoDB支持多文档事务： 在版本4.0中，MongoDB支持副本集上的多文档事务。 在版本4.2中，MongoDB引入了分布式事务，它增加了对分片群集上多文档事务的支持，并合并了对副本集上多文档事务的现有支持。 有关MongoDB中事务的详细信息，请参阅 事务页面。 重要的 在大多数情况下，多文档事务比单文档写入带来更大的性能成本，而多文档事务的可用性不应该取代有效的模式设计。对于许多场景， 非规范化数据模型（嵌入式文档和数组）将继续是数据和用例的最佳选择。也就是说，对于许多场景，适当地对数据建模将最小化对多文档事务的需求。 有关其他事务使用注意事项(如运行时限制和oplog大小限制)，请参见 生产注意事项。 并发控制 并发控制允许多个应用程序同时运行，而不会导致数据不一致或冲突。 一种方法是在只能具有唯一值的字段上创建唯一索引。这样可以防止插入或更新创建重复数据。在多个字段上创建唯一索引以强制字段值的组合具有唯一性。有关用例的示例，请参见update（）和Unique Index以及findAndModify（）和Unique Index。 另一种方法是在查询谓词中为写操作指定字段的期望当前值。 也可以看看： 阅读隔离度，一致性和近效性 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:35:01 "},"docs/MongoDB-CRUD-Operations/MongoDB-CRUD-Concepts/Read-Isolation-Consistency-and-Recency.html":{"url":"docs/MongoDB-CRUD-Operations/MongoDB-CRUD-Concepts/Read-Isolation-Consistency-and-Recency.html","title":"Read Isolation Consistency and Recency","keywords":"","body":"读取隔离、一致性和近效性 在本页面 隔离保证 单调写 实时订单 因果一致性 隔离保证 阅读未提交 根据读取的关注点，客户端可以在持久写入之前看到写入的结果： 不管写的写关注点如何，其他使用\"local\"或\"available\" 读关注的客户端都可以在向发布客户端确认写操作之前看到写操作的结果。 使用\"local\"或\"available\" 读取关注点的客户端可以读取数据，这些数据随后可能会在副本集故障转移期间回滚。 对于多文档事务中的操作，当事务提交时，在事务中进行的所有数据更改都将保存并在事务外部可见。也就是说，一个事务在回滚其他事务时将不会提交其某些更改。 在提交事务之前，在事务外部看不到在事务中进行的数据更改。 但是，当事务写入多个分片时，并非所有外部读取操作都需要等待已提交事务的结果在所有分片上可见。例如，如果提交了一个事务，并且在分片A上可以看到写1，但是在分片B上还看不到写2，则外部读取在读关注点时 \"local\"可以读取写1的结果而看不到写2。 “读取未提交”是默认的隔离级别，适用于 mongod独立实例以及副本集和分片群集。 阅读未提交的单文档原子性 对于单个文档，写操作是原子的。即，如果写操作正在更新文档中的多个字段，则读操作将永远不会看到仅更新了某些字段的文档。但是，尽管客户端可能看不到部分更新的文档，但未提交的读取意味着并发的读取操作仍可以在使更改持久之前看到更新的文档。 对于独立mongod实例，对单个文档的一组读取和写入操作是可序列化的。使用副本集，只有在没有回滚的情况下，对单个文档的一组读取和写入操作才能序列化 。 读取未提交和多个文档写入 当单个写入操作（例如 db.collection.updateMany()）修改多个文档时，每个文档的修改都是原子的，但整个操作不是原子的。 当执行多文档写操作时，无论是通过单个写操作还是通过多个写操作，其他操作都可能会交错。 对于需要原子性地读写多个文档（在单个或多个集合中）的情况，MongoDB支持多文档事务： 在版本4.0中，MongoDB支持副本集上的多文档事务。 在版本4.2中，MongoDB引入了分布式事务，它增加了对分片群集上多文档事务的支持，并合并了对副本集上多文档事务的现有支持。 有关MongoDB中事务的详细信息，请参阅 事务页面。 重要 : 在大多数情况下，与单文档写入相比，多文档事务产生的性能成本更高，并且多文档事务的可用性不应替代有效的架构设计。在许多情况下， 非规范化数据模型（嵌入式文档和数组）将继续是您的数据和用例的最佳选择。也就是说，在许多情况下，适当地对数据建模将最大程度地减少对多文档交易的需求。 有关其他事务使用方面的注意事项（例如运行时限制和操作日志大小限制），另请参见 生产注意事项。 在不隔离多文档写入操作的情况下，MongoDB表现出以下行为： 非时间点读取操作。假设读取操作在时间t1开始并开始读取文档。然后，写操作在稍后的时间t 2提交对文档之一的更新。读者可能会看到文档的更新版本，因此看不到数据的时间点快照。 不可序列化的操作。假设读取操作在时间t 1读取文档d 1，而写入操作在稍后的时间t 3更新d 1。这引入了读写依赖性，因此，如果要序列化操作，则读取操作必须先于写入操作。而且还假设写操作在时间t 2更新文档d 2，而读取操作随后在稍后的时间 t 4读取d 2。这就引入了写-读依赖关系，它将需要读操作来进行在可序列化计划中进行写操作之后。有一个依赖循环，使可序列化成为不可能。 读取操作可能会丢失在读取操作过程中更新的匹配文档。 光标快照 在某些情况下，MongoDB游标可以多次返回同一文档。当游标返回文档时，其他操作可能会与查询交错。如果其中某些操作更改了查询使用的索引上的索引字段；那么光标将多次返回同一文档。 如果您的集合中有一个或多个从未修改过的字段，则可以在此字段或这些字段上使用唯一索引，这样查询将最多返回每个文档一次。查询hint()以显式强制查询使用该索引。 单调写 默认情况下，MongoDB为独立mongod实例和副本集提供单调写保证。 有关单调的写入和分片群集，请参见 因果一致性。 实时订单 3.4版的新功能。 对于主服务器上的读取和写入操作，发出具有\"linearizable\"读取关注的读取操作和具有\"majority\"写入关注的写入操作使多个线程可以在单个文档上执行读写操作，就好像单个线程实时地执行了这些操作一样。也就是说，这些读写的相应计划被认为是线性的。 ​ 也可以看看: ​ 因果一致性 因果一致性 3.6版的新功能。 如果操作在逻辑上取决于先前的操作，则这些操作之间存在因果关系。例如，基于指定条件删除所有文档的写入操作和验证删除操作的后续读取操作具有因果关系。 在因果一致的会话中，MongoDB按照尊重因果关系的顺序执行因果操作，并且客户观察到与因果关系一致的结果。 客户会话和因果一致性保证 为了提供因果一致性，MongoDB 3.6在客户端会话中启用因果一致性。因果一致的会话表示具有\"majority\" 读关注点的读操作和具有\"majority\"写关注点的写操作的关联序列具有因果关系，这由它们的顺序反映出来。 应用程序必须确保一次只有一个线程在客户端会话中执行这些操作。 对于因果相关的操作： 客户端启动客户端会话。 重要 客户会话仅保证以下方面的因果一致性： 读取操作\"majority\"; 也就是说，返回数据已被大多数副本集成员确认并且是持久的。 关注写操作；也就是说，写操作要求确认该操作已应用于大多数副本集的有投票权的成员。 有关因果一致性和各种读写问题的更多信息，请参见 因果一致性和读写问题。 当客户端发出具有\"majority\"读关注和写操作（具有 \"majority\"写关注）的读取序列时 ，客户端将会话信息包含在每个操作中。 对于与会话相关联的每个具有\"majority\"读关注度的读操作和具有\"majority\"写关注度的写操作，即使操作错误，MongoDB也会返回操作时间和集群时间。客户端会话跟踪操作时间和群集时间。 注意 对于未确认的(w: 0)写操作，MongoDB不返回操作时间和集群时间。未被承认的书写不暗示任何因果关系。 虽然MongoDB在客户端会话中返回读操作和已确认的写操作的操作时间和集群时间，但只有读关注“多数”的读操作和写关注“多数”的写操作才能保证因果一致性。有关细节，请参阅 因果一致性和读写问题。 关联的客户端会话跟踪这两个时间字段。 注意 不同会话之间的操作可以因果一致。MongoDB驱动程序和mongo外壳程序提供了延长客户端会话的操作时间和集群时间的方法。因此，客户端可以提前一个客户端会话的群集时间和操作时间，使其与另一客户端会话的操作保持一致。 因果一致性保证 下表列出了因果一致性会话提供的因果一致性保证，\"majority\"涉及具有读关注的读取操作 和具有\"majority\"写关注的写入操作。 保证金 描述 阅读您的文章 读操作反映了在其之前的写操作的结果。 单调读 读取操作不会返回与先前读取操作相比更早的数据状态的结果。例如，如果在会话中：write1优先于write2，read1优先于read2，并且reda1返回反映write2的结果那么read2无法返回write1的结果。 单调写 必须在其他写入之前执行的写入操作将在其他写入之前执行。例如，如果在会话中write1必须在write2之前，那么在write2时数据的状态必须反映数据post write1的状态。其他的写操作可以交错在write1和write2之间，但是write2不能出现在write1之前。 写跟读 在读操作之后执行读操作之后必须发生的写操作。即，写入时的数据状态必须包含之前的读取操作的数据状态。 读取首选项 这些保证适用于MongoDB部署的所有成员。例如，如果在因果一致的会话中发出具有\"majority\"写关注点的写操作， 然后发出从secondary具有\"majority\"读关注点的辅助卷（即读首选项） 读取的读，则读操作将反映写操作之后的数据库状态。 隔离 因果一致的会话内的操作与会话外的操作不是隔离的。如果并发写操作在会话的写操作和读操作之间交错，则会话的读操作可能返回反映在会话的写操作之后发生的写操作的结果。 MongoDB驱动程序 提示 应用程序必须确保一次只有一个线程在客户端会话中执行这些操作。 客户端需要为MongoDB 3.6或更高版本更新的MongoDB驱动程序： Java 3.6+ C＃2.5以上 Perl 2.0以上 Python 3.6+ 节点3.0+ PHPC 1.4以上 C 1.9以上 红宝石2.5+ Scala 2.2+ 例子 重要 因果一致的会话只能保证因读而\"majority\"引起的读和因\"majority\"写而引起的写的 因果一致性 考虑一个集合项，它维护各种项的当前和历史数据。只有历史数据的结束日期是非空的。如果某个项的sku值发生了更改，则需要用结束日期更新具有旧sku值的文档，然后用当前sku值插入新文档。客户端可以使用因果一致会话来确保更新在插入之前发生。 局限性 以下构建内存结构的操作在因果上不一致： 操作方式 笔记 collStats $collStats与latencyStats选项。 $currentOp 如果操作与因果一致的客户端会话相关联，则返回错误。 createIndexes dbHash 从MongoDB 4.2开始 dbStats getMore 如果操作与因果一致的客户端会话相关联，则返回错误 $indexStats mapReduce 从MongoDB 4.2开始 ping 如果操作与因果一致的客户端会话相关联，则返回错误。 serverStatus 如果操作与因果一致的客户端会话相关联，则返回错误 validate 从MongoDB 4.2开始 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/MongoDB-CRUD-Concepts/Read-Isolation-Consistency-and-Recency/Causal-Consistency-and-Read-and-Write-Concerns.html":{"url":"docs/MongoDB-CRUD-Operations/MongoDB-CRUD-Concepts/Read-Isolation-Consistency-and-Recency/Causal-Consistency-and-Read-and-Write-Concerns.html","title":"Causal Consistency and Read and Write-Concerns","keywords":"","body":"因果一致性和读写问题 通过MongoDB的因果一致性客户端会话，读写问题的不同组合可提供不同的 因果一致性保证。如果定义因果一致性以表示耐久性，则下表列出了各种组合提供的特定保证： 阅读关注 写关注 阅读自己的文章 单调读 单调写 写跟读 \"majority\" \"majority\" ✅ ✅ ✅ ✅ \"majority\" { w: 1 } ✅ ✅ \"local\" { w: 1 } \"local\" \"majority\" ✅ 如果因果一致性表示持久性，那么从表中可以看出，只有具有\"majority\"读关注度的读取操作和具有\"majority\"写关注度的写入操作才能保证所有四个因果一致性保证。也就是说， 因果一致的客户端会话只能保证以下方面的因果一致性： \"majority\"关注阅读操作；也就是说，读取操作将返回大多数副本集成员已确认且持久的数据。 \"majority\"关注写操作；也就是说，写操作要求确认该操作已应用于大多数副本集的有投票权的成员。 如果因果一致性并不意味着持久性（即，写操作可能会回滚），则具有写顾虑的写操作也可以提供因果一致性。{ w: 1 } 注意 在某些情况下（但不一定在所有情况下），读和写关注点的其他组合也可以满足所有四个因果一致性保证。 读关注点\"majority\"和写关注点 \"majority\"确保即使在副本集中的两个成员短暂地认为它们是主要的情况下（例如，使用网络分区），这四个因果一致性保证也成立 。尽管两个主数据库都可以完成写操作，但是只有一个主数据库能够完成写操作。{ w: 1 }\"majority\" 例如，考虑网络分区划分五个成员副本集的情况： 场景 为了说明读写关注点要求，在以下情况下，客户端向客户端发出了一系列操作，并对副本集进行了读写关注点的各种组合： 阅读关注“多数”并写关注“多数” 阅读关注“多数”并发表关注{w：1} 阅读关注“本地”，写关注“多数” 阅读关注“本地”并写关注{w：1} 读关注\"majority\"和写关注\"majority\" 在因果一致的会话中使用读取关注\"majority\"和写入关注 \"majority\"可提供以下因果一致性保证： ✅自己读✅单调读read单调写✅写跟随读 方案1（读关注“多数”和写关注“多数”） 在具有两个主操作的过渡期内，由于只有Pnew操作才能满足写关注的写操作，因此客户机会话可以成功发出以下操作序列：{ w: \"majority\" } 序列 例 1.write1\"majority\" 到 新的关注Pnew2.read1>与读关心\"majority\"到S23.write2\"majority\"到新的关注Pnew 4.read2与读取关注\"majority\"到S3 对于项目A，更新qty为50。阅读项目A。对于qty小于或等于的项目50，更新restock到true。阅读项目A。 ✅ 自己写 read1从S2读取数据，该数据反映了write1之后的状态。read2从S1读取数据，该数据反映了write1之后是write2之后的状态。 ✅ 单调读 read2从S3中读取反映read1之后状态的数据。 ✅ 单调写 write2更新Pnew数据，以反映write1之后的状态。 ✅ 写跟随读 write2更新Pnew数据，以反映read1之后的数据状态（即，较早的状态反映read1读取的数据）。 方案2（读取关注“多数”和写入关注“多数”） 考虑一个替代序列，其中具有读关注的read1\"majority\"路由到S1： 序列 例 1.write1\"majority\" 到 新的关注Pnew2.read1>与读关心\"majority\"到S23.write2\"majority\"到新的关注Pnew 4.read2与读取关注\"majority\"到S3 对于项目A，更新qty为50。阅读项目A。对于qty小于或等于的项目50，更新restock到true。阅读项目A。 在这个序列中，read1在Pold上的多数提交点提前之前不能返回。在Pold和S1能够与复制集的其余部分通信之前，这是不可能发生的;此时，Pold已经退出(如果还没有)，两个成员从副本集中的其他成员同步(包括write1)。 ✅ 自己写 read1反映了write11之后的数据状态，尽管在网络分区已修复并且该成员已与副本集的其他成员进行同步之后。read2从S3读取数据，该数据反映了write11之后是write2之后的状态。 ✅ 单调读 read2从S3读取数据，该数据反映read1之后的状态（即，较早的状态反映在read1读取的数据中）。 ✅ 单调写 write2更新Pnew数据，以反映write1之后的状态。 ✅ 写跟随读 write2更新Pnew数据，以反映read1之后的数据状态（即，较早的状态反映read1读取的数据）。 读关注\"majority\"和写关注{w: 1} 如果因果一致性暗示持久性，则在因果一致性会话中使用读关注\"majority\"和写关注 可提供以下因果一致性保证：{ w: 1 } ❌自己读 ✅单调读read单调写. ✅写跟随读 如果因果一致性并不意味着持久性： ✅自己读. ✅单调读read单调写. ✅写跟随读 方案3（“关注多数”和“关注关注” ）{w: 1} 在过渡期内有两个初选，因为无论Pold与Pnew能满足与写入 的写入关注，一个客户端会话可以成功地发出以下的操作序列，但不是因果关系一致，如果一致因果意味着耐久性：{ w: 1 } 序列 例 1.write1与写入关注 到 { w: 1 }Pold2.read11与读关心\"majority\"到S23.write2到新的关注{ w: 1 }Pnew 4.read2与读取关注\"majority\"到S3 对于项目A，更新qty为50。阅读项目A。对于qty小于或等于的项目50，更新restock到true。阅读项目A。 按照这个顺序 直到Pnew上的大多数提交点超过了write1的时间，read1才会返回。 直到Pnew上的大多数提交点超过了write2的时间，read2才能返回。 当网络分区恢复时，write1将回滚。 ➤ 如果因果一致性意味着持久性 ❌ 自己写 read1从S2读取的数据不反映write1之后的状态。 ✅ 单调读 read2从S3读取数据，该数据反映read1之后的状态（即，较早的状态反映在read1读取的数据中）。 ❌ 单调写 write2更新了Pnew数据，而不会反映write1之后的状态。 ✅ 写跟随读 write2更新Pnew数据，以反映read1之后的状态（即，较早的状态反映read1读取的数据）。 ➤ 如果因果一致性并不意味着持久性 ✅ 自己写 read1从S2读取数据，返回反映与write1等效的状态的数据，然后回退write1。 ✅ 单调读 read2从S3读取数据，该数据反映read1之后的状态（即，较早的状态反映在read1读取的数据中）。 ✅ 单调写 write2更新了Pnew的数据，这等效于write1之后回退写1的数据。 ✅ 写跟随读 write2更新Pnew数据，以反映read1之后的状态（即，较早的状态反映read1读取的数据）。 方案4（“关注多数”和“关注关注” ）{w: 1} 考虑一个替代序列，其中具有读关注的读1\"majority\"路由到S1： 序列 例 1.write1与写入关注 到 { w: 1 }Pold2.read11与读关心\"majority\"到S13.write2到新的关注{ w: 1 }Pnew 4.read2与读取关注\"majority\"到S3 对于项目A，更新qty为50。阅读项目A。对于qty小于或等于的项目50，更新restock到true。阅读项目A。 按此顺序： 直到S1上的大多数提交点提高，read1才能返回。在Pold和S1能够与复制集的其他成员进行通信之前，这是不可能发生的。此时，Pold已经退出(如果还没有)，write1将从Pold和S1回滚，两个成员将与复制集的其他成员同步。 ➤ 如果因果一致性意味着持久性 ❌ 自己写 read1读取的数据不反映已回退的write1的结果。 ✅ 单调读 read2从S3读取数据，该数据反映read1之后的状态（即，其较早的状态反映read1读取的数据）。 ❌ 单调写 write2更新关于Pnew的数据，该数据不反映write1之后的状态，该write1在write2之前但已回滚。 ✅ 写跟随读 write2更新Pnew数据，以反映read1之后的状态（即，其较早的状态反映read1读取的数据）。 ➤ 如果因果一致性并不意味着持久性 ✅ 自己写 read1返回反映write1最终结果的数据，因为write1最终会回滚。 ✅ 单调读 read2从S3读取数据，该数据反映read1之后的状态（即，其较早的状态反映read1读取的数据）。 ✅ 单调写 write2更新Pnew上的数据，这等效于write1之后回退write1的数据。 ✅ 写跟随读 write2更新Pnew数据，以反映read1之后的状态（即，其较早的状态反映read1读取的数据）。 读关注\"local\"和写关注{w: 1} 在因果一致的会话中使用读关注\"local\"和写关注 不能保证因果一致性。{ w: 1 } ❌自己读. ❌单调读read单调写. ❌写跟随读 在某些情况下（但不一定在所有情况下），此组合可以满足所有四个因果一致性保证。 方案5（“本地关注”和“关注关注” ）{w: 1} 在这个短暂的时期，因为无论Pold与 Pnew能满足与写入的写入关注，一个客户端会话可以发出以下的操作序列成功，但不是因果关系是一致的：{ w: 1 } 序列 例 1.write1与写入关注 到 { w: 1 }Pold2.read11与读关心\"majority\"到S13.write2到新的关注{ w: 1 }Pnew 4.read2与读取关注\"majority\"到S3 对于项目A，更新qty为50。阅读项目A。对于qty小于或等于的项目50，更新restock到true。阅读项目A。 ❌自己写 read2从S3读取数据，该数据仅反映write2之后的状态，而不反映write1 之后是write2的状态。 ❌单调读 read2从S3读取数据，该数据不反映read1之后的状态（即，较早的状态不反映read1读取的数据）。 ❌单调写 write2更新了Pnew数据，而不会反映write1之后的状态。 ❌写跟随读 write2更新Pnew的数据，该数据不反映read1之后的状态（即，较早的状态不反映read1读取的数据）。 读关注\"local\"和写关注\"majority\" 在因果一致的会话中使用读取关注\"local\"和写入关注 \"majority\"可提供以下因果一致性保证： ❌自己读 ❌单调读read单调写 ❌写跟随读 在某些情况下（但不一定在所有情况下），此组合可以满足所有四个因果一致性保证。 方案6（“关注本地”和“关注多数”） 在此过渡期间，因为只有Pnew才能完成与 写入有关的写入，所以客户机会话可以成功发出以下操作序列，但因果关系不一致：{ w: \"majority\" } 序列 例 1.write1\"majority\" 到 新的关注Pnew2.read1>与读关心\"majority\"到S13.write2\"majority\"到新的关注Pnew 4.read2与读取关注\"majority\"到S3 对于项目A，更新qty为50。阅读项目A。对于qty小于或等于的项目50，更新restock到true。阅读项目A。 ❌阅读自己的文章。 read1从S1读取不反映write11后状态的数据。 ❌单调读。 read2从S3读取数据，该数据不反映read1之后的状态（即，较早的状态不反映read1读取的数据）。 ✅单调写 write2更新Pnew数据，以反映write1之后的状态。 ❌写跟随阅读。 write2更新Pnew的数据，该数据不反映read1之后的状态（即，较早的状态不反映read1读取的数据）。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/MongoDB-CRUD-Concepts/Distributed-Queries.html":{"url":"docs/MongoDB-CRUD-Operations/MongoDB-CRUD-Concepts/Distributed-Queries.html","title":"Distributed Queries","keywords":"","body":"分布式查询 在本页面 读取复制集的操作 在复制集上进行写操作 读取分片群集的操作 在分片群集上写操作 读取复制集的操作 默认情况下，客户端读取复制集的主副本;但是，客户端可以指定一个读首选项，以便对其他成员进行直接读操作。例如，客户端可以配置读取偏好，从二级或从最近的成员读取到: 减少多数据中心部署中的延迟， 通过分配高读取量（相对于写入量）来提高读取吞吐量， 执行备份操作，和/或 允许读取直到选择一个新的主节点。 来自复制集的次要成员的读取操作可能无法反映主要数据库的当前状态。将读取操作定向到不同服务器的读取首选项可能会导致非单调读取。 在3.6版中进行了更改：从MongoDB 3.6开始，客户端可以使用因果一致的会话，这提供了各种保证，包括单调读取。 您可以基于每个连接或每个操作配置读取首选项。有关读取首选项或读取首选项模式的更多信息，请参见读取首选项和 读取首选项模式。 在复制集上进行写操作 在复制集中，所有的写操作都指向集合的主节点。主服务器应用写操作并将操作记录在主服务器的操作日志或oplog上。oplog是对数据集的可重复操作序列。集合中的次要成员不断复制oplog，并在一个异步进程中将这些操作应用到自己身上。 有关副本集和写入操作的更多信息，请参见 复制和 写入问题。 读取分片群集的操作 分片集群允许您以一种对应用程序几乎透明的方式在mongod实例集群之间划分数据集。有关分片集群的概述，请参阅本手册的分片部分。 对于分片群集，应用程序向mongos与该群集关联的实例之一发出操作 。 当分片群集上的读取操作定向到特定分片时，效率最高。分片集合的查询应包含集合的分片键。当查询包含分片键时，mongos可以使用配置数据库中的群集元数据将查询路由到分片。 如果查询不包含分片键，则mongos必须将查询定向到集群中的所有分片。这些分散的收集查询可能效率很低。在较大的群集上，分散收集查询对于常规操作是不可行的。 对于复制集分片，从复制集的辅助成员进行的读取操作可能无法反映主副本的当前状态。将读取操作定向到不同服务器的读取首选项可能会导致非单调读取。 注意 从MongoDB 3.6开始， 客户端可以使用因果一致的 会话，从而提供各种保证，包括单调读取。 碎片副本集的所有成员（不仅是主要副本副本）都维护有关块元数据的元数据。如果不使用读取关注点，这将防止从辅助节点读取返回孤立的数据\"available\"。在较早的版本中，无论是否关注读操作，从辅助对象进行的读操作都可能返回孤立的文档。 有关分片群集中读取操作的更多信息，请参见 mongos和Shard Keys 部分。 在分片群集上写操作 对于分片群集中的分片集合，该 mongos指令将写操作从应用程序定向到负责数据集特定部分的分片。在mongos使用来自集群的元数据 的配置数据库以路由写操作到适当的碎片。 MongoDB 根据分片键的值将分片集合中的数据划分为多个范围。然后，MongoDB将这些块分配给分片。分片键确定块到分片的分布。这可能会影响群集中写操作的性能。 重要 影响单个文档的 更新操作必须包含分片键或_id 字段。如果具有分片密钥，则影响多个文档的更新在某些情况下会更有效，但可以广播到所有分片。 如果分片键的值在每次插入时增加或减少，则所有插入操作都将针对单个分片。结果，单个分片的容量成为分片簇的插入容量的限制。 欲了解更多信息，请参阅分片和 批量写入操作。 ​ 也可以看看： ​ 可重试写入 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/MongoDB-CRUD-Concepts/Linearizable-Reads-via-findAndModify.html":{"url":"docs/MongoDB-CRUD-Operations/MongoDB-CRUD-Concepts/Linearizable-Reads-via-findAndModify.html","title":"Linearizable Reads via findAndModify","keywords":"","body":"可线性通过findAndModify读取 概述 从复制集读取数据时，可能会读取过时(即可能并不能反映所有写道,发生前读操作)或不持久(即数据可能反映了写的状态还没有得到多数或复制集成员因此可以回滚)的数据，这取决于所使用的读取关注点。 从3.4版本开始，MongoDB引入了“可线性化”的读关注点，它返回的是持久的数据，不会过时。可线性化的读关注保证仅适用于读操作指定了唯一标识单个文档的查询筛选器。 本教程概述了一个替代过程，对于使用MongoDB 3.2的部署，该过程使用db.collection.findAndModify()来读取不过时且不能回滚的数据。对于MongoDB 3.4，尽管可以应用概述的过程，但请参阅“线性化”)阅读问题。 可线性通过findAndModify读取 此过程用于db.collection.findAndModify()读取不过期且无法回滚的数据。为此，该过程使用findAndModify()具有写关注的方法来修改文档中的伪字段。具体来说，该过程要求： db.collection.findAndModify()使用完全匹配查询，并且必须存在唯一索引 才能满足该查询。 findAndModify()必须实际修改文档；即导致文档更改。 findAndModify()必须使用写关注 。{ w: \"majority\" } 重要 “仲裁读取”过程比单纯使用读取问题要花费大量成本，\"majority\"因为它会导致写入延迟而不是读取延迟。仅在绝对不过期的情况下才应使用此技术。 前提条件 本教程从名为products的集合中读取内容。使用以下操作初始化集合。 db.products.insert( [ { _id: 1, sku: \"xyz123\", description: \"hats\", available: [ { quantity: 25, size: \"S\" }, { quantity: 50, size: \"M\" } ], _dummy_field: 0 }, { _id: 2, sku: \"abc123\", description: \"socks\", available: [ { quantity: 10, size: \"L\" } ], _dummy_field: 0 }, { _id: 3, sku: \"ijk123\", description: \"t-shirts\", available: [ { quantity: 30, size: \"M\" }, { quantity: 5, size: \"L\" } ], _dummy_field: 0 } ] ) 该集合中的文档包含一个虚拟字段_dummy_field，该字段 db.collection.findAndModify()在本教程中将通过递增 。如果该字段不存在，则该db.collection.findAndModify()操作会将字段添加到文档中。该字段的目的是确保db.collection.findAndModify()对文档进行修改。 程序 1.创建一个唯一索引。 在将用于指定db.collection.findAndModify()操作中完全匹配的字段上创建唯一索引。 本教程将在sku现场使用完全匹配。这样，在sku字段上创建唯一索引。 db.products.createIndex( { sku: 1 }, { unique: true } ) 2.使用findAndModify读取提交的数据。 使用该db.collection.findAndModify()方法对要阅读的文档进行简单更新，然后返回修改后的文档。需要写关注。要指定要阅读的文档，必须使用唯一索引支持的完全匹配查询。{ w: \"majority\" } 下面的findAndModify()操作在唯一索引的字段sku上指定精确匹配，并增加匹配文档中名为_dummy_field的字段。虽然不是必需的，但该命令的写操作还包括一个5000毫秒的wtimeout值，以防止在写操作不能传播到大多数投票成员时永远阻塞操作。 var updatedDocument = db.products.findAndModify( { query: { sku: \"abc123\" }, update: { $inc: { _dummy_field: 1 } }, new: true, writeConcern: { w: \"majority\", wtimeout: 5000 } } ); 即使在副本集中的两个节点认为它们是主节点的情况下，也只有一个节点能够用w:“majority”完成写操作。因此，只有当客户机连接到真正的主服务器来执行操作时，具有“多数”写关注点的findAndModify()方法才会成功。 由于仲裁读取过程只会增加文档中的虚拟字段，因此您可以安全地重复调用 findAndModify()，并根据需要调整 wtimeout。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/MongoDB-CRUD-Concepts/Query-Plans.html":{"url":"docs/MongoDB-CRUD-Operations/MongoDB-CRUD-Concepts/Query-Plans.html","title":"Query Plans","keywords":"","body":"查询计划 在本页面 计划缓存条目状态 queryHash planCacheKey 可用性 对于查询，MongoDB查询优化器在给定可用索引的情况下选择并缓存效率最高的查询计划。最有效的查询计划的评估是基于查询执行计划在查询计划评估候选计划时执行的“工作单元”(工作)的数量。 关联的计划缓存条目用于具有相同查询形状的后续查询。 计划缓存条目状态 从MongoDB 4.2开始，缓存条目与状态关联： 州   描述 失踪 高速缓存中不存在此形状的条目。对于查询，如果形状的缓存条目状态为 Missing：评估候选计划并选择获奖计划。所选计划及其值将以非活动状态添加到缓存中works。 不活跃 缓存中的条目是此形状的占位符条目。也就是说，计划者已经看到了形状并计算了其成本（works价值）并存储为占位符条目，但查询形状不用于生成查询计划。对于查询，如果形状的缓存条目状态为不 活动：评估候选计划并选择获奖计划。将所选计划的works值与非活动条目的值进行比较。如果所选计划的works值为：小于或等于非活动条目的，所选计划将替换占位符“不 活动”条目，并具有“ 活动”状态。如果在替换发生之前，“ 非活动”条目变为“ 活动”（例如，由于其他查询操作），则仅当新活动条目的works值大于所选计划时，才会替换该新活动条目。大于非活动条目的数量，不活动条目保留，但其works值增加。 活性 缓存中的条目用于中奖计划。计划者可以使用该条目来生成查询计划。对于查询，如果形状的缓存条目状态为 Active：活动条目用于生成查询计划。计划者还评估条目的性能，如果条目的 works值不再符合选择标准，它将转换为非活动状态。 有关触发对计划缓存进行更改的其他方案，请参阅计划缓存刷新。 查询计划和高速缓存信息 要查看给定查询的查询计划信息，可以使用 db.collection.explain()或cursor.explain()。 从MongoDB 4.2开始，您可以使用$planCacheStats 聚合阶段来查看集合的计划缓存信息。 计划缓存刷新 如果mongod 重新启动或关闭，查询计划缓存将不会保留。此外： 索引或收集删除之类的目录操作会清除计划缓存。 最近最少使用（LRU）高速缓存替换机制将清除最近最少访问的高速缓存条目，而不管其状态如何。 用户还可以： 使用PlanCache.clear()方法手动清除整个计划缓存 。 使用PlanCache.clearPlansByQuery()方法手动清除特定的计划缓存条目 。 也可以看看 queryHash和planCacheKey queryHash和planCacheKey queryHash 为了帮助识别具有相同查询形状的慢速查询，从MongoDB 4.2开始，每个查询形状都与一个queryHash相关联。queryHash是一个十六进制字符串，表示查询形状的散列，并且只依赖于查询形状。 注意 与任何哈希函数一样，两个不同的查询形状可能会导致相同的哈希值。但是，不同查询形状之间不会发生哈希冲突。 planCacheKey 为了更深入地了解查询计划缓存，MongoDB 4.2引入了planCacheKey。 planCacheKey 是与查询关联的计划缓存条目的键的哈希值。 注意 与queryHash不同，planCacheKey是查询形状和当前可用的形状索引的函数。也就是说，如果添加/删除了支持查询形状的索引，planCacheKey值可能会改变，而queryHash值不会改变。 例如，考虑一个具有以下索引的foo集合: db.foo.createIndex( { x: 1 } ) db.foo.createIndex( { x: 1, y: 1 } ) db.foo.createIndex( { x: 1, z: 1 }, { partialFilterExpression: { x: { $gt: 10 } } } ) 集合上的以下查询具有相同的形状: db.foo.explain().find( { x: { $gt: 5 } } ) // Query Operation 1 db.foo.explain().find( { x: { $gt: 20 } } ) // Query Operation 2 对于这些查询，带有部分过滤表达式的索引可以支持查询操作2，但不支持查询操作1。由于支持查询操作1的索引与查询操作2不同，这两个查询具有不同的planCacheKey。 如果删除了其中一个索引，或者添加了一个新的索引{x: 1, a: 1}，那么用于这两个查询操作的planCacheKey将会改变。 可用性 queryHash和planCacheKey是可用的在: explain() output字段： queryPlanner.queryHash和 queryPlanner.planCacheKey 记录慢查询时，探查器日志消息 和诊断日志消息（即mongod / mongos日志消息）。 $planCacheStats聚合阶段（MongoDB 4.2中的新增功能） PlanCache.listQueryShapes() 方法/ planCacheListQueryShapes命令 PlanCache.getPlansByQuery() 方法/ planCacheListPlans命令 索引筛选器 索引筛选器确定优化器为查询形状评估哪些索引。查询形状由查询、排序和投影规范的组合组成。如果存在针对给定查询形状的索引筛选器，则优化器仅考虑筛选器中指定的那些索引。 当查询形状存在索引过滤器时，MongoDB将忽略 hint()。要查看MongoDB是否对查询形状应用了索引过滤器，请检查方法的indexFilterSet 字段。db.collection.explain()cursor.explain() 索引过滤器仅影响优化器评估的索引；对于给定的查询形状，优化器仍然可以选择将集合扫描作为获胜计划。 索引过滤器在服务器进程的持续时间内存在，并且在关闭后不会持续存在。MongoDB还提供了手动删除过滤器的命令。 因为索引过滤器会覆盖优化器和hint()方法的预期行为，所以请谨慎使用索引过滤器。 见planCacheListFilters， planCacheClearFilters和planCacheSetFilter。 ​ 也可以看看： ​ 索引策略 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/MongoDB-CRUD-Concepts/Query-Optimization.html":{"url":"docs/MongoDB-CRUD-Operations/MongoDB-CRUD-Concepts/Query-Optimization.html","title":"Query Optimization","keywords":"","body":"查询优化 在本页面 创建索引以支持读取操作 查询选择性 覆盖查询 索引通过减少查询操作需要处理的数据量来提高读操作的效率。这简化了与在MongoDB中完成查询相关的工作。 创建索引以支持读取操作 如果应用程序查询特定字段或字段集上的集合，那么查询字段上的索引或字段集上的复合索引可以防止查询扫描整个集合来查找和返回查询结果。有关索引的更多信息，请参阅MongoDB中索引的完整文档。 例子 应用程序inventory在type现场查询集合 。该type字段的值是用户驱动的。 var typeValue = ; db.inventory.find( { type: typeValue } ); 要提高此查询的性能，请向type字段上的inventory集合添加升序或降序索引。在mongo shell中，您可以使用db.collection.createIndex()方法创建索引: db.inventory.createIndex( { type: 1 } ) 这个索引可以防止上述类型查询扫描整个集合返回结果。 要使用索引分析查询的性能，请参阅 分析查询性能。 除了优化读取操作外，索引还可以支持排序操作并允许更有效地利用存储。有关索引创建的更多信息，请参见 db.collection.createIndex()和 索引。 对于单字段索引，升序和降序之间的选择并不重要。对于复合索引，选择很重要。有关更多详细信息，请参见索引顺序。 查询选择性 查询选择性指的是查询谓词排除或过滤集合中的文档的能力。查询选择性可以决定查询是否能够有效地使用索引，甚至根本不使用索引。 选择性更强的查询匹配的文档比例更小。例如，惟一_id字段上的相等匹配具有很高的选择性，因为它最多只能匹配一个文档。 选择性较低的查询匹配较大比例的文档。选择性较低的查询不能有效地使用索引，甚至根本不能使用索引。 例如，不等操作符$nin和 $ne的选择性不是很强，因为它们通常匹配索引的很大一部分。因此，在许多情况下，带有索引的$nin或 $ne查询的执行性能可能不比必须扫描集合中所有文档的$nin或 $ne查询好。 正则表达式的选择性取决于表达式本身。有关详细信息，请参见正则表达式和索引使用。regular expressions 覆盖查询 覆盖查询是可以使用索引完全满足而不需要检查任何文档的查询。当下列所有情况都适用时，索引将 覆盖查询： 查询 中的所有字段都是索引的一部分。 结果中返回的所有字段都在同一索引中。 查询中没有字段等于null(即{“field”:null}或{“field”:{$eq: null}})。 例如，一个集合inventory在type和item字段上具有以下索引 ： db.inventory.createIndex( { type: 1, item: 1 } ) 该索引将涵盖以下操作，该操作在type和item字段上查询 并仅返回该item字段： db.inventory.find( { type: \"food\", item:/^c/ }, { item: 1, _id: 0 } ) 为了让指定的索引覆盖查询，投影文档必须显式地指定_id: 0来从结果中排除_id字段，因为索引不包括_id字段。 3.6版本的改变:索引可以覆盖对嵌入文档中的字段的查询。 例如，考虑一个userdata集合，它具有以下形式的文档: { _id: 1, user: { login: \"tester\" } } 该集合具有以下索引： { \"user.login\": 1 } 该索引将涵盖以下查询：{ \"user.login\": 1 } db.userdata.find( { \"user.login\": \"tester\" }, { \"user.login\": 1, _id: 0 } ) 要为嵌入式文档中的字段建立索引，请使用点符号。 多键覆盖 从3.6开始，如果索引跟踪哪个或哪个字段导致索引为多键，那么多键索引可以覆盖对非数组字段的查询。在MongoDB 3.4或更高版本的存储引擎(MMAPv1除外)上创建的多键索引跟踪该数据。 多键索引不能覆盖对数组字段的查询。 性能 因为索引包含查询所需的所有字段，所以MongoDB既可以匹配查询条件 ，又可以仅使用索引返回结果。 仅查询索引要比查询索引之外的文档快得多。索引键通常比它们编目的文档小，索引通常在RAM中可用，或按顺序位于磁盘上。 局限性 索引字段的限制 地理空间索引不能 覆盖查询。 多键索引不能覆盖对数组字段的查询。 也可以看看 多键覆盖 分片集合的限制 在MongoDB中3.0开始，索引不能覆盖在查询 分片的时候对一个运行集合 mongos，如果指数不包含片键，除了具有以下不同的_id指标：如果在分片集合的查询只规定了一个条件_id字段并仅返回该_id字段，即使该 字段不是分片键，_id索引也可以覆盖针对mongos该_id字段的查询。 在以前的版本中，在对mongos运行时，索引不能覆盖 对分片集合的查询。 解释 要确定查询是否为覆盖查询，请使用 db.collection.explain()或explain() 方法，然后查看结果。 db.collection.explain()提供有关其他操作执行的信息，例如db.collection.update()。有关db.collection.explain()详细信息，请参见 。 有关更多信息，请参见度量索引使用。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/MongoDB-CRUD-Concepts/Query-Optimization/Evaluate-Performance-of-Current-Operations.html":{"url":"docs/MongoDB-CRUD-Operations/MongoDB-CRUD-Concepts/Query-Optimization/Evaluate-Performance-of-Current-Operations.html","title":"Evaluate Performance of Current Operations","keywords":"","body":"评估当前运营的绩效 在本页面 使用数据库分析器来计算针对数据库的操作 使用db.currentOp()来评估mongod业务 使用explain来评估查询性能 以下各节介绍了用于评估操作性能的技术。 使用数据库分析器来计算针对数据库的操作 MongoDB提供了一个数据库分析器，它显示针对数据库的每个操作的性能特征。使用分析器定位任何运行缓慢的查询或写操作。例如，您可以使用此信息来确定要创建什么索引。 从MongoDB 4.2开始，用于读写操作的profiler条目和诊断日志消息(即mongod/mongos日志消息)包括: queryHash帮助识别具有相同查询形状的慢速查询 。 planCacheKey为深入了解查询计划缓存提供慢速查询。 从版本4.2(也可以从4.0.6开始使用)开始，复制集的次要成员现在会记录花费超过慢操作阈值的oplog条目。这些缓慢的oplog消息被记录在REPL组件下的诊断日志中，并应用文本op: 取num>ms。这些较慢的oplog条目仅依赖于较慢的操作阈值。它们不依赖于日志级别(系统或组件级别)、分析级别或较慢的操作采样率。分析器不会捕获很慢的oplog条目。 有关更多信息，请参见Database Profiler。 使用db.currentOp()到评估mongod业务 该db.currentOp()方法报告mongod实例上正在运行的当前操作。 使用explain来评估查询性能 在cursor.explain()与db.collection.explain() 方法返回关于查询执行的信息，如MongoDB的选择以满足查询和执行统计数据的指标。您可以在queryPlanner 模式，executionStats模式或 allPlansExecution模式下运行这些方法，以控制返回的信息量。 https://docs.mongodb.com/manual/reference/program/mongo/#bin.mongo) 例子 要在名为records的集合中查询与表达式{a: 1}匹配的文档时使用cursor.explain()，在mongo shell中使用类似于下面的操作: db.records.find( { a: 1 } ).explain(\"executionStats\") 从MongoDB 4.2开始，explain输出包括: queryHash帮助识别具有相同查询形状的慢速查询。 planCacheKey为深入了解查询计划缓存提供慢速查询。 欲了解更多信息，请参阅解释结果， cursor.explain()，db.collection.explain()，和 分析查询性能。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/MongoDB-CRUD-Concepts/Query-Optimization/Optimize-Query-Performance.html":{"url":"docs/MongoDB-CRUD-Operations/MongoDB-CRUD-Concepts/Query-Optimization/Optimize-Query-Performance.html","title":"Optimize Query Performance","keywords":"","body":"优化查询性能 在本页面 创建索引以支持查询 限制查询结果数以减少网络需求 使用投影仅返回必要的数据 使用$hint选择一个特定的索引 使用增量运算符在服务器端执行操作 创建索引以支持查询 对于常见的查询，请创建索引。如果一个查询搜索多个字段，请创建一个复合索引。扫描索引比扫描集合快得多。索引结构小于文档参考，并按顺序存储参考。 例子 如果你有一个包含博客帖子的帖子集合，并且你经常发出一个查询，对author_name字段排序，那么你可以通过在author_name字段上创建一个索引来优化查询: db.posts.createIndex( { author_name : 1 } ) 索引还可以提高对给定字段进行常规排序的查询的效率。 例子 如果您定期发出查询排序的timestamp字段，然后您可以优化查询创建一个索引的timestamp字段: 创建此索引： db.posts.createIndex( { timestamp : 1 } ) 优化此查询： db.posts.find().sort( { timestamp : -1 } ) 因为MongoDB可以按升序和降序读取索引，所以单键索引的方向并不重要。 索引支持查询，更新操作以及聚合管道的某些阶段 。 在以下情况下，BinData更有效地将类型为索引的键存储在索引中： 二进制子类型的值在0-7或128-135的范围内，并且 字节数组的长度为：0、1、2、3、4、5、6、7、8、10、12、14、16、20、24或32。 限制查询的结果数以减少网络需求 MongoDB 游标以多个文档为一组返回结果。如果知道所需结果的数量，则可以通过发出该limit() 方法来减少对网络资源的需求。 这通常与排序操作结合使用。例如，如果您只需要从查询到posts 集合的10个结果，则可以发出以下命令： db.posts.find().sort( { timestamp : -1 } ).limit(10) 有关限制结果的更多信息，请参见 limit() 使用投影仅返回必要的数据 当您仅需要文档中字段的子集时，可以通过仅返回所需的字段来获得更好的性能： 例如，如果在查询中的posts集合，你只需要timestamp，title，author，和abstract领域，你会发出以下命令： 复制复制的 db 。职位。find （ {}， { timestamp ： 1 ， title ： 1 ， author ： 1 ， abstract ： 1 } ）。排序（ { 时间戳 ： - 1 } ） 有关使用投影的更多信息，请参见 要从查询返回的项目字段。 使用$hint选择一个特定的指数 在大多数情况下，查询优化器为特定操作选择最佳索引。但是，您可以使用hint()方法强制MongoDB使用特定索引。使用 hint()以支持性能测试，或在某些查询，您必须选择包含在几个索引中的一个或多个字段。 使用增量运算符在服务器端执行操作 使用MongoDB的$inc操作符递增或递减文档中的值。操作符在服务器端增加字段的值，作为选择文档、在客户端进行简单修改然后将整个文档写入服务器的替代方法。$inc操作符还可以帮助避免竞争条件，当两个应用程序实例查询一个文档、手动增加一个字段并同时将整个文档保存回来时，可能会出现竞争条件。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/MongoDB-CRUD-Concepts/Query-Optimization/Write-Operation-Performance.html":{"url":"docs/MongoDB-CRUD-Operations/MongoDB-CRUD-Concepts/Query-Optimization/Write-Operation-Performance.html","title":"Write Operation Performance","keywords":"","body":"写操作性能 在本页面 索引 储存性能 索引 集合上的每个索引都会给写操作的性能增加一些负担。 对于集合上的每个操作insert或delete写入操作，MongoDB从目标集合的每个索引中插入或删除相应的文档键。根据受update影响的键，更新操作可能导致对集合上的索引子集进行更新。 注意 如果写操作中涉及的文档包含在索引中，则MongoDB仅更新稀疏索引或 部分索引。 一般来说，索引为读操作提供的性能收益抵得上插入损失。但是，为了尽可能优化写性能，在创建新索引和评估现有索引时要小心，以确保您的查询实际使用这些索引。 有关索引和查询，请参见查询优化。有关索引的更多信息，请参见索引和 索引策略。 储存性能 硬件 存储系统的功能为MongoDB的写操作性能创建了一些重要的物理限制。与驱动器的存储系统相关的许多独特因素都会影响写入性能，包括随机访问模式，磁盘缓存，磁盘预读和RAID配置。 对于随机工作负载，固态驱动器（SSD）的性能可比旋转硬盘（HDD）高100倍或更多。 ​ 看到: ​ 生产说明中有关其他硬件和配置选项的建议。 日记 为了在崩溃时提供持久性，MongoDB使用预写日志记录到磁盘日志上。MongoDB首先将内存中的更改写入磁盘上的日志文件。如果MongoDB在对数据文件进行更改之前终止或遇到错误，MongoDB可以使用日志文件对数据文件应用写操作。 虽然日志提供的持久性保证通常超过了额外写操作的性能成本，但考虑一下日志和性能之间的以下交互: 如果日志和数据文件位于同一块设备上，则数据文件和日志可能必须竞争有限数量的可用I / O资源。将日志移动到单独的设备可能会增加写操作的容量。 如果应用程序指定了包括J选项的写关注点，mongod将减少日志写之间的持续时间，这会增加总体写负载。 日志写入之间的持续时间可以使用commitIntervalMs运行时选项进行配置 。减少日志提交之间的时间间隔将增加写入操作的数量，这可能会限制MongoDB的写入操作能力。增加日志提交之间的时间量可能会减少写操作的总数，但也会增加在发生故障的情况下日志不会记录写操作的机会。 有关日志记录的其他信息，请参见日志记录。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/MongoDB-CRUD-Concepts/Query-Optimization/Explain-Results.html":{"url":"docs/MongoDB-CRUD-Operations/MongoDB-CRUD-Concepts/Query-Optimization/Explain-Results.html","title":"Explain Results","keywords":"","body":"解释结果 在本页面 解释输出 queryPlanner executionStats serverInfo 3.0格式变更 集合扫描与索引使用 覆盖查询 索引交集 $or 表达 为了返回查询计划的信息和查询计划的执行统计信息，MongoDB提供: db.collection.explain()方法， cursor.explain()方法， 该explain命令。 explain结果将查询计划呈现为一个阶段树。 \"winningPlan\" : { \"stage\" : , ... \"inputStage\" : { \"stage\" : , ... \"inputStage\" : { \"stage\" : , ... } } }, 每个阶段将其结果(即文档或索引键)传递给父节点。叶节点访问集合或索引。内部节点操作子节点产生的文档或索引键。根节点是MongoDB派生结果集的最后一个阶段。 阶段描述了操作；例如 COLLSCAN 用于收集扫描 IXSCAN 用于扫描索引键 FETCH 用于检索文件 SHARD_MERGE 用于合并分片的结果 SHARDING_FILTER 用于从分片中筛选出孤立文档 解释输出 以下各节列出了该explain操作返回的一些关键字段。 注意 字段列表并不意味着详尽无遗，而只是强调了早期解释版本中的一些关键字段更改。 输出格式在各个发行版之间可能有所更改。 queryPlanner queryPlanner信息详细说明了查询优化器选择的计划。 未分片集合 分片集合 explain.queryPlanner 包含有关查询优化器选择查询计划的信息 。 explain.queryPlanner.``namespace 一个字符串，它指定.要对其运行查询的名称空间（即 ）。 explain.queryPlanner.``indexFilterSet 一个布尔值，指定MongoDB是否对查询形状应用了索引过滤器。 explain.queryPlanner.``queryHash 一个十六进制字符串，代表查询形状的哈希， 并且仅取决于查询形状。 queryHash可以帮助识别具有相同查询形状的慢查询（包括写操作的查询过滤器）。 注意 与任何散列函数一样，两个不同的查询形状可能导致相同的散列值。但是，不同查询形状之间不太可能出现哈希冲突。 只有当值为true且仅应用于聚合管道操作中的explain时，该字段才会出现。当为true时，由于管道已被优化，所以在输出中不会出现聚合阶段信息。 新版本4.2 explain.queryPlanner.winningPlan ​ 详细说明查询优化器选择的计划的文档。MongoDB将计划呈现为一个阶段树;例如，一个阶段可以有一个inputStage，如果该阶段有 多个子阶段，则可以有inputStage。 ​ explain.queryPlanner.winningPlan.stage ​ 表示舞台名称的字符串。 ​ 每个阶段由特定于该阶段的信息组成。例如，IXSCAN阶段将包括索引边界以及特定于索引扫描的其他数据。如果一个阶段有一个子 阶段或多个子阶段，那么这个阶段将有一个inputStage或inputStage。 ​ explain.queryPlanner.winningPlan.inputStage ​ 描述子阶段的文档，它向父阶段提供文档或索引键。如果父阶段只有一个子阶段，则会显示该字段。 ​ explain.queryPlanner.winningPlan.inputStages ​ 一系列描述子阶段的文档。子阶段将文档或索引键提供给父阶段。如果父级具有多个子节点，则该字段存在。例如，$或表达式的阶 段或索引交集会消耗来自多个源的输入。 ​ explain.queryPlanner.rejectedPlans ​ 查询优化器考虑和拒绝的候选计划的数组。如果没有其他候选计划，则该数组可以为空。 executionStats 返回的executionStats信息详细说明了获胜计划的执行情况。为了包括 executionStats在结果中，您必须在以下任一位置运行解释： 执行状态 allPlansExecution 详细模式。使用allPlansExecution模式包括在计划选择期间捕获的部分执行数据。 未分片集合 分片集合 explain.executionStats.executionStages ​ 以阶段树的形式详细说明获奖计划的完成执行情况；即一个阶段可以有一个inputStage或多个 inputStages。 ​ explain.executionStats.executionStages.works ​ 指定查询执行阶段执行的“工作单位”的数量。查询执行将其工作分为几个小单元。“工作单元”可能包括检查单个索引键，从集合中获 取单个文档，对单个文档应用投影或进行内部簿记。 ​ explain.executionStats.executionStages.advanced ​ 在此阶段返回到其父阶段的中间结果数，或将其前进。 ​ explain.executionStats.executionStages.needTime ​ 没有将中间结果提前到其父阶段的工作周期数（请参阅参考资料 explain.executionStats.executionStages.advanced）。例 如，索引扫描阶段可能会花费一个工作周期来寻找索引中的新位置，而不是返回索引键。 ​ 这个工作周期将计入explain.executionStats.executionStages.needTime而非计入 ​ explain.executionStats.executionStages.advanced。 ​ explain.executionStats.executionStages.needYield ​ 存储层请求查询阶段挂起处理并产生其锁的次数。 ​ explain.executionStats.executionStages.saveState ​ 查询阶段挂起处理并保存其当前执行状态的次数，例如，为准备产生锁而做的准备。 ​ explain.executionStats.executionStages.restoreState ​ 查询阶段恢复保存的执行状态的次数，例如，在恢复之前已产生的锁之后。 ​ explain.executionStats.executionStages.isEOF ​ 指定执行阶段是否已到达流的末尾： ​ 如果true或1，则执行阶段已到达流的末尾。 ​ 如果false或0，则阶段可能仍会返回结果。例如，考虑一个具有限制的查询，其执行阶段由查询LIMIT的输入阶段组 ​ 成IXSCAN。如果查询返回的值超过指定的限制，则该LIMIT阶段将报告，但其基础阶段将报告。isEOF: 1IXSCANisEOF: 0 ​ explain.executionStats.executionStages.inputStage.keysExamined ​ 对于扫描索引的查询执行阶段（例如IXSCAN）， keysExamined是在索引扫描过程中检查的入站和出站键的总数。如果索引扫描 由单个连续范围的键组成，则仅需要检查入站键。如果索引范围由几个键范围组成，则索引扫描执行过程可能会检查越界键，以便 从一个范围的末尾跳到下一个范围的末尾。 考虑以下示例，其中有一个字段索引， x并且集合包含100个文档，其x值从1到100： db.keys.find( { x : { $in : [ 3, 4, 50, 74, 75, 90 ] } } ).explain( \"executionStats\" ) ​ 查询将扫描键3和4。然后它将扫描键5，检测它是否超出范围，并跳到下一个键50。 ​ 继续这个过程，查询扫描键3、4、5、50、51、74、75、76、90和91。键5,51,76和91是仍在检查的超出范围的 ​ 键。keysExamined的值为10。 ​ explain.executionStats.executionStages.inputStage.docsExamined ​ 指定在查询执行阶段扫描的文档数量。 ​ 用于COLLSCAN阶段，以及从集合检索文档的阶段(例如FETCH) ​ explain.executionStats.executionStages.inputStage.seeks ​ 版本3.4中的新特性:仅用于索引扫描(IXSCAN)阶段。 ​ 为了完成索引扫描，我们必须将索引游标查找到新位置的次数。 explain.executionStats.allPlansExecution ​ 包含在计划选择阶段捕获的胜出计划和被否决计划的部分执行信息。只有当explain在所有计划执行冗长模式下运行时，该字段才 会出现。 serverInfo 未分片集合 分片集合 对于未分片的集合，explain返回serverInfoMongoDB实例的以下 信息： “ serverInfo”：{ “ host”：， “ port”：， “ version”：， “ gitVersion”： } 对于分片集合，explain返回serverInfo每个访问的分片的，并返回的 顶级 serverInfo对象mongos。 \"queryPlanner\" : { ... \"winningPlan\" : { \"stage\" : , \"shards\" : [ { \"shardName\" : , \"connectionString\" : , \"serverInfo\" : { \"host\" : , \"port\" : , \"version\" : , \"gitVersion\" : }, ... } ... ] } }, \"serverInfo\" : { // serverInfo for mongos \"host\" : , \"port\" : , \"version\" : , \"gitVersion\" : } 3.0格式变更 从MongoDB 3.0开始，结果的格式和字段explain 与以前的版本已更改。以下列出了一些主要区别。 集合扫描与索引使用 如果查询计划者选择了集合扫描，则解释结果将包括一个COLLSCAN阶段。 如果查询计划者选择了索引，则说明结果包括一个 IXSCAN阶段。该阶段包括诸如索引键样式，遍历方向和索引边界之类的信息。 在以前的MongoDB版本中，cursor.explain()返回的 cursor字段值为： BasicCursor 用于收集扫描， BtreeCursor [] 用于索引扫描。 有关收集扫描和索引扫描的执行统计信息的更多信息，请参见分析查询性能。 覆盖查询 当索引涵盖查询时，MongoDB既可以匹配查询条件，也可以仅使用索引键返回结果；即MongoDB无需检查集合中的文档即可返回结果。 当索引覆盖查询时，解释结果的IXSCAN 阶段不是该阶段的后代FETCH，而在 executionStats中，totalDocsExaminedis是0。 在MongoDB的早期版本中，cursor.explain()返回该 indexOnly字段以指示索引是否覆盖查询。 索引交集 对于索引交叉计划，结果将包括一个AND_SORTED阶段或一个AND_HASH 包含inputStages详细描述索引的数组的阶段。例如： { “ stage” ： “ AND_SORTED” ， “ inputStages” ： [ { “ stage” ： “ IXSCAN” ， ... }， { “ stage” ： “ IXSCAN” ， ... } ] } 在以前的MongoDB版本中，cursor.explain()返回cursor值为index交集的 字段。Complex Plan $or表达式 如果MongoDB对$or表达式使用索引，则结果将包括OR带有inputStages详细索引的数组的阶段 ；例如： 复制复制的 { “ stage” ： “ OR” ， “ inputStages” ： [ { “ stage” ： “ IXSCAN” ， ... }， { “ stage” ： “ IXSCAN” ， ... }， ... ] } 在MongoDB的早期版本中，cursor.explain()返回clauses详细说明索引的 数组。 分类阶段 如果MongoDB可以使用索引扫描来获取请求的排序顺序，则结果将不包含SORT阶段。否则，如果MongoDB无法使用索引进行排序，则explain结果将包括一个 SORT阶段。 在MongoDB 3.0之前，cursor.explain()返回此 scanAndOrder字段以指定MongoDB是否可以使用索引顺序返回排序的结果。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/MongoDB-CRUD-Concepts/Analyze-Query-Performance.html":{"url":"docs/MongoDB-CRUD-Operations/MongoDB-CRUD-Concepts/Analyze-Query-Performance.html","title":"Analyze Query Performance","keywords":"","body":"分析查询性能 在本页面 评估查询的性能 该 cursor.explain(\"executionStats\") 和db.collection.explain(\"executionStats\")方法提供了有关查询的性能统计信息。这些统计信息可用于衡量查询是否以及如何使用索引。 db.collection.explain() 提供关于其他操作(如db.collection.update())执行的信息。详细信息请参见db.collection.explain() 评估查询的性能 考虑一个包含以下文件的收集清单: { \"_id\" : 1, \"item\" : \"f1\", type: \"food\", quantity: 500 } { \"_id\" : 2, \"item\" : \"f2\", type: \"food\", quantity: 100 } { \"_id\" : 3, \"item\" : \"p1\", type: \"paper\", quantity: 200 } { \"_id\" : 4, \"item\" : \"p2\", type: \"paper\", quantity: 150 } { \"_id\" : 5, \"item\" : \"f3\", type: \"food\", quantity: 300 } { \"_id\" : 6, \"item\" : \"t1\", type: \"toys\", quantity: 500 } { \"_id\" : 7, \"item\" : \"a1\", type: \"apparel\", quantity: 250 } { \"_id\" : 8, \"item\" : \"a2\", type: \"apparel\", quantity: 400 } { \"_id\" : 9, \"item\" : \"t2\", type: \"toys\", quantity: 50 } { \"_id\" : 10, \"item\" : \"f4\", type: \"food\", quantity: 75 } 没有索引的查询 以下查询检索的文档中，quantity字段的值在100到200之间，包括: db.inventory.find( { quantity: { $gte: 100, $lte: 200 } } ) 查询返回以下文档: { \"_id\" : 2, \"item\" : \"f2\", \"type\" : \"food\", \"quantity\" : 100 } { \"_id\" : 3, \"item\" : \"p1\", \"type\" : \"paper\", \"quantity\" : 200 } { \"_id\" : 4, \"item\" : \"p2\", \"type\" : \"paper\", \"quantity\" : 150 } 要查看所选的查询计划，请将cursor.explain(\"executionStats\")游标方法链接到find命令的末尾: db.inventory.find( { quantity: { $gte: 100, $lte: 200 } } ).explain(\"executionStats\") explain() 返回以下结果： { “ queryPlanner” ： { “ plannerVersion” ： 1 ， ... “ winningPlan” ： { “ stage” ： “ COLLSCAN” ， ... } }， “ executionStats” ： { “ executionSuccess” ： true ， “ nReturned” ： 3 ， “ executionTimeMillis” ： 0 ， “ totalKeysExamined” ： 0 ， “ totalDocsExamined” ： 10 ， “ executionStages” ： { “阶段” ： “ COLLSCAN” ， ... }， ... }， ... } queryPlanner.winningPlan.stage显示 COLLSCAN以指示收集扫描。 收集扫描表明， mongod必须逐个文档扫描整个收集文档以识别结果。这通常是昂贵的操作，并且可能导致查询缓慢。 executionStats.nReturned显示3表示查询匹配并返回三个文档。 executionStats.totalKeysExamined显示0 以指示这是查询未使用索引。 executionStats.totalDocsExamined屏幕显示10 MongoDB必须扫描十个文档（即集合中的所有文档）才能找到三个匹配的文档。 匹配文档的数量和检查文档的数量之间的差异可能表明，为了提高效率，查询可能会受益于索引的使用。 查询与索引 为了支持对quantity字段的查询，请在quantity字段上添加索引: db.inventory.createIndex( { quantity: 1 } ) 要查看查询计划统计信息，请使用explain(“executionStats”)方法: db.inventory.find( { quantity: { $gte: 100, $lte: 200 } } ).explain(\"executionStats\") 该explain()方法返回以下结果: { “ queryPlanner” ： { “ plannerVersion” ： 1 ， ... “ winningPlan” ： { “ stage” ： “ FETCH” ， “ inputStage” ： { “ stage” ： “ IXSCAN” ， “ keyPattern” ： { “ quantity” ： 1 }， ... } }， “ rejectedPlans” ： [ ] }， “ executionStats” ： { “ executionSuccess” ： true ， “ nReturned” ： 3 ， “ executionTimeMillis” ： 0 ， “ totalKeysExamined” ： 3 ， “ totalDocsExamined” ： 3 ， “ executionStages” ： { ... }， ... }， ... } queryPlanner.winningPlan.inputStage.stage显示 IXSCAN以指示索引的使用。 executionStats.nReturned 显示3表示查询匹配并返回三个文档。 executionStats.totalKeysExamined显示3 以指示MongoDB扫描了三个索引条目。检查的键数与返回的文档数匹配，这意味着mongod只需检查索引键即可返回结果。在 mongod没有扫描所有的文件，只有三个匹配文档不得不被拉入内存中。这导致非常有效的查询。 executionStats.totalDocsExamined屏幕显示3 MongoDB扫描了三个文档。 如果没有索引，查询将扫描包含10个文档的整个集合，以返回3个匹配的文档。查询还必须扫描每个文档的全部内容，可能会将它们拉到内存中。这将导致昂贵的查询操作，并且可能会很慢。 当使用索引运行时，查询扫描了3个索引项和3个文档，以返回3个匹配的文档，从而产生一个非常高效的查询。 比较索引的性能 要手动比较使用多个索引的查询的性能，可以将 hint() 方法与explain()方法结合使用。 考虑以下查询: db.inventory.find( { quantity: { $gte: 100, $lte: 300 }, type: \"food\" } ) 查询返回以下文档: { \"_id\" : 2, \"item\" : \"f2\", \"type\" : \"food\", \"quantity\" : 100 } { \"_id\" : 5, \"item\" : \"f3\", \"type\" : \"food\", \"quantity\" : 300 } 要支持查询，添加复合索引。对于复合索引，字段的顺序很重要。 例如，添加以下两个复合索引。第一个索引首先按数量字段排序，然后按类型字段排序。第二个索引首先按类型排序，然后是quantity字段。 db.inventory.createIndex( { quantity: 1, type: 1 } ) db.inventory.createIndex( { type: 1, quantity: 1 } ) 评估第一个索引对查询的影响: db.inventory.find( { quantity: { $gte: 100, $lte: 300 }, type: \"food\" } ).hint({ quantity: 1, type: 1 }).explain(\"executionStats\") explain()方法返回如下输出: { \"queryPlanner\" : { ... \"winningPlan\" : { \"stage\" : \"FETCH\", \"inputStage\" : { \"stage\" : \"IXSCAN\", \"keyPattern\" : { \"quantity\" : 1, \"type\" : 1 }, ... } } }, \"rejectedPlans\" : [ ] }, \"executionStats\" : { \"executionSuccess\" : true, \"nReturned\" : 2, \"executionTimeMillis\" : 0, \"totalKeysExamined\" : 5, \"totalDocsExamined\" : 2, \"executionStages\" : { ... } }, ... } MongoDB扫描了5个索引键(executionStats.totalKeysExamined)以返回2个匹配的文档(executionStats.nReturned)。 评估第二个索引对查询的影响: db.inventory.find( { quantity: { $gte: 100, $lte: 300 }, type: \"food\" } ).hint({ type: 1, quantity: 1 }).explain(\"executionStats\") explain()方法返回如下输出: { \"queryPlanner\" : { ... \"winningPlan\" : { \"stage\" : \"FETCH\", \"inputStage\" : { \"stage\" : \"IXSCAN\", \"keyPattern\" : { \"type\" : 1, \"quantity\" : 1 }, ... } }, \"rejectedPlans\" : [ ] }, \"executionStats\" : { \"executionSuccess\" : true, \"nReturned\" : 2, \"executionTimeMillis\" : 0, \"totalKeysExamined\" : 2, \"totalDocsExamined\" : 2, \"executionStages\" : { ... } }, ... } MongoDB扫描了2个索引键(executionStats.totalKeysExamined)以返回2个匹配的文档(executionStats.nReturned)。 对于这个示例查询，复合索引{type: 1, quantity: 1}比复合索引{quantity: 1, type: 1}更有效。 ​ 也可以看看 ​ 查询优化，查询计划， 优化查询性能， 索引策略 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/MongoDB-CRUD-Operations/MongoDB-CRUD-Concepts/Tailable-Cursors.html":{"url":"docs/MongoDB-CRUD-Operations/MongoDB-CRUD-Concepts/Tailable-Cursors.html","title":"Tailable Cursors","keywords":"","body":"Tailable游标 默认情况下，当客户端使用完游标中的所有结果时，MongoDB将自动关闭游标。但是，对于有上限的集合，您可以使用一个可定制的游标，该游标在客户端穷尽初始游标的结果后保持打开状态。可跟踪游标在概念上等同于带-f选项的tail Unix命令(即“follow”模式)。在客户端向有上限的集合中插入新的额外文档之后，可定制游标将继续检索文档。 在具有高写量的有上限集合上使用可定制游标，因为索引不实用。例如，MongoDB复制使用可跟踪的游标跟踪主服务器的oplog. 注意 如果查询位于索引字段上，则不要使用可跟踪游标，而是使用常规游标。跟踪查询返回的索引字段的最后一个值。要检索新添加的文档，使用查询条件中索引字段的最后一个值再次查询集合，如下面的示例所示: db..find( { indexedField: { $gt: } } ) 考虑以下与可跟踪游标相关的行为: 可跟踪游标不使用索引，并按自然顺序返回文档。 由于可tailable游标不使用索引，因此查询的初始扫描可能开销较大;但是，在最初耗尽游标之后，后续对新添加文档的检索就不那么昂贵了。 可跟踪游标可能会死亡或无效，如果有下列情况: 查询返回不匹配。 游标返回集合“末尾”的文档，然后应用程序删除该文档。 一个已死亡游标的id为0。 请参阅驱动程序文档，以获取特定于驱动程序的方法以指定可跟踪游标。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Aggregation.html":{"url":"docs/Aggregation.html","title":"Aggregation","keywords":"","body":"聚合 在本页面 聚合管道 Aggregation Pipeline Map-Reduce 单用途聚合操作 Single Purpose Aggregation Operations 其他 Features 和行为 Additional Features and Behaviors 聚合操作处理数据记录和 return 计算结果。聚合操作将来自多个文档的值组合在一起，并且可以对分组数据执行各种操作以返回单个结果。 MongoDB 提供了三种执行聚合的方法：聚合管道，map-reduce function和单一目的聚合方法。 聚合管道 MongoDB 的Aggregation framework是以数据处理流水线的概念为蓝本的。文档进入 multi-stage 管道，将文档转换为聚合结果。 最基本的管道阶段提供过滤器，其操作类似于查询和文档转换，可以修改输出文档的形式。 其他管道操作提供了按特定字段或字段对文档进行分组和排序的工具，以及用于聚合数组内容(包括文档数组)的工具。此外，管道阶段可以使用operators执行任务，例如计算平均值或连接 string。 该管道使用 MongoDB 中的原生操作来提供高效的数据聚合，是 MongoDB 中数据聚合的首选方法。 聚合管道可以在分片集合 sharded collection上运行。 聚合管道可以使用索引来改善其某些阶段的性能。此外，聚合管道具有内部优化阶段。有关详细信息，请参阅管道操作和索引和聚合管道优化。 Map-Reduce MongoDB 还提供map-reduce操作来执行聚合。通常，map-reduce 操作有两个阶段：一个 map 阶段，它处理每个文档并为每个输入文档发出一个或多个 objects，并减少组合 map 操作输出的阶段。可选地，map-reduce 可以具有最终化阶段以对结果进行最终修改。与其他聚合操作一样，map-reduce 可以指定查询条件以选择输入文档以及排序和限制结果。 Map-reduce 使用自定义 JavaScript 函数来执行 map 并减少操作，以及可选的 finalize 操作。虽然自定义 JavaScript 与聚合管道相比提供了极大的灵活性，但通常，map-reduce 的效率低于聚合管道并且更复杂。 Map-reduce 可以在分片集合 sharded collection上运行。 Map-reduce 操作也可以输出到分片集合。有关详细信息，请参阅聚合管道和分片集合和Map-Reduce 和 Sharded Collections。 注意 从 MongoDB 2.4 开始，在 map-reduce 操作中无法访问某些mongoshell 函数和 properties。 MongoDB 2.4 还支持多个 JavaScript 操作以在同一 time 运行 run。在 MongoDB 2.4 之前，JavaScript code 在单个线程中执行，引发了 map-reduce 的并发问题。 单用途聚合操作 MongoDB 还提供 db.collection.estimatedDocumentCount(), db.collection.count()和db.collection.distinct()。 所有这些操作都聚合来自单个集合的文档。虽然这些操作提供了对 common 聚合过程的简单访问，但它们缺乏聚合管道和 map-reduce 的灵活性和功能。 其他 Features 和行为 有关聚合管道 map-reduce 和特殊 group 功能的 feature 比较，请参阅聚合命令比较。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Aggregation/Aggregation-Pipeline.html":{"url":"docs/Aggregation/Aggregation-Pipeline.html","title":"Aggregation Pipeline","keywords":"","body":" 聚合管道 在本页面 管道 管道表达式 聚合管道行为 注意事项 聚合管道是用于数据聚合的 framework，其模型基于数据处理流水线的概念。文档进入 multi-stage 管道，将文档转换为聚合结果。 在这个例子中 db.orders.aggregate([ { $match: { status: \"A\" } }, { $group: { _id: \"$cust_id\", total: { $sum: \"$amount\" } } } ]) 第一阶段：该$match阶段按status字段过滤文档，并将status等于的文档传递到下一阶段\"A\"。 第二阶段：该$group阶段按cust_id字段将文档分组，以计算每个唯一值的总和cust_id。 管道 MongoDB 聚合管道由阶段组成。每个阶段在文档通过管道时转换文档。管道阶段不需要为每个输入文档生成一个输出文档; 如：某些阶段可能会生成新文档或过滤掉文档。管道阶段可以在管道中多次出现。 MongoDB 在mongo shell 中提供db.collection.aggregate()方法，在聚合管道中提供聚合命令。有关可用阶段，请参阅聚合管道阶段。 对于聚合管道的 example 用法，请考虑使用用户首选项数据进行聚合和使用 Zip Code 数据集进行聚合。 从MongoDB 4.2开始，您可以使用聚合管道在以下位置进行更新： 命令 Mongoshall方法 findAndModify db.collection.findOneAndUpdate（）db.collection.findAndModify（） pdate db.collection.updateOne（）db.collection.updateMany（）db.collection.update（）Bulk.find.update（）Bulk.find.updateOne（）Bulk.find.upsert（） 也可以看看 聚合管道更新 管道表达式 某些管道阶段将管道表达式作为操作数。管道表达式指定要应用于输入文档的转换。表达式具有文档结构，可以包含其他表达式。 管道表达式只能对管道中的当前文档进行操作，并且不能引用其他文档中的数据：表达式操作提供文档的 in-memory 转换。 通常，表达式是 stateless，只有在聚合 process 看到一个 exception：累加器表达式时才会计算。 在文档通过管道进行时，在$group阶段中使用的累加器将保持其 state(如： 总计，最大值，最小值和相关数据)。 更改 version 3.2：$project阶段有一些累加器可用;但是，在$project阶段使用时，累加器不会跨文档维护 state。 有关表达式的更多信息，请参阅表达式。 聚合管道行为 在 MongoDB 中，管道命令在单个集合上运行，从逻辑上将整个集合传递到聚合管道。要尽可能优化操作，请使用以下策略以避免扫描整个集合。 管道运算符和索引 MongoDB的query planner分析聚合管道，以确定是否 可以使用索引来改善管道性能。例如，以下管道阶段可以利用索引： 注意 以下管道阶段并不代表可以使用索引的所有阶段的完整列表。 $match 如果$match阶段出现在管道的开始，阶段可以使用索引来过滤文档。 $sort 该$sort阶段可以使用索引，只要它不是由前面$project，$unwind或 $group阶段。 $group 该$group阶段有时可以使用的索引来查找每一个组中的第一文档，如果所有的满足下列条件： 该$group阶段之前是一个$sort 阶段，该阶段对字段进行分组 在分组的字段上有一个索引，它与排序顺序匹配 该$group阶段中使用的唯一累加器是 $first $geoNear 该$geoNear管道运算符需要一个地理空间索引的优势。使用时$geoNear， $geoNear管道操作必须出现在聚合管道的第一阶段。 在版本3.2中进行了更改：从MongoDB 3.2开始，索引可以覆盖聚合管道。在MongoDB 2.6和3.0中，索引无法覆盖聚合管道，因为即使管道使用索引，聚合仍需要访问实际文档。 早期过滤 如果聚合操作仅需要集合中的数据子集，请使用$match，$limit和$skip阶段来限制在管道开头输入的文档。当放置在管道的开头时，$match操作使用合适的索引来仅扫描集合中的匹配文档。 在管道的开头放置$match管道阶段后跟$sort阶段在逻辑上等同于具有排序的单个查询并且可以使用索引。如果可能，将$match operators 放在管道的开头。 附加功能 止于4.0版本 聚合管道具有内部优化阶段，为 operators 的某些序列提供改进的 performance。有关详细信息，请参阅聚合管道优化。 聚合管道支持对分片集合的操作。见聚合管道和分片集合。 聚合管道优化 聚合管道限制 聚合管道和分片集合 使用 Zip Code 数据集进行聚合 Example with User Preference Data 注意事项 始于4.0版本 分片集合 聚合管道支持对分片集合的操作。请参阅聚合管道和分片集合。 聚合管道与Map-Reduce的比较 聚合管道比Map-Reduce提供更好的性能和更一致的接口。可以使用聚合管道运算符（例如$ group，$ merge等）来重写各种map-reduce操作。对于需要自定义功能的map-reduce操作，MongoDB从版本4.4开始提供$ accumulator和$ function聚合运算符。这些运算符使用户能够在JavaScript中定义自定义聚合表达式。有关详细信息，请参见Map-Reduce示例。 限制 聚合管道对值类型和结果大小有一些限制。有关聚合管道的限制和限制的详细信息，请参见聚合管道限制。管道优化聚合管道具有内部优化阶段，可为某些操作员序列提供改进的性能。有关详细信息，请参阅聚合管道优化。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Aggregation/Aggregation-Pipeline/Aggregation-Pipeline-Optimization.html":{"url":"docs/Aggregation/Aggregation-Pipeline/Aggregation-Pipeline-Optimization.html","title":"Aggregation Pipeline Optimization","keywords":"","body":" 聚合管道优化 在本页面 投影优化 管道序列优化 管道聚结优化 例子 聚合管道操作具有优化阶段，该阶段试图重塑管道以改善性能。 要查看优化程序如何转换特定聚合管道，请在db.collection.aggregate()方法中包含说明选项。 优化可能会在不同版本之间发生变化。 投影优化 聚合管道可以确定它是否仅需要文档中的字段的子集来获得结果。如果是这样，管道将只使用那些必需的字段，减少通过管道的数据量。 管道序列优化 ($project or $unset or $addFields or $set) + $match Sequence Optimization 对于包含投影阶段($project或$addFields)后跟$match阶段的聚合管道，MongoDB 将$match阶段中不需要在投影阶段计算的值的任何过滤器移动到投影前的新$match阶段。 如果聚合管道包含多个投影 and/or $match阶段，MongoDB 会为每个$match阶段执行此优化，在滤镜不依赖的所有投影阶段之前移动每个$match滤镜。 考虑以下阶段的管道： { $addFields: { maxTime: { $max: \"$times\" }, minTime: { $min: \"$times\" } } }, { $project: { _id: 1, name: 1, times: 1, maxTime: 1, minTime: 1, avgTime: { $avg: [\"$maxTime\", \"$minTime\"] } } }, { $match: { name: \"Joe Schmoe\", maxTime: { $lt: 20 }, minTime: { $gt: 5 }, avgTime: { $gt: 7 } } } 优化器将$match阶段分成四个单独的过滤器，一个用于$match查询文档中的每个 key。然后优化器在尽可能多的投影阶段之前移动每个滤波器，根据需要创建新的$match阶段。鉴于此示例，优化程序生成以下优化管道： { $match: { name: \"Joe Schmoe\" } }, { $addFields: { maxTime: { $max: \"$times\" }, minTime: { $min: \"$times\" } } }, { $match: { maxTime: { $lt: 20 }, minTime: { $gt: 5 } } }, { $project: { _id: 1, name: 1, times: 1, maxTime: 1, minTime: 1, avgTime: { $avg: [\"$maxTime\", \"$minTime\"] } } }, { $match: { avgTime: { $gt: 7 } } } $match过滤器{ avgTime: { $gt: 7 } }取决于$project阶段来计算avgTime字段。 $project阶段是此管道中的最后一个投影阶段，因此无法移动avgTime上的$match过滤器。 $match过滤器{ avgTime: { $gt: 7 } }取决于$project阶段来计算avgTime字段。 $project阶段是此管道中的最后一个投影阶段，因此无法移动avgTime上的$match过滤器。 maxTime和minTime字段在$addFields阶段计算，但不依赖于$project阶段。优化器为这些字段上的过滤器创建了一个新的$match阶段，并将其放在$project阶段之前。 $match过滤器{ name: \"Joe Schmoe\" }不使用在$project或$addFields阶段计算的任何值，因此它在两个投影阶段之前被移动到新的$match阶段。 注意 优化后，过滤器{ name: \"Joe Schmoe\" }位于管道开头的$match阶段。这具有额外的好处，即允许聚合在最初查询集合时在name字段上使用索引。有关更多信息，请参见管道操作员和索引。 $sort $match 序列优化 如果序列中带有$sort后跟$match，则$match会在$sort之前移动，以最小化要排序的 objects 的数量。对于 example，如果管道包含以下阶段： { $sort: { age : -1 } }, { $match: { status: 'A' } } 在优化阶段，优化程序将序列转换为以下内容： { $match: { status: 'A' } }, { $sort: { age : -1 } } $redact $match 序列优化 如果可能，当管道的$redact阶段紧跟着$match阶段时，聚合有时可以在$redact阶段之前添加$match阶段的一部分。如果添加的$match阶段位于管道的开头，则聚合可以使用索引以及查询集合来限制进入管道的文档数。有关更多信息，请参见管道操作员和索引。 对于 example，如果管道包含以下阶段： { $redact: { $cond: { if: { $eq: [ \"$level\", 5 ] }, then: \"$$PRUNE\", else: \"$$DESCEND\" } } }, { $match: { year: 2014, category: { $ne: \"Z\" } } } 优化器可以在$redact阶段之前添加相同的$match阶段： { $match: { year: 2014 } }, { $redact: { $cond: { if: { $eq: [ \"$level\", 5 ] }, then: \"$$PRUNE\", else: \"$$DESCEND\" } } }, { $match: { year: 2014, category: { $ne: \"Z\" } } } $project/ $unset+ $skip序列优化 3.2版中的新功能。 当您在$project或$unset之后 有一个序列时$skip，将$skip 移至之前$project。例如，如果管道包括以下阶段： { $sort: { age : -1 } }, { $project: { status: 1, name: 1 } }, { $skip: 5 } 在优化阶段，优化器将序列转换为以下内容： { $sort: { age : -1 } }, { $skip: 5 }, { $project: { status: 1, name: 1 } } 管道聚合优化 如果可能，优化阶段将流水线阶段合并到其前身。通常，合并发生在任何序列重新排序优化之后。 $sort+ $limit合并 在版本4.0中更改。 当一个$sort先于$limit，优化器可以聚结$limit到$sort，如果没有中间阶段的修改文件（例如，使用数$unwind，$group）。如果有管道阶段会更改和阶段之间的文档数，则MongoDB将不会合并$limit到 。$sort$sort$limit 例如，如果管道包括以下阶段： { $sort : { age : -1 } }, { $project : { age : 1, status : 1, name : 1 } }, { $limit: 5 } 在优化阶段，优化器将序列合并为以下内容： { \"$sort\" : { \"sortKey\" : { \"age\" : -1 }, \"limit\" : NumberLong(5) } }, { \"$project\" : { \"age\" : 1, \"status\" : 1, \"name\" : 1 } } 这样，排序操作就可以仅在执行过程中保持最高n结果，这n是指定的限制，MongoDB仅需要将n项目存储在内存中 [1]。有关更多信息，请参见$ sort运算符和内存。 用$skip进行序列优化 如果$skip在$sort 和$limit阶段之间有一个阶段，MongoDB将合并 $limit到该$sort阶段并增加该 $limit值$skip。有关示例，请参见 $ sort + $ skip + $ limit序列。 [1]当优化仍将适用 allowDiskUse是true与n项目超过 聚集内存限制。 $limit+ $limit合并 当$limit紧接着另一个时 $limit，两个阶段可以合并为一个阶段 $limit，其中限制量为两个初始限制量中的较小者。例如，管道包含以下序列： { $limit: 100 }, { $limit: 10 } 然后，第二$limit级可以聚结到第一 $limit阶段，并导致在单个$limit 阶段，即限制量10是两个初始极限的最小100和10。 { $limit: 10 } $skip+ $skip合并 当$skip紧跟另一个$skip，这两个阶段可合并成一个单一的$skip，其中跳过量为总和的两个初始跳过量。例如，管道包含以下序列： { $skip: 5 }, { $skip: 2 } 然后，第二$skip阶段可以合并到第一 $skip阶段，并导致单个$skip 阶段，其中跳过量7是两个初始限制5和的总和2。 { $skip: 7 } $match+ $match合并 当一个$match紧随另一个紧随其后时 $match，这两个阶段可以合并为一个单独 $match的条件 $and。例如，管道包含以下序列： { $match: { year: 2014 } }, { $match: { status: \"A\" } } 然后，第二$match阶段可以合并到第一 $match阶段，从而形成一个$match 阶段 { $match: { $and: [ { \"year\" : 2014 }, { \"status\" : \"A\" } ] } } $lookup + $unwind 合并 3.2版中的新功能。 当a $unwind立即紧随其后 $lookup，并且在 领域$unwind运行时，优化程序可以将其合并 到阶段中。这样可以避免创建较大的中间文档。as$lookup$unwind$lookup 例如，管道包含以下序列： { $lookup: { from: \"otherCollection\", as: \"resultingArray\", localField: \"x\", foreignField: \"y\" } }, { $unwind: \"$resultingArray\"} 优化器可以将$unwind阶段合并为 $lookup阶段。如果使用explain 选项运行聚合，则explain输出将显示合并阶段： { $lookup: { from: \"otherCollection\", as: \"resultingArray\", localField: \"x\", foreignField: \"y\", unwinding: { preserveNullAndEmptyArrays: false } } } 例子 $limit $skip $limit $skip 序列 止于Mongodb4.0 管道包含一系列交替的$limit和$skip阶段： { $limit: 100 }, { $skip: 5 }, { $limit: 10 }, { $skip: 2 } $skip $limit 序列优化反转{ $skip: 5 }和{ $limit: 10 }阶段的位置并增加限制量： { $limit: 100 }, { $limit: 15}, { $skip: 5 }, { $skip: 2 } 然后，优化器将两个$limit阶段合并为一个$limit阶段，将两个$skip阶段合并为一个$skip阶段。结果序列如下： { $limit: 15 }, { $skip: 7 } 有关详细信息，请参阅$limit $limit 合并和$skip $skip 合并。 也可以看看 db.collection.aggregate()中的说明选项 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Aggregation/Aggregation-Pipeline/Aggregation-Pipeline-Limits.html":{"url":"docs/Aggregation/Aggregation-Pipeline/Aggregation-Pipeline-Limits.html","title":"Aggregation Pipeline Limits","keywords":"","body":" 聚合管道限制 在本页面 结果大小限制 Memory 限制 使用管道命令的聚合操作具有以下限制。 结果大小限制 更改 version 3.6：MongoDB 3.6 删除管道命令的选项，以将其结果作为单个文档返回。 管道命令可以_retret 一个游标或 store 存储集合中的结果。返回游标或将结果存储在集合中时，结果集中的每个文档都受BSON 文件大小限制，目前为 16 兆字节;如果任何单个文档超过BSON 文件大小限制，该命令将产生错误。该限制仅适用于退回的文件;在管道处理期间，文档可能超过此大小。 db.collection.aggregate()方法默认返回游标。聚合命令可以返回游标或将结果存储在集合中。 当返回游标或将结果存储在集合中时，结果集中的每个文档都受BSON文档大小限制（当前为16兆字节）； 如果任何单个文档超出BSON文档大小限制，该命令将产生错误。 该限制仅适用于退回的文件； 在管道处理过程中，文档可能会超出此大小。 db.collection.aggregate（）方法返回一个游标。 Memory 限制 更改了 version 2.6. 管道阶段的 RAM 限制为 100 兆字节。如果某个阶段超出此限制，MongoDB 将产生错误。要允许处理大型数据集，请使用allowDiskUse选项启用聚合管道阶段以将数据写入临时 files。 聚合管道阶段的RAM限制为100 MiB（100 1024 1024字节）。 如果阶段超出此限制，则MongoDB将产生错误。 为了处理大型数据集，可以在aggregate（）方法中设置allowDiskUse选项。 allowDiskUse选项使大多数聚合管道操作可以将数据写入临时文件。 以下聚合操作是allowDiskUse选项的例外： 这些操作必须在内存限制限制内： 更改了 version 3.4. $ graphLookup阶段 $graphLookup阶段必须保持在 100 兆字节的 memory 限制内。如果为aggregate()操作指定了allowDiskUse: true，$graphLookup阶段将忽略该选项。如果aggregate()操作中还有其他阶段，则allowDiskUse: true选项对这些其他阶段有效。 $ add阶段中使用的累加器表达式（从版本3.6.17开始） $ group阶段中使用的$ push累加器表达式（从版本3.6.17开始） 如果管道包含观察到allowDiskUse的其他阶段：true 在aggregate（）操作中，allowDiskUse：true选项在其他阶段有效。 也可以看看 $sort 和 Memory 限制和$group Operator 和 Memory。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Aggregation/Aggregation-Pipeline/Aggregation-Pipeline-and-Sharded-Collections.html":{"url":"docs/Aggregation/Aggregation-Pipeline/Aggregation-Pipeline-and-Sharded-Collections.html","title":"Aggregation Pipeline and Sharded Collections","keywords":"","body":" 聚合管道和分片集合 在本页面 行为 优化 聚合管道支持对分片集合的操作。本节介绍特定于聚合管道和分片集合的行为。 行为 更改了 version 3.2. 如果管道以 shard key 上的精确$match开头，则整个管道仅在匹配的分片上运行。以前，管道将被拆分，合并它的工作必须在主分片上完成。 对于必须在多个分片上运行的聚合操作，如果操作不需要在数据库的主分片上运行 running，则这些操作将会将结果路由到随机分片以合并结果，以避免重载该数据库的主分片。 $out阶段和$lookup阶段需要在数据库的主分片上运行 running。 优化 在将聚合管道分成两部分时，管道被拆分以确保分片在考虑优化的情况下执行尽可能多的阶段。 要查看管道是如何拆分的，请在db.collection.aggregate()方法中包含说明选项。 优化可能会在不同版本之间发生变化。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Aggregation/Aggregation-Pipeline/Example-with-ZIP-Code-Data.html":{"url":"docs/Aggregation/Aggregation-Pipeline/Example-with-ZIP-Code-Data.html","title":"Example with ZIP Code Data","keywords":"","body":" 使用 Zip Code 数据集进行聚合 在本页面 数据模型 Data Model aggregate()方法 返回人口超过 1000 万的国家 按 State 返回平均城市人口 按 State 返回最大和最小城市 本文档中的示例使用zipcodes集合。该系列可在以下网址获得：media.mongodb.org/zips.json。使用mongoimport将此数据集加载到mongod实例中。 数据模型 zipcodes集合中的每个文档都具有以下形式： { \"_id\": \"10280\", \"city\": \"NEW YORK\", \"state\": \"NY\", \"pop\": 5574, \"loc\": [ -74.016323, 40.710537 ] } _id字段将 zip code 保存为 string。 city字段包含 city name。一个城市可以有多个与之关联的 zip code，因为城市的不同部分可以各自具有不同的 zip code。 state字段包含两个字母 state 缩写。 pop字段包含人口。 loc字段将位置保存为纬度经度对。 aggregate()方法 以下所有示例都使用mongo shell 中的aggregate()帮助程序。 aggregate()方法使用聚合管道将文档处理为聚合结果。 聚合管道由多个阶段组成，每个阶段在文档沿着管道传递时都会对其进行处理。文档按顺序通过各个阶段。 mongo shell 中的aggregate()方法在聚合数据库命令提供了一个包装器。有关用于数据聚合操作的更惯用的界面，请参阅驱动的文档。 返回人口超过 1000 万的国家 以下聚合操作将返回总人口超过 1000 万的所有州： db.zipcodes.aggregate( [ { $group: { _id: “$state“, totalPop: { $sum: “$pop“ } } }, { $match: { totalPop: { $gte: 10*1000*1000 } } } ] ) 在此 example 中，聚合管道包含$group阶段，后跟$match阶段： 阶段按state字段对zipcode集合的文档进行分组，为每个 state 计算totalPop字段，并为每个唯一的 state 输出文档。 新的 per-state 文档有两个字段：_id字段和totalPop字段。 _id字段包含state的 value即： group by field。 totalPop字段是一个计算字段，包含每个 state 的总人口。要计算 value，$group使用$sum operator 为每个 state 添加填充字段(pop)。 在$group阶段之后，管道中的文档类似于以下内容： { “_id“ : “AK“, “totalPop“ : 550043 } $match阶段过滤这些分组文档，仅输出totalPop value 大于或等于 1000 万的文档。 $match阶段不会更改匹配的文档，但会不加修改地输出匹配的文档。 此聚合操作的等效SQL是： SELECT state, SUM(pop) AS totalPop FROM zipcodes GROUP BY state HAVING totalPop >= (10*1000*1000) 也可以看看 $group，$match，$sum 按 State 返回平均城市人口 以下聚合操作返回每个 state 中城市的平均人口数： db.zipcodes.aggregate( [ { $group: { _id: { state: “$state“, city: “$city“ }, pop: { $sum: “$pop“ } } }, { $group: { _id: “$_id.state“, avgCityPop: { $avg: “$pop“ } } } ] ) 在这个 example 中，聚合管道包含$group阶段，后跟另一个$group阶段： 第一个阶段通过city和state的组合对文档进行分组，使用$sum表达式计算每个组合的总体，并为每个city和state组合输出一个文档。 [1] 在管道中的这个阶段之后，文档类似于以下内容： { “_id“ : { “state“ : “CO“, “city“ : “EDGEWATER“ }, “pop“ : 13154 } 第二个$group阶段通过_id.state字段(i.e._id文档中的state字段)对管道中的文档进行分组，使用$avg表达式计算每个 state 的平均城市人口(avgCityPop)，并为每个 state 输出一个文档。 此聚合操作产生的文档类似于以下内容： { “_id“ : “MN“, “avgCityPop“ : 5335 } 也可以看看 $group，$sum，$avg 按 State 返回最大和最小城市 以下聚合操作按每个 state 的填充返回最小和最大的城市： db.zipcodes.aggregate( [ { $group:{ _id: { state: “$state“, city: “$city“ }, pop: { $sum: “$pop“ } } }, { $sort: { pop: 1 } }, { $group:{ _id : “$_id.state“, biggestCity: { $last: “$_id.city“ }, biggestPop: { $last: “$pop“ }, smallestCity: { $first: “$_id.city“ }, smallestPop: { $first: “$pop“ } } }, // the following $project is optional, and // modifies the output format. { $project:{ _id: 0, state: “$_id“, biggestCity: { name: “$biggestCity“, pop: “$biggestPop“ }, smallestCity: { name: “$smallestCity“, pop: “$smallestPop“ } } } ] ) 在此 example 中，聚合管道包含$group阶段，$sort阶段，另一个$group阶段和$project阶段： 第一个$group阶段通过city和state的组合对文档进行分组，计算每个组合的pop值的和，并为每个city和state组合输出一个文档。 在管道的这个阶段，文档类似于以下内容： { “_id“ : { “state“ : “CO“, “city“ : “EDGEWATER“ }, “pop“ : 13154 } $sort阶段通过pop field value 对管道中的文档进行排序，从最小到最大; i.e。通过增加 order。此操作不会更改文档。 下一个$group阶段按_id.state字段(即：_id文档中的state字段)对 now-sorted 文档进行分组，并为每个 state 输出一个文档。 该阶段还为每个 state 计算以下四个字段。使用$last表达式，$group operator 创建biggestCity和biggestPop字段，用于存储人口和人口最多的城市。使用$first表达式，$group operator 创建smallestCity和smallestPop字段，用于存储人口和人口最少的城市。 在管道的这个阶段，文件类似于以下内容： { “_id“ : “WA“, “biggestCity“ : “SEATTLE“, “biggestPop“ : 520096, “smallestCity“ : “BENGE“, “smallestPop“ : 2 } 最后的$project阶段将_id字段重命名为state，并将biggestCity，biggestPop，smallestCity和smallestPop移动到biggestCity和smallestCity嵌入文档中。 此聚合操作的输出文档类似于以下内容： { “state“ : “RI“, “biggestCity“ : { “name“ : “CRANSTON“, “pop“ : 176404 }, “smallestCity“ : { “name“ : “CLAYVILLE“, “pop“ : 45 } } [1] 一个城市可以有多个与之关联的 zip code，因为城市的不同部分可以各自具有不同的 zip code。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Aggregation/Aggregation-Pipeline/Example-with-User-Preference-Data.html":{"url":"docs/Aggregation/Aggregation-Pipeline/Example-with-User-Preference-Data.html","title":"Example with User Preference Data","keywords":"","body":" 使用用户首选项数据进行聚合 在本页面 数据模型 规范化和排序文档 返回按月加入订单的用户名 返回每月的联接总数 Return 五个 Common“喜欢” 数据模型 考虑一个假设的体育俱乐部，其数据库包含一个users集合，用于跟踪用户的加入日期，运动偏好，并将这些数据存储在类似于以下内容的文档中： { _id : “jane“, joined : ISODate(“2011-03-02“), likes : [“golf“, “racquetball“] } { _id : “joe“, joined : ISODate(“2012-07-02“), likes : [“tennis“, “golf“, “swimming“] } 规范化和排序文档 以下操作以大写和字母 order 返回用户名。聚合包括users集合中所有文档的用户名。您可以这样做以规范化用户名以进行处理。 db.users.aggregate([ { $project : { name:{$toUpper:“$_id“} , _id:0 } }, { $sort : { name : 1 } } ]) users集合中的所有文档都通过管道传递，该管道包含以下操作： $project 操作： 创建一个名为name的新字段。 使用$toUpper operator 将_id的 value 转换为大写。然后$project创建一个名为name的新字段来保存此 value。 抑制id字段。除非明确禁止，否则$project将默认通过_id字段。 operator 按name字段对结果进行排序。 聚合的结果类似于以下内容： { \"name\" : \"JANE\" }, { \"name\" : \"JILL\" }, { \"name\" : \"JOE\" } 返回按月加入订单的用户名 以下聚合操作返回按其加入的月份排序的用户名。这种聚合可以帮助生成会员续订通知。 db.users.aggregate([ { $project : { month_joined : { $month : “$joined“ }, name : “$_id“, _id : 0 } }, { $sort : { month_joined : 1 } } ]) 管道通过以下操作传递users集合中的所有文档： $project operator： 创建两个新字段：month_joined和name。 从结果中抑制id。除非明确禁止，否则aggregate()方法包含_id。 $month operator 将joined字段的值转换为月份的 integer 表示。然后$project operator 将这些值分配给month_joined字段。 $sort operator 按month_joined字段对结果进行排序。 该操作返回类似于以下内容的结果： { “month_joined“ : 1, “name“ : “ruth“ }, { “month_joined“ : 1, “name“ : “harold“ }, { “month_joined“ : 1, “name“ : “kate“ }, { “month_joined“ : 2, “name“ : “jill“ } 返回每月的联接总数 以下操作显示了一年中每个月加入的人数。您可以将此汇总数据用于招聘和营销策略。 db.users.aggregate([ { $project : { month_joined : { $month : “$joined“ } } } , { $group : { _id : {month_joined:“$month_joined“} , number : { $sum : 1 } } }, { $sort : { “_id.month_joined“ : 1 } } ]) 管道通过以下操作传递users集合中的所有文档： $project operator 创建一个名为month_joined的新字段。 $month operator 将joined字段的值转换为月份的 integer 表示。然后$project operator 将值分配给month_joined字段。 $group operator 收集具有给定month_joined value 的所有文档，并计算该 value 的文档数量。具体来说，对于每个唯一 value，$group创建一个包含两个字段的新“per-month”文档： _id，包含带有month_joined字段及其 value 的嵌套文档。 number，这是一个生成的字段。对于包含给定month_joined value 的每个文档，$sum operator 将此字段递增 1。 $sort operator 根据month_joined字段的内容对$group创建的文档进行排序。 此聚合操作的结果类似于以下内容： { “_id“ : { “month_joined“ : 1 }, “number“ : 3 }, { “_id“ : { “month_joined“ : 2 }, “number“ : 9 }, { “_id“ : { “month_joined“ : 3 }, “number“ : 5 } Return 五个 Common“喜欢” 以下聚合收集数据集中前五个最“喜欢”的活动。这种分析有助于规划和未来发展。 db.users.aggregate([ { $unwind : “$likes“ }, { $group : { _id : “$likes“ , number : { $sum : 1 } } }, { $sort : { number : -1 } }, { $limit : 5 } ]) 管道从users集合中的所有文档开始，并通过以下操作传递这些文档： $unwind operator 分隔likes array 中的每个 value，并为 array 中的每个元素创建源文档的新 version。 例 给出来自用户集合的以下文档： { _id : \"jane\", joined : ISODate(\"2011-03-02\"), likes : [\"golf\", \"racquetball\"] } 该$unwind运营商将创建下列文件： { _id : “jane“, joined : ISODate(“2011-03-02“), likes : “golf“ } { _id : “jane“, joined : ISODate(“2011-03-02“), likes : “racquetball“ } $group operator 收集likes字段具有相同 value 的所有文档，并计算每个分组。有了这些信息，$group创建了一个包含两个字段的新文档： _id，其中包含likes value。 number，这是一个生成的字段。对于包含给定likes value 的每个文档，$sum operator 将此字段递增 1。 $sort operator 按字段在 reverse order 中对这些文档进行排序。 $limit operator 仅包含前 5 个结果文档。 聚合的结果类似于以下内容： { “_id“ : “golf“, “number“ : 33 }, { “_id“ : “racquetball“, “number“ : 31 }, { “_id“ : “swimming“, “number“ : 24 }, { “_id“ : “handball“, “number“ : 19 }, { “_id“ : “tennis“, “number“ : 18 } Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Aggregation/Map-Reduce.html":{"url":"docs/Aggregation/Map-Reduce.html","title":"Map-Reduce","keywords":"","body":" Map-Reduce 在本页面 Map-Reduce JavaScript 函数 Map-Reduce 行为 Map-reduce 是一种数据处理范例，用于将大量数据压缩为有用的汇总结果。对于 map-reduce 操作，MongoDB 提供MapReduce数据库命令。 注意 从4.2版开始，MongoDB弃用： 地图-reduce选项来创建一个新的分片集合以及使用的分片供选择的map-reduce。要输出到分片集合，请首先创建分片集合。MongoDB 4.2还不建议替换现有分片集合。 nonAtomic：false选项的显式规范。 考虑以下 map-reduce 操作： 在此 map-reduce 操作中，MongoDB 将 map 阶段应用于每个输入文档(即：集合中与查询条件匹配的文档)。 map function 会发出 key-value 对。对于具有多个值的密钥，MongoDB 应用 reduce 阶段，该阶段收集并压缩聚合数据。 MongoDB 然后 store 存储集合中的结果。可选地，reduce function 的输出可以通过 finalize function 以进一步压缩或处理聚合的结果。 MongoDB 中的所有 map-reduce 函数都是process 中的 JavaScript 和 run。 Map-reduce 操作将单个采集的文档作为输入，并且可以在开始 map 阶段之前执行任意排序和限制。 MapReduce可以操作的结果作为文档返回，或者可以将结果写入集合。输入和输出集合可以分片。 注意 对于大多数聚合操作，聚合管道提供更好的 performance 和更一致的接口。但是，map-reduce 操作提供了一些在聚合管道中目前不可用的灵活性。 Map-Reduce JavaScript 函数 在 MongoDB 中，map-reduce 操作使用自定义 JavaScript 函数将值映射或关联到 key。如果 key 有多个值映射到它，则操作会将 key 的值减少为单个 object。 自定义 JavaScript 函数的使用为 map-reduce 操作提供了灵活性。例如，在处理文档时，map function 可以创建多个 key 和 value 映射或不创建映射。 Map-reduce 操作还可以使用自定义 JavaScript function 对 map 末尾的结果进行最终修改并减少操作，例如执行其他计算。 在4.2.1版本开始，MongoDB的不赞成使用范围（即使用JavaScript的BSON类型15）的 map，reduce和finalize功能。要确定变量的范围，请改用scope参数。 Map-Reduce 行为 在 MongoDB 中，map-reduce 操作可以将结果写入集合或 return 结果内联。如果将 map-reduce 输出写入集合，则可以对同一输入集合执行后续 map-reduce 操作，这些集合将替换，合并或减少新结果与先前结果合并。有关详细信息和示例，请参阅MapReduce和执行增量 Map-Reduce。 在内联返回 map-reduce 操作的结果时，结果文档必须在BSON 文件大小限制范围内，当前为 16 兆字节。有关 map-reduce 操作的限制和限制的其他信息，请参阅MapReduce reference 页面。 分片集合 MongoDB 支持分片集合上的 map-reduce 操作。 但是，从版本4.2开始，MongoDB弃用map-reduce选项以创建新的分片集合，并将该 sharded选项用于map-reduce。要输出到分片集合，请首先创建分片集合。MongoDB 4.2还不建议替换现有分片集合。 见Map-Reduce 和 Sharded Collections。 视图 视图不支持 map-reduce 操作。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Aggregation/Map-Reduce/Map-Reduce-and-Sharded-Collections.html":{"url":"docs/Aggregation/Map-Reduce/Map-Reduce-and-Sharded-Collections.html","title":"Map-Reduce and Sharded Collections","keywords":"","body":" Map-Reduce 和 Sharded Collections 在本页面 Sharded Collection 作为输入 Sharded Collection as Output Map-reduce 支持对分片集合的操作，既可以作为输入也可以作为输出。本节介绍MapReduce特定于分片集合的行为。 Sharded Collection 作为输入 当使用分片集合作为 map-reduce 操作的输入时，mongos将自动将 map-reduce job 分派给 parallel 中的每个分片。不需要特殊选项。 mongos将等待所有分片上的作业完成。 Sharded Collection as Output 如果MapReduce的out字段具有sharded value，则 MongoDB 使用_id字段将输出集合分片为 shard key。 要输出到分片集合： 如果输出集合不存在，请首先创建分片集合 从版本4.2开始，MongoDB弃用map-reduce选项以 创建新的分片集合，并将该sharded 选项用于map-reduce。因此，要输出到分片集合，请首先创建分片集合。 如果您没有首先创建分片集合，则MongoDB会在_id字段上创建和分片集合。但是，建议您首先创建分片集合。 从4.2版开始，MongoDB不赞成替换现有的分片集合。 从版本4.0开始，如果输出集合已存在但未分片，则map-reduce失败。 对于新的或空的分片集合，MongoDB使用map-reduce操作的第一阶段的结果来创建在分片之间分布的初始块。 mongos并行地将映射减少后处理作业分派给拥有块的每个分片。在后处理期间，每个分片将从其他分片中提取其自身块的结果，运行最终的reduce / finalize，然后本地写入输出集合。 注意 在以后的 map-reduce 作业中，MongoDB 根据需要拆分块。 在 post-processing 期间会自动阻止输出集合的块平衡，以避免并发问题。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Aggregation/Map-Reduce/Map-Reduce-Concurrency.html":{"url":"docs/Aggregation/Map-Reduce/Map-Reduce-Concurrency.html","title":"Map-Reduce Concurrency","keywords":"","body":" Map-Reduce 并发 map-reduce 操作由许多任务组成，包括从输入集合中读取，执行map function，执行reduce function，在处理期间写入临时集合以及写入输出集合。 在操作期间，map-reduce 采用以下锁定： 读取阶段采用读锁定。它产生每 100 个文件。 insert 进入临时集合会为单次写入执行写锁定。 如果输出集合不存在，则输出集合的创建将采用写入锁定。 如果输出集合存在，则输出操作(即：merge，replace，reduce)将执行写入锁定。此写锁定是 global，并阻止mongod实例上的所有操作。 注意 后处理期间的最终写锁定使结果自动显示。然而，输出操作merge和reduce可能需要时间来处理。对于merge和reduce，该 nonAtomic标志可用，从而释放写入每个输出文档之间的锁定。从MongoDB 4.2开始，不推荐使用显式设置。有关 更多信息，请参见参考。nonAtomic: falsedb.collection.mapReduce() Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Aggregation/Map-Reduce/Map-Reduce-Examples.html":{"url":"docs/Aggregation/Map-Reduce/Map-Reduce-Examples.html","title":"Map-Reduce Examples","keywords":"","body":" Map-Reduce 例子 在本页面 返回每位客户的总价格 用每个项目的平均数量计算订单和总数量 在mongo shell 中，db.collection.mapReduce()方法是MapReduce命令周围的 wrapper。以下示例使用db.collection.mapReduce()方法： 聚合管道作为替代 聚合管道 比map-reduce提供更好的性能和更一致的接口。 各种map-reduce表达式可以使用被重写聚合管道运算符，诸如$group， $merge等 下面的示例包括聚合管道备选方案。 orders使用以下文档创建样本集合： db.orders.insertMany([ { _id: 1, cust_id: \"Ant O. Knee\", ord_date: new Date(\"2020-03-01\"), price: 25, items: [ { sku: \"oranges\", qty: 5, price: 2.5 }, { sku: \"apples\", qty: 5, price: 2.5 } ], status: \"A\" }, { _id: 2, cust_id: \"Ant O. Knee\", ord_date: new Date(\"2020-03-08\"), price: 70, items: [ { sku: \"oranges\", qty: 8, price: 2.5 }, { sku: \"chocolates\", qty: 5, price: 10 } ], status: \"A\" }, { _id: 3, cust_id: \"Busby Bee\", ord_date: new Date(\"2020-03-08\"), price: 50, items: [ { sku: \"oranges\", qty: 10, price: 2.5 }, { sku: \"pears\", qty: 10, price: 2.5 } ], status: \"A\" }, { _id: 4, cust_id: \"Busby Bee\", ord_date: new Date(\"2020-03-18\"), price: 25, items: [ { sku: \"oranges\", qty: 10, price: 2.5 } ], status: \"A\" }, { _id: 5, cust_id: \"Busby Bee\", ord_date: new Date(\"2020-03-19\"), price: 50, items: [ { sku: \"chocolates\", qty: 5, price: 10 } ], status: \"A\"}, { _id: 6, cust_id: \"Cam Elot\", ord_date: new Date(\"2020-03-19\"), price: 35, items: [ { sku: \"carrots\", qty: 10, price: 1.0 }, { sku: \"apples\", qty: 10, price: 2.5 } ], status: \"A\" }, { _id: 7, cust_id: \"Cam Elot\", ord_date: new Date(\"2020-03-20\"), price: 25, items: [ { sku: \"oranges\", qty: 10, price: 2.5 } ], status: \"A\" }, { _id: 8, cust_id: \"Don Quis\", ord_date: new Date(\"2020-03-20\"), price: 75, items: [ { sku: \"chocolates\", qty: 5, price: 10 }, { sku: \"apples\", qty: 10, price: 2.5 } ], status: \"A\" }, { _id: 9, cust_id: \"Don Quis\", ord_date: new Date(\"2020-03-20\"), price: 55, items: [ { sku: \"carrots\", qty: 5, price: 1.0 }, { sku: \"apples\", qty: 10, price: 2.5 }, { sku: \"oranges\", qty: 10, price: 2.5 } ], status: \"A\" }, { _id: 10, cust_id: \"Don Quis\", ord_date: new Date(\"2020-03-23\"), price: 25, items: [ { sku: \"oranges\", qty: 10, price: 2.5 } ], status: \"A\" } ]) 返回每位客户的总价格 对orders集合执行map-reduce操作，以对进行分组cust_id，并计算price每个的 的总和cust_id： 定义map函数来处理每个输入文档： 在函数中，this指的是map-reduce操作正在处理的文档。 该函数将映射price到cust_id每个文档的，并发出cust_id和price对。 var mapFunction1 = function() { emit(this.cust_id, this.price); }; 使用两个参数keyCustId和定义相应的reduce函数 valuesPrices： valuesPrices是一个数组，其元素是price 由map功能发射并由分组值keyCustId。 该函数将valuesPrice数组简化为其元素的总和。 var reduceFunction1 = function(keyCustId, valuesPrices) { return Array.sum(valuesPrices); }; orders使用mapFunction1map函数和reduceFunction1 reduce函数对集合中的所有文档执行map-reduce 。 db.orders.mapReduce( mapFunction1, reduceFunction1, { out: \"map_reduce_example\" } ) 此操作将结果输出到名为的集合 map_reduce_example。如果map_reduce_example集合已经存在，则该操作将用此map-reduce操作的结果替换内容。 查询map_reduce_example集合以验证结果： db.map_reduce_example.find().sort( { _id: 1 } ) ​ 该操作返回以下文档： { \"_id\" : \"Ant O. Knee\", \"value\" : 95 } { \"_id\" : \"Busby Bee\", \"value\" : 125 } { \"_id\" : \"Cam Elot\", \"value\" : 60 } { \"_id\" : \"Don Quis\", \"value\" : 155 } 聚合替代 使用可用的聚合管道运算符，您可以重写map-reduce操作，而无需定义自定义函数： db.orders.aggregate([ { $group: { _id: \"$cust_id\", value: { $sum: \"$price\" } } }, { $out: \"agg_alternative_1\" } ]) $group由平台组cust_id并计算value字段（参见$sum）。该 value字段包含price每个的总计cust_id。 该阶段将以下文档输出到下一阶段： { \"_id\" : \"Don Quis\", \"value\" : 155 } { \"_id\" : \"Ant O. Knee\", \"value\" : 95 } { \"_id\" : \"Cam Elot\", \"value\" : 60 } { \"_id\" : \"Busby Bee\", \"value\" : 125 } 然后，$out将输出写入collection agg_alternative_1。或者，您可以使用 $merge代替$out。 查询agg_alternative_1集合以验证结果： db.agg_alternative_1.find().sort( { _id: 1 } ) 该操作返回以下文档： { \"_id\" : \"Ant O. Knee\", \"value\" : 95 } { \"_id\" : \"Busby Bee\", \"value\" : 125 } { \"_id\" : \"Cam Elot\", \"value\" : 60 } { \"_id\" : \"Don Quis\", \"value\" : 155 } 用每个项目的平均数量计算订单和总数量 在此示例中，您将对值大于或等于的orders所有文档在集合上执行map-reduce操作 。工序按字段分组 ，并计算每个的订单数量和总订购量。然后，该操作将为每个值计算每个订单的平均数量，并将结果合并到输出集合中。合并结果时，如果现有文档的密钥与新结果相同，则该操作将覆盖现有文档。如果不存在具有相同密钥的文档，则该操作将插入该文档。 定义map函数来处理每个输入文档： 在函数中，this指的是map-reduce操作正在处理的文档。 对于每个商品，该函数将其sku与一个新对象相关联，该对象value包含订单的countof 1和该商品qty，并发出skuand value对。 var mapFunction2 = function() { for (var idx = 0; idx 使用两个参数keySKU和定义相应的reduce函数 countObjVals： countObjVals是一个数组，其元素是映射到keySKU由map函数传递给reducer函数的分组值的对象。 该函数将countObjVals数组简化为reducedValue包含count和 qty字段的单个对象。 在中reducedVal，该count字段包含 count各个数组元素的qty字段总和，而该字段包含各个数组元素的 字段总和qty。 var reduceFunction2 = function(keySKU, countObjVals) { reducedVal = { count: 0, qty: 0 }; for (var idx = 0; idx 定义有两个参数的函数确定key和 reducedVal。该函数修改reducedVal对象以添加一个名为avg的计算字段，并返回修改后的对象： var finalizeFunction2 = function (key, reducedVal) { reducedVal.avg = reducedVal.qty/reducedVal.count; return reducedVal; }; 在执行的map-reduce操作orders使用集合mapFunction2，reduceFunction2和 finalizeFunction2功能。 db.orders.mapReduce( mapFunction2, reduceFunction2, { out: { merge: \"map_reduce_example2\" }, query: { ord_date: { $gte: new Date(\"2020-03-01\") } }, finalize: finalizeFunction2 } ); 此操作使用该query字段选择仅ord_date大于或等于的那些文档。然后将结果输出到集合 。new Date(\"2020-03-01\") map_reduce_example2 如果map_reduce_example2集合已经存在，则该操作会将现有内容与此map-reduce操作的结果合并。也就是说，如果现有文档具有与新结果相同的密钥，则该操作将覆盖现有文档。如果不存在具有相同密钥的文档，则该操作将插入该文档。 查询map_reduce_example2集合以验证结果： db.map_reduce_example2.find().sort( { _id: 1 } ) 该操作返回以下文档： { \"_id\" : \"apples\", \"value\" : { \"count\" : 3, \"qty\" : 30, \"avg\" : 10 } } { \"_id\" : \"carrots\", \"value\" : { \"count\" : 2, \"qty\" : 15, \"avg\" : 7.5 } } { \"_id\" : \"chocolates\", \"value\" : { \"count\" : 3, \"qty\" : 15, \"avg\" : 5 } } { \"_id\" : \"oranges\", \"value\" : { \"count\" : 6, \"qty\" : 58, \"avg\" : 9.666666666666666 } } { \"_id\" : \"pears\", \"value\" : { \"count\" : 1, \"qty\" : 10, \"avg\" : 10 } } 聚合替代 使用可用的聚合管道运算符，您可以重写map-reduce操作，而无需定义自定义函数： db.orders.aggregate( [ { $match: { ord_date: { $gte: new Date(\"2020-03-01\") } } }, { $unwind: \"$items\" }, { $group: { _id: \"$items.sku\", qty: { $sum: \"$items.qty\" }, orders_ids: { $addToSet: \"$_id\" } } }, { $project: { value: { count: { $size: \"$orders_ids\" }, qty: \"$qty\", avg: { $divide: [ \"$qty\", { $size: \"$orders_ids\" } ] } } } }, { $merge: { into: \"agg_alternative_3\", on: \"_id\", whenMatched: \"replace\", whenNotMatched: \"insert\" } } ] ) 该$match阶段仅选择ord_date大于或等于的那些文档。new Date(\"2020-03-01\") 该$unwinds阶段按items数组字段细分文档，以输出每个数组元素的文档。例如： { \"_id\" : 1, \"cust_id\" : \"Ant O. Knee\", \"ord_date\" : ISODate(\"2020-03-01T00:00:00Z\"), \"price\" : 25, \"items\" : { \"sku\" : \"oranges\", \"qty\" : 5, \"price\" : 2.5 }, \"status\" : \"A\" } { \"_id\" : 1, \"cust_id\" : \"Ant O. Knee\", \"ord_date\" : ISODate(\"2020-03-01T00:00:00Z\"), \"price\" : 25, \"items\" : { \"sku\" : \"apples\", \"qty\" : 5, \"price\" : 2.5 }, \"status\" : \"A\" } { \"_id\" : 2, \"cust_id\" : \"Ant O. Knee\", \"ord_date\" : ISODate(\"2020-03-08T00:00:00Z\"), \"price\" : 70, \"items\" : { \"sku\" : \"oranges\", \"qty\" : 8, \"price\" : 2.5 }, \"status\" : \"A\" } { \"_id\" : 2, \"cust_id\" : \"Ant O. Knee\", \"ord_date\" : ISODate(\"2020-03-08T00:00:00Z\"), \"price\" : 70, \"items\" : { \"sku\" : \"chocolates\", \"qty\" : 5, \"price\" : 10 }, \"status\" : \"A\" } { \"_id\" : 3, \"cust_id\" : \"Busby Bee\", \"ord_date\" : ISODate(\"2020-03-08T00:00:00Z\"), \"price\" : 50, \"items\" : { \"sku\" : \"oranges\", \"qty\" : 10, \"price\" : 2.5 }, \"status\" : \"A\" } { \"_id\" : 3, \"cust_id\" : \"Busby Bee\", \"ord_date\" : ISODate(\"2020-03-08T00:00:00Z\"), \"price\" : 50, \"items\" : { \"sku\" : \"pears\", \"qty\" : 10, \"price\" : 2.5 }, \"status\" : \"A\" } { \"_id\" : 4, \"cust_id\" : \"Busby Bee\", \"ord_date\" : ISODate(\"2020-03-18T00:00:00Z\"), \"price\" : 25, \"items\" : { \"sku\" : \"oranges\", \"qty\" : 10, \"price\" : 2.5 }, \"status\" : \"A\" } { \"_id\" : 5, \"cust_id\" : \"Busby Bee\", \"ord_date\" : ISODate(\"2020-03-19T00:00:00Z\"), \"price\" : 50, \"items\" : { \"sku\" : \"chocolates\", \"qty\" : 5, \"price\" : 10 }, \"status\" : \"A\" } ... $group由平台组items.sku，计算每个SKU： 该qty字段。该qty字段包含qty每个订单的总数items.sku（请参阅参考资料$sum）。 orders_ids列表。该orders_ids字段包含不同顺序的列表_id的对items.sku（参见 $addToSet）。 { \"_id\" : \"chocolates\", \"qty\" : 15, \"orders_ids\" : [ 2, 5, 8 ] } { \"_id\" : \"oranges\", \"qty\" : 63, \"orders_ids\" : [ 4, 7, 3, 2, 9, 1, 10 ] } { \"_id\" : \"carrots\", \"qty\" : 15, \"orders_ids\" : [ 6, 9 ] } { \"_id\" : \"apples\", \"qty\" : 35, \"orders_ids\" : [ 9, 8, 1, 6 ] } { \"_id\" : \"pears\", \"qty\" : 10, \"orders_ids\" : [ 3 ] } 该$project阶段调整输出文档的形状以反映map-reduce的输出，该输出具有两个字段_id和 value。该$project设置： value.count到的尺寸orders_ids数组。（请参阅$size） 在value.qty到qty输入文档的数量字段。 value.avg平均每笔订购的数量。（请参阅$divide和$size） { \"_id\" : \"apples\", \"value\" : { \"count\" : 4, \"qty\" : 35, \"avg\" : 8.75 } } { \"_id\" : \"pears\", \"value\" : { \"count\" : 1, \"qty\" : 10, \"avg\" : 10 } } { \"_id\" : \"chocolates\", \"value\" : { \"count\" : 3, \"qty\" : 15, \"avg\" : 5 } } { \"_id\" : \"oranges\", \"value\" : { \"count\" : 7, \"qty\" : 63, \"avg\" : 9 } } { \"_id\" : \"carrots\", \"value\" : { \"count\" : 2, \"qty\" : 15, \"avg\" : 7.5 } } 最后，$merge将输出写入collection agg_alternative_3。如果现有文档的密钥_id与新结果相同，则该操作将覆盖现有文档。如果不存在具有相同密钥的文档，则该操作将插入该文档。 查询agg_alternative_3集合以验证结果： db.agg_alternative_3.find().sort( { _id: 1 } ) 该操作返回以下文档： { \"_id\" : \"apples\", \"value\" : { \"count\" : 4, \"qty\" : 35, \"avg\" : 8.75 } } { \"_id\" : \"carrots\", \"value\" : { \"count\" : 2, \"qty\" : 15, \"avg\" : 7.5 } } { \"_id\" : \"chocolates\", \"value\" : { \"count\" : 3, \"qty\" : 15, \"avg\" : 5 } } { \"_id\" : \"oranges\", \"value\" : { \"count\" : 7, \"qty\" : 63, \"avg\" : 9 } } { \"_id\" : \"pears\", \"value\" : { \"count\" : 1, \"qty\" : 10, \"avg\" : 10 } } Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Aggregation/Map-Reduce/Perform-Incremental-Map-Reduce.html":{"url":"docs/Aggregation/Map-Reduce/Perform-Incremental-Map-Reduce.html","title":"Perform Incremental Map-Reduce","keywords":"","body":" 执行增量 Map-Reduce 在本页面 数据设置 当前集合的初始 Map-Reduce 后续增量 Map-Reduce Map-reduce 操作可以处理复杂的聚合任务。要执行 map-reduce 操作，MongoDB 提供MapReduce命令，并在mongo shell 中提供db.collection.mapReduce() wrapper 方法。 如果 map-reduce 数据集不断增长，您可能希望执行增量 map-reduce 而不是每个 time 对整个数据集执行 map-reduce 操作。 执行增量 map-reduce： 在当前集合上运行 map-reduce job 并将结果输出到单独的集合。 如果有更多数据要进行 process，run 后续 map-reduce job： query参数指定仅匹配新文档的条件。 out参数，指定将新结果合并到现有输出集合中的reduce操作。 请考虑以下 example，其中您在sessions集合上安排 map-reduce 操作，以在每天结束时运行 run。 数据设置 sessions集合包含 log 用户每天会话的文档，例如： db.sessions.save( { userid: \"a\", ts: ISODate('2011-11-03 14:17:00'), length: 95 } ); db.sessions.save( { userid: \"b\", ts: ISODate('2011-11-03 14:23:00'), length: 110 } ); db.sessions.save( { userid: \"c\", ts: ISODate('2011-11-03 15:02:00'), length: 120 } ); db.sessions.save( { userid: \"d\", ts: ISODate('2011-11-03 16:45:00'), length: 45 } ); db.sessions.save( { userid: \"a\", ts: ISODate('2011-11-04 11:05:00'), length: 105 } ); db.sessions.save( { userid: \"b\", ts: ISODate('2011-11-04 13:14:00'), length: 120 } ); db.sessions.save( { userid: \"c\", ts: ISODate('2011-11-04 17:00:00'), length: 130 } ); db.sessions.save( { userid: \"d\", ts: ISODate('2011-11-04 15:37:00'), length: 65 } ); 当前集合的初始 Map-Reduce 运行第一个 map-reduce 操作如下： 定义 map function _将userid映射到包含字段userid，total_time，count和avg_time的 object： var mapFunction = function() { var key = this.userid; var value = { userid: this.userid, total_time: this.length, count: 1, avg_time: 0 }; emit( key, value ); }; 使用两个 arguments key和values定义相应的 reduce function 以计算总 time 和计数。 key对应于userid，values是 array，其元素对应于映射到mapFunction中userid的各个 object。 var reduceFunction = function(key, values) { var reducedObject = { userid: key, total_time: 0, count:0, avg_time:0 }; values.forEach( function(value) { reducedObject.total_time += value.total_time; reducedObject.count += value.count; }); return reducedObject; }; 使用两个 arguments key和reducedValue定义 finalize function。 function 修改reducedValue文档以添加另一个字段average并返回修改后的文档。 var finalizeFunction = function (key, reducedValue) { if (reducedValue.count > 0) reducedValue.avg_time = reducedValue.total_time / reducedValue.count; return reducedValue; }; 使用mapFunction，reduceFunction和finalizeFunction函数在session集合上执行 map-reduce。将结果输出到集合session_stat。如果session_stat集合已存在，则操作将替换内容： db.sessions.mapReduce( mapFunction, reduceFunction, { out: \"session_stat\", finalize: finalizeFunction } ) 查询session_stats集合以验证结果： db.session_stats.find().sort( { _id: 1 } ) 该操作返回以下文档： { \"_id\" : \"a\", \"value\" : { \"total_time\" : 200, \"count\" : 2, \"avg_time\" : 100 } } { \"_id\" : \"b\", \"value\" : { \"total_time\" : 230, \"count\" : 2, \"avg_time\" : 115 } } { \"_id\" : \"c\", \"value\" : { \"total_time\" : 250, \"count\" : 2, \"avg_time\" : 125 } } { \"_id\" : \"d\", \"value\" : { \"total_time\" : 110, \"count\" : 2, \"avg_time\" : 55 } } 后续增量 Map-Reduce 之后，随着sessions集合的增长，您可以运行其他 map-reduce 操作。对于 example，将新文档添加到sessions集合： db.sessions.save( { userid: \"a\", ts: ISODate('2011-11-05 14:17:00'), length: 100 } ); db.sessions.save( { userid: \"b\", ts: ISODate('2011-11-05 14:23:00'), length: 115 } ); db.sessions.save( { userid: \"c\", ts: ISODate('2011-11-05 15:02:00'), length: 125 } ); db.sessions.save( { userid: \"d\", ts: ISODate('2011-11-05 16:45:00'), length: 55 } ); 最终，对usersessions集合执行增量map-reduce ，但使用该query字段仅选择新文档。将结果输出到collection session_stats，但是reduce将内容与增量map-reduce的结果进行比较： db.usersessions.mapReduce( mapFunction, reduceFunction, { query: { ts: { $gte: ISODate('2020-03-05 00:00:00') } }, out: { reduce: \"session_stats\" }, finalize: finalizeFunction } ); 查询session_stats集合以验证结果： db.session_stats.find().sort( { _id: 1 } ) 该操作返回以下文档： { \"_id\" : \"a\", \"value\" : { \"total_time\" : 330, \"count\" : 3, \"avg_time\" : 110 } } { \"_id\" : \"b\", \"value\" : { \"total_time\" : 270, \"count\" : 3, \"avg_time\" : 90 } } { \"_id\" : \"c\", \"value\" : { \"total_time\" : 360, \"count\" : 3, \"avg_time\" : 120 } } { \"_id\" : \"d\", \"value\" : { \"total_time\" : 210, \"count\" : 3, \"avg_time\" : 70 } } 聚合替代 前提条件：将集合设置为原始状态： db.usersessions.drop(); db.usersessions.insertMany([ { userid: \"a\", start: ISODate('2020-03-03 14:17:00'), length: 95 }, { userid: \"b\", start: ISODate('2020-03-03 14:23:00'), length: 110 }, { userid: \"c\", start: ISODate('2020-03-03 15:02:00'), length: 120 }, { userid: \"d\", start: ISODate('2020-03-03 16:45:00'), length: 45 }, { userid: \"a\", start: ISODate('2020-03-04 11:05:00'), length: 105 }, { userid: \"b\", start: ISODate('2020-03-04 13:14:00'), length: 120 }, { userid: \"c\", start: ISODate('2020-03-04 17:00:00'), length: 130 }, { userid: \"d\", start: ISODate('2020-03-04 15:37:00'), length: 65 } ]) 使用可用的聚合管道运算符，您可以重写map-reduce示例，而无需定义自定义函数： db.usersessions.aggregate([ { $group: { _id: \"$userid\", total_time: { $sum: \"$length\" }, count: { $sum: 1 }, avg_time: { $avg: \"$length\" } } }, { $project: { value: { total_time: \"$total_time\", count: \"$count\", avg_time: \"$avg_time\" } } }, { $merge: { into: \"session_stats_agg\", whenMatched: [ { $set: { \"value.total_time\": { $add: [ \"$value.total_time\", \"$$new.value.total_time\" ] }, \"value.count\": { $add: [ \"$value.count\", \"$$new.value.count\" ] }, \"value.avg\": { $divide: [ { $add: [ \"$value.total_time\", \"$$new.value.total_time\" ] }, { $add: [ \"$value.count\", \"$$new.value.count\" ] } ] } } } ], whenNotMatched: \"insert\" }} ]) 通过userid$group，得出： total_time使用$sum操作 count使用$sum操作 avg_time使用$avg操作 该操作返回以下文档： { \"_id\" : \"c\", \"total_time\" : 250, \"count\" : 2, \"avg_time\" : 125 } { \"_id\" : \"d\", \"total_time\" : 110, \"count\" : 2, \"avg_time\" : 55 } { \"_id\" : \"a\", \"total_time\" : 200, \"count\" : 2, \"avg_time\" : 100 } { \"_id\" : \"b\", \"total_time\" : 230, \"count\" : 2, \"avg_time\" : 115 } 该$project阶段调整输出文档的形状以反映map-reduce的输出，该输出具有两个字段_id和 value。如果不需要镜像_idand value结构，则该阶段是可选的 。 { \"_id\" : \"a\", \"value\" : { \"total_time\" : 200, \"count\" : 2, \"avg_time\" : 100 } } { \"_id\" : \"d\", \"value\" : { \"total_time\" : 110, \"count\" : 2, \"avg_time\" : 55 } } { \"_id\" : \"b\", \"value\" : { \"total_time\" : 230, \"count\" : 2, \"avg_time\" : 115 } } { \"_id\" : \"c\", \"value\" : { \"total_time\" : 250, \"count\" : 2, \"avg_time\" : 125 } } 该$merge阶段将结果输出到 session_stats_agg集合。如果现有文档_id与新结果相同，则该操作将应用指定的管道，以根据结果和现有文档计算total_time，count和avg_time。如果是相同的，现有的文档_id中session_stats_agg，操作插入文档。 查询session_stats_agg集合以验证结果： db.session_stats_agg.find().sort( { _id: 1 } ) 该操作返回以下文档： { \"_id\" : \"a\", \"value\" : { \"total_time\" : 200, \"count\" : 2, \"avg_time\" : 100 } } { \"_id\" : \"b\", \"value\" : { \"total_time\" : 230, \"count\" : 2, \"avg_time\" : 115 } } { \"_id\" : \"c\", \"value\" : { \"total_time\" : 250, \"count\" : 2, \"avg_time\" : 125 } } { \"_id\" : \"d\", \"value\" : { \"total_time\" : 110, \"count\" : 2, \"avg_time\" : 55 } } 新文档添加到usersessions集合中： db.usersessions.insertMany([ { userid: \"a\", ts: ISODate('2020-03-05 14:17:00'), length: 130 }, { userid: \"b\", ts: ISODate('2020-03-05 14:23:00'), length: 40 }, { userid: \"c\", ts: ISODate('2020-03-05 15:02:00'), length: 110 }, { userid: \"d\", ts: ISODate('2020-03-05 16:45:00'), length: 100 } ]) $match在管道的开头添加一个阶段以指定日期过滤器： db.usersessions.aggregate([ { $match: { ts: { $gte: ISODate('2020-03-05 00:00:00') } } }, { $group: { _id: \"$userid\", total_time: { $sum: \"$length\" }, count: { $sum: 1 }, avg_time: { $avg: \"$length\" } } }, { $project: { value: { total_time: \"$total_time\", count: \"$count\", avg_time: \"$avg_time\" } } }, { $merge: { into: \"session_stats_agg\", whenMatched: [ { $set: { \"value.total_time\": { $add: [ \"$value.total_time\", \"$$new.value.total_time\" ] }, \"value.count\": { $add: [ \"$value.count\", \"$$new.value.count\" ] }, \"value.avg_time\": { $divide: [ { $add: [ \"$value.total_time\", \"$$new.value.total_time\" ] }, { $add: [ \"$value.count\", \"$$new.value.count\" ] } ] } } } ], whenNotMatched: \"insert\" }} ]) 查询session_stats_agg集合以验证结果： db.session_stats_agg.find().sort( { _id: 1 } ) 该操作返回以下文档： { \"_id\" : \"a\", \"value\" : { \"total_time\" : 330, \"count\" : 3, \"avg_time\" : 110 } } { \"_id\" : \"b\", \"value\" : { \"total_time\" : 270, \"count\" : 3, \"avg_time\" : 90 } } { \"_id\" : \"c\", \"value\" : { \"total_time\" : 360, \"count\" : 3, \"avg_time\" : 120 } } { \"_id\" : \"d\", \"value\" : { \"total_time\" : 210, \"count\" : 3, \"avg_time\" : 70 } } 可选的。为了避免$match每次运行时都必须修改聚合管道的日期条件，可以在帮助函数中定义包装聚合： updateSessionStats = function(startDate) { db.usersessions.aggregate([ { $match: { ts: { $gte: startDate } } }, { $group: { _id: \"$userid\", total_time: { $sum: \"$length\" }, count: { $sum: 1 }, avg_time: { $avg: \"$length\" } } }, { $project: { value: { total_time: \"$total_time\", count: \"$count\", avg_time: \"$avg_time\" } } }, { $merge: { into: \"session_stats_agg\", whenMatched: [ { $set: { \"value.total_time\": { $add: [ \"$value.total_time\", \"$$new.value.total_time\" ] }, \"value.count\": { $add: [ \"$value.count\", \"$$new.value.count\" ] }, \"value.avg_time\": { $divide: [ { $add: [ \"$value.total_time\", \"$$new.value.total_time\" ] }, { $add: [ \"$value.count\", \"$$new.value.count\" ] } ] } } } ], whenNotMatched: \"insert\" }} ]); }; 然后，要运行，您只需将开始日期传递给该updateSessionStats()函数： updateSessionStats(ISODate('2020-03-05 00:00:00')) 也可以看看 $ merge示例 按需实例化视图 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Aggregation/Map-Reduce/Troubleshoot-the-Map-Function.html":{"url":"docs/Aggregation/Map-Reduce/Troubleshoot-the-Map-Function.html","title":"Troubleshoot the Map Function","keywords":"","body":" 对 Map Function 进行故障排除 map function 是一个 JavaScript function，它将 value 与 key 关联或“maps”，并在map-reduce操作期间发出 key 和 value 对。 要验证map function 发出的key和value对，请编写自己的emit function。 考虑一个包含以下原型文档的集合orders： { _id: ObjectId(\"50a8240b927d5d8b5891743c\"), cust_id: \"abc123\", ord_date: new Date(\"Oct 04, 2012\"), status: 'A', price: 250, items: [ { sku: \"mmm\", qty: 5, price: 2.5 }, { sku: \"nnn\", qty: 5, price: 2.5 } ] } 为每个文档定义_ma 功能 var map = function() { emit(this.cust_id, this.price); }; 定义emit function 以打印 key 和 value： var emit = function(key, value) { print(\"emit\"); print(\"key: \" + key + \" value: \" + tojson(value)); } 使用orders集合中的单个文档调用map function： var myDoc = db.orders.findOne( { _id: ObjectId(\"50a8240b927d5d8b5891743c\") } ); map.apply(myDoc); 验证 key 和 value 对是否符合预期。 emit key: abc123 value:250 使用orders集合中的多个文档调用map function： var myCursor = db.orders.find( { cust_id: \"abc123\" } ); while (myCursor.hasNext()) { var doc = myCursor.next(); print (\"document _id= \" + tojson(doc._id)); map.apply(doc); print(); } 验证 key 和 value 对是否符合预期。 也可以看看 map function 必须满足各种要求。有关map function 的所有要求的列表，请参阅MapReduce或mongo shell 辅助方法db.collection.mapReduce()。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Aggregation/Map-Reduce/Troubleshoot-the-Reduce-Function.html":{"url":"docs/Aggregation/Map-Reduce/Troubleshoot-the-Reduce-Function.html","title":"Troubleshoot the Reduce Function","keywords":"","body":" 排除 Reduce Function 问题 在本页面 确认输出类型 确保对映射值的 Order 不敏感 确保减少 Function Idempotence reduce function 是一个 JavaScript function，它在map-reduce操作期间“减少”到单个 object 与特定 key 关联的所有值。 reduce function 必须满足各种要求。本教程有助于验证reduce function 是否符合以下条件： reduce function 必须_retject 一个 object，其类型必须与map function 发出的value的类型相同。 valuesArray中元素的 order 不应影响reduce function 的输出。 reduce function 必须是幂等的。 有关reduce function 的所有要求的列表，请参阅MapReduce或mongo shell 辅助方法db.collection.mapReduce()。 确认输出类型 您可以测试reduce function 返回的 value 与map function 发出的 value 的类型相同。 定义一个reduceFunction1 function，它接受 arguments keyCustId和valuesPrices。 valuesPrices是整数的 array： var reduceFunction1 = function(keyCustId, valuesPrices) { return Array.sum(valuesPrices); }; 定义 sample array 整数： var myTestValues = [ 5, 5, 10 ]; 使用myTestValues调用reduceFunction1： reduceFunction1('myKey', myTestValues); 验证reduceFunction1返回 integer： 20 定义一个reduceFunction2 function，它接受 arguments keySKU和valuesCountObjects。 valuesCountObjects是包含两个字段count和qty的 array 文档： var reduceFunction2 = function(keySKU, valuesCountObjects) { reducedValue = { count: 0, qty: 0 }; for (var idx = 0; idx 定义 sample array 文档： var myTestObjects = [ { count: 1, qty: 5 }, { count: 2, qty: 10 }, { count: 3, qty: 15 } ]; 使用myTestObjects调用reduceFunction2： reduceFunction2('myKey', myTestObjects); 验证reduceFunction2返回的文档中包含count和qty字段： { \"count\" : 6, \"qty\" : 30 } 确保对映射值的 Order 不敏感 reduce function 以key和values array 为参数。您可以测试reduce function 的结果不依赖于values array 中元素的 order。 定义 sample values1 array 和 sample values2 array，它们只在 array 元素的 order 中有所不同： var values1 = [ { count: 1, qty: 5 }, { count: 2, qty: 10 }, { count: 3, qty: 15 } ]; var values2 = [ { count: 3, qty: 15 }, { count: 1, qty: 5 }, { count: 2, qty: 10 } ]; 定义一个reduceFunction2 function，它接受 arguments keySKU和valuesCountObjects。 valuesCountObjects是包含两个字段count和qty的 array 文档： var reduceFunction2 = function(keySKU, valuesCountObjects) { reducedValue = { count: 0, qty: 0 }; for (var idx = 0; idx 先使用values1然后使用values2调用reduceFunction2： reduceFunction2('myKey', values1); reduceFunction2('myKey', values2); 验证reduceFunction2返回相同的结果： { \"count\" : 6, \"qty\" : 30 } 确保减少 Function Idempotence 因为 map-reduce 操作可能会为同一个 key 多次调用reduce，并且不会为工作集中的 key 的单个实例调用reduce，reduce function 必须 return 与从该值发出的 value 相同类型的 value。 map function。您可以测试reduce function process“减少”值而不影响最终的 value。 定义一个reduceFunction2 function，它接受 arguments keySKU和valuesCountObjects。 valuesCountObjects是包含两个字段count和qty的 array 文档： var reduceFunction2 = function(keySKU, valuesCountObjects) { reducedValue = { count: 0, qty: 0 }; for (var idx = 0; idx 定义 sample key： var myKey = 'myKey'; 定义 sample valuesIdempotent array，其中包含一个调用reduceFunction2 function 的元素： var valuesIdempotent = [ { count: 1, qty: 5 }, { count: 2, qty: 10 }, reduceFunction2(myKey, [ { count:3, qty: 15 } ] ) ]; 定义一个 sample values1 array，它结合了传递给reduceFunction2的值： var values1 = [ { count: 1, qty: 5 }, { count: 2, qty: 10 }, { count: 3, qty: 15 } ]; 首先使用myKey和valuesIdempotent调用reduceFunction2，然后使用myKey和values1调用reduceFunction2： reduceFunction2(myKey, valuesIdempotent); reduceFunction2(myKey, values1); 验证reduceFunction2返回相同的结果： { \"count\" : 6, \"qty\" : 30 } Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Aggregation/Aggregation-Reference.html":{"url":"docs/Aggregation/Aggregation-Reference.html","title":"Aggregation Reference","keywords":"","body":" 聚合参考 聚合管道快速参考 用于聚合管道的快速参考卡。 聚合命令 数据聚合命令的 reference，它提供 MongoDB 聚合功能的接口。 聚合命令比较 [MapReduce](reference-command-mapReduce.html#dbcmd.mapReduce)和[骨料](reference-command-aggregate.html#dbcmd.aggregate)命令的比较。 聚合管道操作员 聚合管道操作具有一组 operators，可用于定义和操作管道阶段中的文档。 聚合表达式中的变量 在聚合管道表达式中使用变量。 SQL 到聚合映射图表 使用 MongoDB 和 common SQL statements 中的聚合管道和 operators 在 SQL 和 MongoDB 中概述 common 聚合操作。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Aggregation/Aggregation-Reference/Aggregation-Pipeline-Quick-Reference.html":{"url":"docs/Aggregation/Aggregation-Reference/Aggregation-Pipeline-Quick-Reference.html","title":"Aggregation Pipeline Quick Reference","keywords":"","body":" 聚合管道快速参考 在本页面 阶段 表达式 Operator 表达式 表达式 Operators 的索引 注意 有关特定 operator 的详细信息，包括语法和示例，请单击特定的 operator 以转到其 reference 页面。 阶段 阶段(db.collection.aggregate) 在db.collection.aggregate方法中，管道阶段出现在 array 中。文档按顺序通过各个阶段。除和$geoNear阶段之外的所有阶段都可以在管道中多次出现。 db.collection.aggregate( [ { }, ... ] ) 阶段 描述 $addFields 向文档添加新字段。与$project类似，$addFields重塑了流中的每个文档;具体而言，通过向输出文档添加新字段，该文档包含输入文档和新添加字段中的现有字段。 $bucket 根据指定的表达式和存储区边界，将传入的文档分组，称为存储桶。 $bucketAuto 根据指定的表达式将传入的文档分类为特定数量的组(称为存储桶)。自动确定存储桶边界，以尝试将文档均匀地分配到指定数量的存储桶中。 $collStats 返回有关集合或视图的统计信息。 $count 返回聚合管道此阶段的文档数量计数。 $facet 在同一组输入文档的单个阶段内处理多个聚合管道。允许创建能够在单个阶段中跨多个维度或方面表征数据的 multi-faceted 聚合。 $geoNear 基于与地理空间点的接近度返回有序的文档流。将$match，$sort和$limit的功能合并到地理空间数据中。输出文档包括附加距离字段，并且可以包括位置标识符字段。 $graphLookup 对集合执行递归搜索。对于每个输出文档，添加一个新的 array 字段，该字段包含该文档的递归搜索的遍历结果。 $group 按指定的标识符表达式对文档进行分组，并将累加器 expression(s(如果指定)应用于每个 group。消耗所有输入文档，并为每个不同的 group 输出一个文档。输出文档仅包含标识符字段，如果指定，则包含累积字段。 $indexStats 返回有关集合的每个索引的使用的统计信息。 $limit 将未修改的前 n 个文档传递给管道，其中 n 是指定的限制。对于每个输入文档，输出一个文档(对于前 n 个文档)或零文档(在前 n 个文档之后)。 $listSessions 列出足以传播到system.sessions集合的所有会话。 $lookup 对同一数据库中的另一个集合执行左外连接，以从“已连接”集合中过滤文档以进行处理。 $match 过滤文档流以仅允许匹配的文档未经修改地传递到下一个管道阶段。 $match使用标准的 MongoDB 查询。对于每个输入文档，输出一个文档(match)或零文档(无 match)。 $out 将聚合管道的结果文档写入集合。要使用$out阶段，它必须是管道中的最后一个阶段。 $project 重新整形流中的每个文档，例如添加新字段或删除现有字段。对于每个输入文档，输出一个文档。 $redact 通过基于文档本身中存储的信息限制每个文档的内容来重塑流中的每个文档。包含$project和$match的功能。可用于实现字段 level 编辑。对于每个输入文档，输出一个或零个文档。 $replaceRoot 用指定的嵌入文档替换文档。该操作将替换输入文档中的所有现有字段，包括_id字段。指定嵌入在输入文档中的文档，以将嵌入的文档提升到顶部 level。 $sample 从输入中随机选择指定数量的文档。 $skip 跳过前 n 个文档，其中 n 是指定的跳过编号，并将未修改的其余文档传递给管道。对于每个输入文档，输出零文档(对于前 n 个文档)或一个文档(如果在前 n 个文档之后)。 $sort 按指定的排序 key 重新排序文档流。只有 order 改变;文件保持不变。对于每个输入文档，输出一个文档。 $sortByCount 根据指定表达式的 value 对传入文档进行分组，然后计算每个不同 group 中的文档计数。 $unwind 从输入文档解构 array 字段以输出每个元素的文档。每个输出文档都使用元素 value 替换 array。对于每个输入文档，输出 n 个文档，其中 n 是 array 元素的数量，对于空 array 可以为零。 阶段(db.aggregate) 从 version 3.6 开始，MongoDB 还提供了db.aggregate方法： db.aggregate( [ { }, ... ] ) 以下阶段使用db.aggregate()方法而不是db.collection.aggregate()方法。 阶段 描述 $currentOp 返回有关 MongoDB 部署的 active and/or 休眠操作的信息。 $listLocalSessions 列出最近在当前连接的mongos或mongod实例上使用的所有 active 会话。这些会话可能尚未传播到system.sessions集合。 表达式 表达式可以包括field paths 和系统变量，literals，表达 objects和表达式 operators。表达式可以嵌套。 字段路径和系统变量 聚合表达式使用字段路径来访问输入文档中的字段。要指定字段路径，请使用带有美元符号前缀的 string $字段 name 或虚线字段 name(如果该字段位于嵌入文档中)。对于 example，\"$user\"指定user字段的字段路径，或\"$user.name\"指定\"user.name\"字段的字段路径。 \"$\"等效于\"$$CURRENT.\"，其中CURRENT是系统变量，默认情况下，在大多数阶段默认为当前 object 的根，除非在特定阶段另有说明。 CURRENT可以反弹。 除了CURRENT系统变量外，其他系统变量也可用于表达式。要访问表达式中的变量，请在变量 name 前加上$$。 Literals Literals 可以是任何类型。但是，MongoDB 解析以美元符号$开头的 string literals 作为字段的路径，作为投影标志的 numeric/boolean literals。要避免解析 literals，请使用$literal表达式。 表达式 Objects 表达式 objects 具有以下形式： { : , ... } 如果表达式是数字或 boolean literals，MongoDB 将 literals 视为投影标志(e.g. 1或true包括该字段)，仅在$project阶段有效。要避免将 numeric 或 boolean literals 视为投影标志，请使用$literal表达式来包装数字或 boolean literals。 Operator 表达式 在这个部分 算数表达式运算符 数组表达式运算符 布尔表达式运算符 比较表达式运算符 条件表达式运算符 日期表达式运算符 文字表达式运算符 对象表达式运算符 集合表达式运算符 字符串表达式运算符 文本表达式运算符 角度表达式运算符 累加器($group) 累加器($project 和$addFields) 变量表达式运算符 Operator 表达式与采用 arguments 的函数类似。通常，这些表达式采用 array 的 array 并具有以下形式： { : [ , ... ] } 如果 operator 接受单个参数，则可以省略指定参数列表的外部 array： { : } 如果参数是文字 array，为了避免解析歧义，必须将文字 array 包装在$literal表达式中，或者保留指定参数列表的外部 array。 算数表达式运算符 算术表达式对 numbers 执行数学运算。一些算术表达式也可以支持 date 算术。 名称 描述 $abs 返回数字的绝对 value。 $add 添加 numbers 以 return 总和，或添加 numbers 和 date 以 return 新的 date。如果添加 numbers 和 date，则将 numbers 视为毫秒。接受任意数量的参数表达式，但最多只能有一个表达式解析为 date。 $ceil 返回大于或等于指定数字的最小 integer。 $divide 返回将第一个数除以第二个数的结果。接受两个参数表达式。 $exp 将 e 提高到指定的指数。 $floor 返回小于或等于指定数字的最大 integer。 $ln 计算数字的自然 log。 $log 计算指定基数中的数字的 log。 $log10 计算数字的 log 基数 10。 $mod 返回第一个数字的余数除以第二个数字。接受两个参数表达式。 $multiply 将 numbers 乘以_return 产品。接受任意数量的参数表达式。 $pow 将数字提高到指定的指数。 $sqrt 计算平方根。 $subtract 返回从第一个中减去第二个 value 的结果。如果这两个值是 numbers，返回差异。如果这两个值是日期，则返回差异(以毫秒为单位)。如果这两个值是 date 和一个以毫秒为单位的数字，_return 结果 date。接受两个参数表达式。如果这两个值是 date 和数字，请首先指定 date 参数，因为从数字中减去 date 没有意义。 $trunc 截断其整数的数字。 数组表达式运算符 名称 描述 $arrayElemAt 返回指定的 array 索引处的元素。 $arrayToObject 将 key value 对的 array 转换为文档。 $concatArrays 连接数组以 return 连接的 array。 $filter 选择 array 的子集以 return array 仅包含 match 过滤条件的元素。 $in 返回一个 boolean，指示指定的 value 是否在 array 中。 $indexOfArray 搜索 array 以查找指定 value 的出现并返回第一次出现的 array 索引。如果未找到子字符串，则返回-1。 $isArray 确定操作数是否为 array。返回 boolean。 $map 将子表达式应用于 array 的每个元素，并在 order 中返回结果值的 array。接受命名参数。 $objectToArray 将文档转换为表示 key-value 对的文档的 array。 $range 根据 user-defined 输入输出包含整数序列的 array。 $reduce 将表达式应用于 array 中的每个元素，并将它们组合为单个 value。 $reverseArray 返回带有 reverse order 元素的 array。 $size 返回 array 中的元素数。接受单个表达式作为参数。 $slice 返回 array 的子集。 $zip 将两个数组合并在一起。 布尔表达式运算符 Boolean 表达式将其参数表达式计算为布尔值，并将_retolean 作为结果返回 boolean。 除了false boolean value 之外，Boolean 表达式还计算为false以下：null，0和undefined值。 Boolean 表达式将所有其他值计算为true，包括 non-zero 数值和数组。 名称 描述 $and 仅当其所有表达式求值为true时才返回true。接受任意数量的参数表达式。 $not 返回与其参数表达式相反的 boolean value。接受单个参数表达式。 $or 当任何表达式求值为true时返回true。接受任意数量的参数表达式。 比较表达式运算符 比较表达式 return boolean 除了$cmp，它返回一个数字。 比较表达式采用两个参数表达式并比较 value 和 type，使用指定的 BSON 比较 order表示不同类型的值。 名称 描述 $cmp 如果两个值相等则返回0，如果第一个 value 大于第二个值则返回1，如果第一个 value 小于第二个值，则返回-1。 $eq 如果值相等，则返回true。 $gt 如果第一个 value 大于第二个，则返回true。 $gte 如果第一个 value 大于或等于第二个，则返回true。 $lt 如果第一个 value 小于第二个，则返回true。 $lte 如果第一个 value 小于或等于第二个值，则返回true。 $ne 如果值不相等，则返回true。 条件表达式运算符 名称 描述 $cond 一个三元 operator，它计算一个表达式，并根据结果返回另外两个表达式之一的 value。接受有序列表中的三个表达式或三个命名参数。 $cond 如果第一个表达式导致 null 结果，则返回第一个表达式的 non-null 结果或第二个表达式的结果。空结果包含未定义值或缺少字段的实例。接受两个表达式作为 arguments。第二个表达式的结果可以为 null。 $switch 评估一系列案例表达。当它找到一个计算结果为true的表达式时，$switch执行一个指定的表达式并突破控制流。 日期表达式运算符 以下 operators 返回 date objects 或 date object 的组件： 名称 描述 $dateFromParts 给出 date 的组成部分，构造一个 BSON Date object。 $dateFromString 将 date/time string 转换为 date object。 $dateToParts 返回包含 date 组成部分的文档。 $dateToString 将 date 作为格式化的 string 返回。 $dayOfMonth 将 date 的月中某天返回为 1 到 31 之间的数字。 $dayOfWeek 将 date 的星期几返回为 1(星期日)和 7(星期六)之间的数字。 $dayOfYear 将 date 的年中日期作为 1 到 366(闰年)之间的数字返回。 $hour 将 date 的小时数作为 0 到 23 之间的数字返回。 $isoDayOfWeek 返回 ISO 8601 格式的工作日编号，范围从1(星期一)到7(星期日)。 $isoWeek 返回 ISO 8601 格式的周数，范围从1到53。 Week numbers 从1开始，周(星期一到星期日)包含年份的第一个星期四。 $isoWeekYear 以 ISO 8601 格式返回年份编号。年份从第 1 周的星期一(ISO 8601)开始，结束于上周的星期日(ISO 8601)。 $millisecond 返回 date 的毫秒数，作为 0 到 999 之间的数字。 $minute 将 date 的分钟作为 0 到 59 之间的数字返回。 $month 将 date 的月份返回为 1(1 月)和 12(12 月)之间的数字。 $second 返回 date 的秒数，作为 0 到 60 之间的数字(闰秒)。 $week 返回 date 的周数，作为 0(在一年的第一个星期日之前的部分周)和 53(闰年)之间的数字。 $year 将 date 的年份作为数字返回(例： 2014)。 以下算术 operators 可以使用 date 操作数： 名称 描述 $add 添加 numbers 和 date 以 return 新的 date。如果添加 numbers 和 date，则将 numbers 视为毫秒。接受任意数量的参数表达式，但最多只能有一个表达式解析为 date。 $subtract 返回从第一个中减去第二个 value 的结果。如果这两个值是日期，则返回差异(以毫秒为单位)。如果这两个值是 date 和一个以毫秒为单位的数字，_return 结果 date。接受两个参数表达式。如果这两个值是 date 和数字，请首先指定 date 参数，因为从数字中减去 date 没有意义。 文字表达式运算符 名称 描述 $literal 无需解析即可返回 value。用于聚合管道可以将其解释为表达式的值。对于 example，将$literal表达式用于以$开头的 string，以避免将其解析为字段路径。 对象表达式运算符 名称 描述 $mergeObjects 将多个文档合并为一个文档。 version 3.6 中的新内容。 $objectToArray 将文档转换为表示 key-value 对的文档的 array。 version 3.6 中的新内容。 集合表达式运算符 Set 表达式对数组执行 set 操作，将数组视为 sets。 Set 表达式忽略每个输入 array 和元素的 order 中的重复条目。 如果 set 操作返回一个 set，则该操作会过滤掉结果中的重复项，以输出仅包含唯一条目的 array。输出 array 中元素的 order 未指定。 如果集合包含嵌套的 array 元素，则 set 表达式不会下降到嵌套的 array 中，而是在 top-level 处计算 array。 名称 描述 $allElementsTrue 如果没有集合的元素计算为false，则返回true，否则返回false。接受单个参数表达式。 $anyElementTrue 如果集合中的任何元素求值为true，则返回true;否则，返回false。接受单个参数表达式。 $setDifference 返回一个集合，其中的元素出现在第一个集合中但不出现在第二个集合中; i.e。相对于第一组执行第二组的相对补充)。接受两个参数表达式。 $setEquals 如果输入 sets 具有相同的不同元素，则返回true。接受两个或多个参数表达式。 $setIntersection 返回一个包含所有输入 sets 中出现的元素的集合。接受任意数量的参数表达式。 $setIsSubset 如果第一组的所有元素出现在第二组中，则返回true，包括第一组的等于第二组的时间; i.e。不是严格的子集。接受两个参数表达式。 $setUnion 返回一个包含任何输入 sets 中出现的元素的集合。 字符串表达式运算符 具有$concat的 exception 的 String 表达式仅对 strings 的 ASCII 字符具有 well-defined 行为。 无论使用哪个字符，$concat行为都是 well-defined。 名称 描述 $concat 连接任意数量的 strings。 $dateFromString 将 date/time string 转换为 date object。 $dateToString 将 date 作为格式化的 string 返回。 $indexOfBytes 搜索 string 以查找子字符串的出现并返回第一次出现的 UTF-8 字节索引。如果未找到子字符串，则返回-1。 $indexOfCP 搜索 string 以查找子字符串的出现并返回第一次出现的 UTF-8 code 点索引。如果找不到子字符串，则返回-1 $split 根据分隔符将 string 拆分为子字符串。返回子字符串的 array。如果在 string 中找不到分隔符，则返回包含原始 string 的 array。 $strLenBytes 返回 string 中 UTF-8 编码字节的数量。 $strLenCP 返回 string 中 UTF-8 code 点的数量。 $strcasecmp 执行 case-insensitive string 比较并返回：如果两个 strings 相等则返回0，如果第一个 string 大于第二个，则返回1，如果第一个 string 小于第二个，则返回-1。 $substr 已过时。使用$substrBytes或$substrCP。 $substrBytes 返回 string 的子字符串。从 string 中指定的 UTF-8 字节索引(zero-based)处的字符开始，并继续指定的字节数。 $substrCP 返回 string 的子字符串。从 string 中指定的 UTF-8 code point(CP)索引(zero-based)处的字符开始，并继续指定的 code 点数。 $toLower 将 string 转换为小写。接受单个参数表达式。 $toUpper 将 string 转换为大写。接受单个参数表达式。 文本表达式运算符 名称 描述 $meta 访问文本搜索元数据。 角度表达式运算符 名称 描述 $type 返回该字段的 BSON 数据类型。 累加器($group) 可以在$group阶段使用，累加器是 operators，它们在文档通过管道时保持其 state(例： 总计，最大值，最小值和相关数据)。 当在$group阶段用作累加器时，这些 operators 将单个表达式作为输入，为每个输入文档计算一次表达式，并为共享相同 group key 的 group 文档保持其阶段。 名称 描述 $addToSet 返回每个 group 的唯一表达式值的 array。 _Oray 元素的 Order 是未定义的。 $avg 返回数值的平均值。忽略 non-numeric 值。 $first 从每个 group 的第一个文档返回一个 value。仅当文档位于已定义的 order 中时才定义 Order。 $last 从每个 group 的最后一个文档返回一个 value。仅当文档位于已定义的 order 中时才定义 Order。 $max 返回每个 group 的最高表达式 value。 $mergeObjects 返回通过组合每个 group 的输入文档创建的文档。 $min 返回每个 group 的最低表达式 value。 $push 返回每个 group 的表达式值的 array。 $stdDevPop 返回输入值的总体标准偏差。 $stdDevSamp 返回输入值的 sample 标准偏差。 $sum 返回数值的总和。忽略 non-numeric 值。 累加器($project 和$addFields) 一些可用作$group阶段累加器的运算符也可用于$project和$addFields阶段，但不能用作累加器。在$project和$addFields阶段使用时，这些 operators 不会维护它们的 state，并且可以将单个参数或多个 arguments 作为输入。 更改了 version 3.2. 以下累加器 operators 也可用于$project和$addFields阶段。 名称 描述 $avg 返回每个文档的指定表达式或表达式列表的平均值。忽略 non-numeric 值。 $max 返回每个文档的指定表达式或表达式列表的最大值 $min 返回每个文档的指定表达式或表达式列表的最小值 $stdDevPop 返回输入值的总体标准偏差。 $stdDevSamp 返回输入值的 sample 标准偏差。 $sum 返回数值的总和。忽略 non-numeric 值。 变量表达式运算符 名称 描述 $let 定义在子表达式范围内使用的变量，并返回子表达式的结果。接受命名参数。 接受任意数量的参数表达式。 表达式 Operators 的索引 $abs$add$addToSet$allElementsTrue$and$anyElementTrue$arrayElemAt$arrayToObject$avg$cmp$concat$concatArrays$cond$dateFromParts$dateToParts$dateFromString$dateToString $dayOfMonth$dayOfWeek$dayOfYear$divide$eq$exp$filter$first$floor$gt$gte$hour$ifNull$in$indexOfArray$indexOfBytes$indexOfCP$isArray $isoDayOfWeek$isoWeek$isoWeekYear$last$let$literal$ln$log$log10$lt$lte$map$max$mergeObjects$meta$min$millisecond $minute$mod$month$multiply$ne$not$objectToArray$or$pow$push$range$reduce$reverseArray$second$setDifference$setEquals$setIntersection$setIsSubset$setUnion$size $slice$split$sqrt$stdDevPop$stdDevSamp$strcasecmp$strLenBytes$strLenCP$substr$substrBytes$substrCP$subtract$sum$switch$toLower$toUpper$trunc$type$week$year$zip Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Aggregation/Aggregation-Reference/Aggregation-Commands.html":{"url":"docs/Aggregation/Aggregation-Reference/Aggregation-Commands.html","title":"Aggregation Commands","keywords":"","body":" 聚合命令 在本页面 聚合命令 聚合方法 注意 有关特定 operator 的详细信息，包括语法和示例，请单击特定的 operator 以转到其 reference 页面。 聚合命令 名称 描述 Aggregate 使用聚合 framework 执行，例如 group。 count 计算集合或视图中的文档数。 distinct 显示在集合或视图中为指定 key 找到的不同值。 MapReduce 对大型数据集执行map-reduce聚合。 聚合方法 名称 描述 db.collection.aggregate() 提供对聚合管道的访问。 db.collection.group() 已过时。按指定的 key 对集合中的文档进行分组，并执行简单聚合。 db.collection.mapReduce() 对大型数据集执行map-reduce聚合。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Aggregation/Aggregation-Reference/Aggregation-Commands-Commparison.html":{"url":"docs/Aggregation/Aggregation-Reference/Aggregation-Commands-Commparison.html","title":"Aggregation Commands Commparison","keywords":"","body":" 聚合命令比较 以下 table 简要概述了 MongoDB 聚合命令的 features。 Aggregate / db.collection.aggregate() MapReduce / db.collection.mapReduce() 描述 旨在提高聚合任务的性能和可用性的具体目标。 使用“管道”方法，其中 objects 在通过一系列管道操作符(如$group，$match和$sort)时进行转换。 有关管道 operators 的更多信息，请参见聚合管道操作员。 实现 Map-Reduce 聚合以处理大型数据集。 主要特点 可以根据需要重复管道操作员。 Pipeline operators 不需要为每个输入文档生成一个输出文档。 还可以生成新文档或过滤掉文档。 除了分组操作之外，还可以执行复杂的聚合任务以及对不断增长的数据集执行增量聚合。 见Map-Reduce 例子和执行增量 Map-Reduce。 灵活性 仅限于聚合管道支持的 operators 和表达式。 但是，可以使用$project pipeline operator 添加计算字段，创建新虚拟 sub-objects，并将 sub-fields 提取到 top-level 结果中。 有关更多信息，请参阅$project以及有关所有可用管道操作符的更多信息聚合管道操作员。 自定义map，reduce和finalize JavaScript 函数为聚合逻辑提供了灵活性。 有关功能的详细信息和限制，请参阅MapReduce。 输出结果 将结果作为游标返回。如果管道包含$out阶段，则游标为空。 在 version 3.6 中更改：MongoDB 3.6 删除了使用aggregate命令而没有 cursor选项，除非该命令包含explain选项。除非包含explain选项，否则必须指定游标选项。 要指示具有默认批处理大小的游标，请指定cursor: {}。 要指示 non-default 批量大小的光标，请使用cursor: { batchSize: }。 返回各种选项的结果(内联，新集合，合并，替换，减少)。有关输出选项的详细信息，请参阅MapReduce。 分片 支持 non-sharded 和分片输入集合。 支持 non-sharded 和分片输入集合。 更多信息 聚合管道db.collection.aggregate()Aggregate Map-Reducedb.collection.mapReduce()MapReduce. Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Aggregation/Aggregation-Reference/Variables-in-Aggregation-Expressions.html":{"url":"docs/Aggregation/Aggregation-Reference/Variables-in-Aggregation-Expressions.html","title":"Variables in Aggregation Expressions","keywords":"","body":" 聚合表达式中的变量 在本页面 用户变量 系统变量 聚合表达式可以同时使用 user-defined 和系统变量。 变量可以容纳任何BSON 类型数据。要访问变量的 value，请使用带有前缀为 double 美元符号($$)的变量 name 的 string。 如果变量 references 一个 object，要访问 object 中的特定字段，请使用点表示法; 即： \"$$.\"。 用户变量 用户变量名称可以包含 ascii 字符[_a-zA-Z0-9]和任何 non-ascii 字符。 用户变量名必须以小写的 ascii 字母[a-z]或 non-ascii 字符开头。 系统变量 MongoDB 提供以下系统变量： 变量 描述 ROOT References 根文档，即： top-level 文档，当前正在聚合管道阶段中处理。 CURRENT Reference 聚合管道阶段中正在处理的字段路径的开始。除非另有说明，否则所有阶段都以CURRENT开头，与ROOT相同。 CURRENT可以修改。但是，由于$等同于$$CURRENT.，因此重新绑定CURRENT会改变$访问的含义。 REMOVE 一个变量，用于计算缺少的 value。允许条件排除字段。在$projection中，从输出中排除设置为变量REMOVE的字段。 有关其用法的示例，请参阅有条件地排除字段。 version 3.6 中的新内容。 DESCEND $redact表达式的允许结果之一。 PRUNE $redact表达式的允许结果之一。 KEEP $redact表达式的允许结果之一。 也可以看看 $let，$redact，$map Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Aggregation/Aggregation-Reference/SQL-to-Aggregation-Mapping-Chart.html":{"url":"docs/Aggregation/Aggregation-Reference/SQL-to-Aggregation-Mapping-Chart.html","title":"SQL to Aggregation Mapping Chart","keywords":"","body":" SQL 到聚合映射图表 在本页面 例子 聚合管道允许 MongoDB 提供与 SQL 中许多 common 数据聚合操作相对应的本机聚合功能。 以下 table 概述了 common SQL 聚合术语，函数和概念以及相应的 MongoDB 聚合运算符： SQL 术语，函数和概念 Mongo聚合命令 WHERE $match GROUP BY $group HAVING $match SELECT $project ORDER BY $sort LIMIT $limit SUM() $sum COUNT() $sum$sortByCount join $lookup SELECT INTO NEW_TABLE $out MERGE INTO TABLE $merge （从MongoDB 4.2开始可用） 有关所有聚合管道和表达式 operators 的列表，请参阅聚合管道快速参考。 也可以看看 SQL 到 MongoDB 映射图表 例子 以下 table 提供了 SQL 聚合 statements 和相应的 MongoDB statements 的快速 reference。 table 中的示例假定以下条件： SQL 示例假设两个表orders和order_lineitem由order_lineitem.order_id和orders.id列连接。 MongoDB 示例假设一个集合orders包含以下原型的文档： { cust_id: \"abc123\", ord_date: ISODate(\"2012-11-02T17:04:11.102Z\"), status: 'A', price: 50, items: [ { sku: \"xxx\", qty: 25, price: 1 }, { sku: \"yyy\", qty: 25, price: 1 } ] } SQL语句 MongoDB语句 描述 SELECT COUNT(*) AS count FROM orders db.orders.aggregate( [ { $group: { _id: null, count: { $sum: 1 } } } ] ) 计算来自orders的所有记录 SELECT SUM(price) AS total FROM orders db.orders.aggregate( [ { $group: { _id: null, total: { $sum: \"$price\" } } } ] ) orders中对price字段求和 SELECT cust_id, SUM(price) AS total FROM orders GROUP BY cust_id db.orders.aggregate( [ { $group: { _id: \"$cust_id\", total: { $sum: \"$price\" } } } ] ) 对于每个唯一cust_id，对price字段进行求和。 SELECT cust_id, SUM(price) AS total FROM orders GROUP BY cust_id ORDER BY total db.orders.aggregate( [ { $group: { _id: \"$cust_id\", total: { $sum: \"$price\" } } }, { $sort: { total: 1 } } ] ) 对于每个唯一cust_id，求和price字段，结果按总和排序。 SELECT cust_id, ord_date, SUM(price) AS total FROM orders GROUP BY cust_id, ord_date db.orders.aggregate( [ { $group: { _id: { cust_id: \"$cust_id\", ord_date: { $dateToString: { format: \"%Y-%m-%d\", date: \"$ord_date\" }} }, total: { $sum: \"$price\" } } } ] ) 对于每个唯一的cust_id，通过ord_date分组，将price字段相加。排除 data 的 time 部分。 SELECT cust_id, count(*) FROM orders GROUP BY cust_id HAVING count(*) > 1 db.orders.aggregate( [ { $group: { _id: \"$cust_id\", count: { $sum: 1 } } }, { $match: { count: { $gt: 1 } } } ] ) 对于具有多个记录的cust_id，返回cust_id和相应的 record 计数。 SELECT cust_id, ord_date, SUM(price) AS total FROM orders GROUP BY cust_id, ord_date HAVING total > 250 db.orders.aggregate( [ { $group: { _id: { cust_id: \"$cust_id\", ord_date: { $dateToString: { format: \"%Y-%m-%d\", date: \"$ord_date\" }} }, total: { $sum: \"$price\" } } }, { $match: { total: { $gt: 250 } } } ] ) 对于每个唯一的cust_id，通过ord_date分组，仅在总和大于 250 的情况下对price字段和 return 求和。排除 date 的 time 部分 SELECT cust_id, SUM(price) as total FROM orders WHERE status = 'A' GROUP BY cust_id db.orders.aggregate( [ { $match: { status: 'A' } }, { $group: { _id: \"$cust_id\", total: { $sum: \"$price\" } } } ] ) 对于状态为A的每个唯一cust_id，请对price字段求和。 SELECT cust_id, SUM(price) as total FROM orders WHERE status = 'A' GROUP BY cust_id HAVING total > 250 db.orders.aggregate( [ { $match: { status: 'A' } }, { $group: { _id: \"$cust_id\", total: { $sum: \"$price\" } } }, { $match: { total: { $gt: 250 } } } ] ) 对于状态为A的每个唯一cust_id，仅对总和大于 250 的price字段和 return 求和。 SELECT cust_id, SUM(li.qty) as qty FROM orders o, order_lineitem li WHERE li.order_id = o.id GROUP BY cust_id db.orders.aggregate( [ { $unwind: \"$items\" }, { $group: { _id: \"$cust_id\", qty: { $sum: \"$items.qty\" } } } ] ) 对于每个唯一cust_id，将与订单关联的相应 line item qty字段相加。 SELECT COUNT(*) FROM (SELECT cust_id, ord_date FROM orders GROUP BY cust_id, ord_date) as DerivedTable db.orders.aggregate( [ { $group: { _id: { cust_id: \"$cust_id\", ord_date: { $dateToString: { format: \"%Y-%m-%d\", date: \"$ord_date\" }} } } }, { $group: { _id: null, count: { $sum: 1 } } } ] ) 计算不同的cust_id，ord_date分组的数量。排除 date 的 time 部分。 也可以看看 SQL 到 MongoDB 映射图表 聚合管道快速参考 db.collection.aggregate() Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes.html":{"url":"docs/Indexes.html","title":"Indexes","keywords":"","body":"索引 在本页面 默认的id索引 创建索引 索引类型 索引属性 索引用途 索引和排序规则 覆盖查询 索引交集 限制条件 其他注意事项 索引支持在MongoDB中有效地执行查询。如果没有索引，MongoDB必须执行集合扫描，即扫描集合中的每个文档，以选择那些与查询语句匹配的文档。如果一个查询存在适当的索引，MongoDB可以使用该索引来限制它必须检查的文档数量。 索引是特殊的数据结构，它以一种易于遍历的形式存储集合数据集的一小部分。索引存储一个或一组特定字段的值，按字段的值排序。索引项的排序支持有效的相等匹配和基于范围的查询操作。此外，MongoDB可以通过使用索引中的排序返回排序后的结果。 下图说明了使用索引选择和排序匹配文档的查询： 基本上，MongoDB中的索引与其他数据库系统中的索引类似。MongoDB在集合 级别定义索引，并支持在MongoDB集合中文档的任何字段或子字段上的索引。 默认id索引 在创建集合期间，MongoDB 在_id字段上 创建唯一索引。该索引可防止客户端插入两个具有相同值的文档。你不能将_id字段上的index删除。 注意 在分片群集中，如果您不使用_id字段作为分片键，那么您的应用程序 必须确保_id字段中值的唯一性以防止错误。这通常是通过使用标准的自动生成的ObjectId来完成的。 创建索引 要在Mongo Shell中创建索引 ，请使用 db.collection.createIndex()。 db.collection.createIndex( , ) 以下示例在name字段上创建单个键降序索引： db.collection.createIndex( { name: -1 } ) db.collection.createIndex方法只在不存在相同规范的索引时创建索引。 索引名称 索引的默认名称是索引键和索引中每个键的方向(即1或-1)的连接，使用下划线作为分隔符。例如，在{ item : 1, quantity: -1 }上创建的索引名称为item1_quantity-1。 您可以使用自定义名称创建索引，例如比默认名称更易于理解的名称。例如，考虑一个经常查询products集合以填充现有清单上的数据的应用程序。以下createIndex() 方法在上创建索引item并quantity命名为：query for inventory 您可以创建具有自定义名称的索引，比如比默认名称更易于阅读的索引。例如，考虑一个经常查询products集合以填充现有库存数据的应用程序。下面的createIndex() 方法在名为查询的商品和数量上创建一个索引: db.products.createIndex( { item: 1, quantity: -1 } , { name: \"query for inventory\" } ) 您可以使用db.collection.getIndexes() 方法查看索引名称。一旦创建索引，您将无法重命名。相反，您必须删除并使用新名称重新创建索引。 索引类型 MongoDB提供了许多不同的索引类型来支持特定类型的数据和查询。 单个字段 除MongoDB定义的_id索引外，MongoDB还支持在文档的单个字段上创建用户定义的升序/降序索引。 对于单字段索引和排序操作，索引键的排序顺序(升序或降序)并不重要，因为MongoDB可以从任何方向遍历索引。 有关单字段索引的更多信息，请参见单字段索引和使用单字段索引排序。 复合索引 MongoDB还支持多个字段上的用户定义索引，即 复合索引。 复合索引中列出的字段的顺序具有重要意义。例如，如果一个复合索引由{userid: 1, score: -1}组成，索引首先按userid排序，然后在每个userid值内按score排序。 对于复合索引和排序操作，索引键的排序顺序(升序或降序)可以决定索引是否支持排序操作。有关索引顺序对复合索引中的结果的影响的更多信息，请参见 排序顺序。 有关复合索引的更多信息，请参见复合索引和在多个字段上排序。 多键索引 MongoDB使用多键索引来索引存储在数组中的内容。如果索引包含数组值的字段，MongoDB为数组的每个元素创建单独的索引项。这些多键索引允许查询通过匹配数组的一个或多个元素来选择包含数组的文档。MongoDB自动决定是否创建一个多键索引，如果索引字段包含数组值;您不需要显式地指定多键类型。 有关多键索引的更多信息，请参见 Multikey Indexes 和 Multikey Index Bounds。 地理空间索引 为了支持对地理空间坐标数据的高效查询，MongoDB提供了两个特殊的索引:在返回结果时使用平面几何的2d索引和使用球面几何返回结果的2dsphere索引。 有关地理空间索引的高级介绍，请参见2d Index Internals。 文本索引 MongoDB提供了一种文本索引类型，它支持搜索集合中的字符串内容。这些文本索引不存储特定于语言的停止词(例如“the”，“a”，“or”)，并且在一个集合中只存储根词的词干。 有关文本索引和搜索的更多信息，请参见文本索引。 Hashed索引 为了支持基于Hashed的分片，MongoDB提供了Hashed索引类型，该索引类型对字段值的Hashed进行索引。这些索引在其范围内具有更随机的值分布，但只支持相等匹配，而不支持基于范围的查询。 索引属性 唯一索引 索引的unique属性使MongoDB拒绝索引字段的重复值。除了唯一性约束，唯一索引和MongoDB其他索引功能上是一致的。 部分索引 3.2版中的新功能。 部分索引仅索引集合中符合指定过滤器表达式的文档。通过对集合中的部分文档建立索引，部分索引可以降低存储需求，并降低创建和维护索引的性能成本。 部分索引提供了稀疏索引功能的超集，因此应优先于稀疏索引。 稀疏索引 索引的稀疏属性可确保索引仅包含具有索引字段的文档的条目。索引会跳过没有索引字段的文档。 可以将稀疏索引与唯一索引结合使用，以防止插入索引字段值重复的文档，并跳过索引缺少索引字段的文档。 TTL索引 TTL索引是MongoDB可以使用的特殊索引，它可以在一定时间后自动从集合中删除文档。对于某些类型的信息（例如计算机生成的事件数据，日志和会话信息），它们仅需要在数据库中保留有限的时间，这是理想的选择。 请参阅：通过设置TTL使集合中的数据过期以获取实现说明。 参见:通过执行指令设置TTL使集合中的数据过期。 索引用途 索引可以提高读操作的效率。分析查询性能教程提供了一个带有和不带有索引的查询的执行统计信息示例。 有关MongoDB如何选择要使用的索引的信息，请参阅查询优化器。 索引和排序 3.4版的新功能。 排序允许用户为字符串比较指定特定的语言的规则，例如字母大小写和重音符号的规则。 Mongo Shell Compass 注意 下面的示例演示了Mongo Shell中的索引和排序。 请参阅MongoDB Compass文档，了解如何使用自定义排序法与Compass中的索引。 Python 注意 下面的示例演示了Mongo Shell中的索引和排序。 参考驱动程序文档，了解如何在特定驱动程序中使用排序创建索引。 Java 注意 下面的示例演示了Mongo Shell中的索引和排序。 参考驱动程序文档，了解如何在特定驱动程序中使用排序创建索引。 Node.js 注意 下面的示例演示了Mongo Shell中的索引和排序。 参考驱动程序文档，了解如何在特定驱动程序中使用排序创建索引。 若要使用索引进行字符串比较，操作还必须指定相同的排序。也就是说，如果索引指定了不同的排序，则具有排序的索引不能支持对索引字段执行字符串比较的操作。 例如，该集合myColl在category具有排序规则语言环境的字符串字段上具有索引\"fr\"。 db.myColl.createIndex( { category: 1 }, { collation: { locale: \"fr\" } } ) 下面的查询操作指定了与索引相同的排序，可以使用索引: db.myColl.find( { category: \"cafe\" } ).collation( { locale: \"fr\" } ) 但是，以下查询操作（默认情况下使用“简单”二进制整理程序）无法使用索引： db.myColl.find( { category: \"cafe\" } ) 对于索引前缀键不是字符串、数组和嵌入式文档的复合索引，指定不同排序规则的操作仍然可以使用索引来支持对索引前缀键的比较。 例如，集合myColl有一个关于数值字段score和price以及字符串字段类别的复合索引;索引是用collation locale \"fr\"创建的，用于字符串比较: db.myColl.createIndex( { score: 1, price: 1, category: 1 }, { collation: { locale: \"fr\" } } ) 使用\"simple\"二进制排序规则进行字符串比较的以下操作可以使用索引： db.myColl.find( { score: 5 } ).sort( { price: 1 } ) db.myColl.find( { score: 5, price: { $gt: NumberDecimal( \"10\" ) } } ).sort( { price: 1 } ) 以下操作使用\"simple\"二进制排序规则对索引category字段进行字符串比较，该操作可以使用索引来完成查询的一部分：score: 5 db.myColl.find( { score: 5, category: \"cafe\" } ) 有关整理的更多信息，请参见整理参考页。 以下索引仅支持简单的二进制比较，不支持排序规则： 文字索引 2d索引 geoHaystack索引。 覆盖查询 当查询条件和查询的只包含索引字段时，MongoDB直接从索引返回结果，而不扫描任何文档或将文档带入内存。这些覆盖的查询可能非常高效。 有关覆盖查询的更多信息，请参见 覆盖查询。 索引交集 MongoDB可以使用索引的交集来完成查询。对于指定复合查询条件的查询，如果一个索引可以满足查询条件的一部分，而另一个索引可以满足查询条件的另一部分，则MongoDB可以使用两个索引的交集来满足查询。使用复合索引还是使用索引交集是否更有效取决于特定查询和系统。 有关索引交集的详细信息，请参见索引交集。 限制条件 某些限制适用于索引，例如索引键的长度或每个集合的索引数。有关详细信息，请参见索引限制。 其他注意事项 尽管索引可以提高查询性能，但是索引还提出了一些操作上的考虑。有关更多信息，请参见索引的操作注意事项。 应用程序在建立索引期间可能会遇到性能下降的情况，包括对集合的有限读/写访问权限。有关索引构建过程的更多信息，请参见\"现存集合的索引构建\"，包括\"在复制集环境下的索引构建\"章节 一些驱动程序可能指定索引，使用NumberLong(1)而不是1作为规范。这对结果索引没有任何影响。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/Single-Field-Indexes.html":{"url":"docs/Indexes/Single-Field-Indexes.html","title":"Single Field Indexes","keywords":"","body":"单字段索引 在本页面 在单个字段上创建升序索引 在嵌入式字段上创建索引 在内嵌文档上创建索引 其他注意事项 MongoDB为文档集合中任何字段上的索引提供了完整的支持 。默认情况下，所有集合在_id字段上都有一个索引，应用程序和用户可以添加其他索引来支持重要的查询和操作。 本文档描述单个字段上的升序/降序索引。 在单个字段上创建升序索引 假设一个 records的集合，包含类似于如下所示的文档: { \"_id\": ObjectId(\"570c04a4ad233577f97dc459\"), \"score\": 1034, \"location\": { state: \"NY\", city: \"New York\" } } 下面的操作在records集合的score字段上创建一个升序索引: db.records.createIndex( { score: 1 } ) 索引规范中的字段值描述该字段的索引类型。例如，值' 1 '指定一个索引，该索引按升序对项目排序。值' -1 '指定按降序排列项目的索引。有关其他索引类型，请参见索引类型 创建的索引将支持在字段score上选择查询，例如: db.records.find( { score: 2 } ) db.records.find( { score: { $gt: 10 } } ) 在嵌入式字段上创建索引 可以在嵌入文档中的字段上创建索引，就像索引文档中的顶级字段一样。嵌入字段上的索引不同于嵌入文档上的索引，它包含了完整的内容，直到索引中嵌入文档的最大“索引大小”为止。相反，嵌入字段上的索引允许您使用“点表示法”来内省嵌入的文档。 考虑一个名为“records”的集合，它包含类似于以下示例文档的文档: { \"_id\": ObjectId(\"570c04a4ad233577f97dc459\"), \"score\": 1034, \"location\": { state: \"NY\", city: \"New York\" } } 以下操作在\"location.state\" 字段上创建索引： db.records.createIndex( { \"location.state\": 1 } ) 创建的索引将支持选择字段\"location.state\"的查询。，例如: db.records.find( { \"location.state\": \"CA\" } ) db.records.find( { \"location.city\": \"Albany\", \"location.state\": \"NY\" } ) 在内嵌文档上创建索引 您还可以在整个内嵌文档上创建索引。 考虑一个名为“records”的集合，它包含类似于以下示例文档的文档: { \"_id\": ObjectId(\"570c04a4ad233577f97dc459\"), \"score\": 1034, \"location\": { state: \"NY\", city: \"New York\" } } “location”字段是一个内嵌文档，包含嵌入式字段city和state。下面的命令创建一个索引的\"location\"字段作为一个整体: db.records.createIndex( { location: 1 } ) 以下查询可以使用\"location\"字段的索引: db.records.find( { location: { city: \"New York\", state: \"NY\" } } ) 注意 尽管查询可以使用索引，但结果集不包括上面的示例文档。在嵌入文档上执行相等匹配时，字段顺序很重要，内嵌文档必须精确匹配。有关查询内嵌文档的更多信息，请参见查询内嵌文档。 其他注意事项 在索引构建期间，应用程序可能会遇到性能下降，包括对集合的读/写访问受限。有关索引构建过程的更多信息，请参见 “填充集合上的索引构建”，包括“ 复制环境中的 索引构建”部分。 一些驱动程序可能指定索引，使用NumberLong(1)而不是1作为规范。这对结果索引没有任何影响。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/Compound-Indexes.html":{"url":"docs/Indexes/Compound-Indexes.html","title":"Compound Indexes","keywords":"","body":"复合索引 在本页面 创建复合索引 排序顺序 前缀 索引交集 其他注意事项 MongoDB支持复合索引，其中单个索引结构持有对集合文档中多个字段 [1]的引用。下图展示了两个字段上的复合索引示例: [1] mongodb对任何复合索引施加32个字段的限制。 复合索引可以支持在多个字段上匹配的查询。 创建复合索引 要创建一个复合索引，使用类似如下原型的操作: db.collection.createIndex( { : , : , ... } ) 索引规范中的字段值描述该字段的索引类型。例如，值1指定按升序对项排序的索引。值-1指定按降序对项排序的索引。有关其他索引类型，请参见索引类型。 重要 不能创建具有hashed索引类型的复合索引。如果试图创建包含hashed索引字段的复合索引，将收到一个错误。 考虑一个名为products的集合，它包含类似于以下文档的文档: { \"_id\": ObjectId(...), \"item\": \"Banana\", \"category\": [\"food\", \"produce\", \"grocery\"], \"location\": \"4th Street Store\", \"stock\": 4, \"type\": \"cases\" } 以下操作在item和 stock字段上创建一个升序索引： db.products.createIndex( { \"item\": 1, \"stock\": 1 } ) 复合索引中列出的字段的顺序很重要。索引将包含对文档的引用，这些文档首先按item字段的值排序，然后在该字段的每个值内item，按stock字段的值排序。有关更多信息，请参见排序顺序。 除了支持在所有索引字段上都匹配的查询之外，复合索引还可以支持在索引字段的前缀上匹配的查询。也就是说，索引支持对item字段以及item和stock字段的查询： db.products.find( { item: \"Banana\" } ) db.products.find( { item: \"Banana\", stock: { $gt: 5 } } ) 有关详细信息，请参见前缀。 排序顺序 索引以升序（1）或降序（-1）排序顺序存储对字段的引用。对于单字段索引，键的排序顺序无关紧要，因为MongoDB可以在任一方向上遍历索引。但是，对于复合索引，属性的顺序决定了索引是否支持结果集的排序。 假设一个包含字段username和date的文档的集合事件。应用程序可以发出查询，返回的结果首先按升序username值排序，然后按降序(即从最近到最后)date排序，例如: db.events.find().sort( { username: 1, date: -1 } ) 或先按username 降序再按date升序返回结果的查询，例如: db.events.find().sort( { username: -1, date: 1 } ) 以下索引可以支持这两种排序操作： db.events.createIndex( { \"username\" : 1, \"date\" : -1 } ) 但是，上面的索引不支持先升序username值再升序 date值排序，例如: db.events.find().sort( { username: 1, date: 1 } ) 有关排序顺序和复合索引的更多信息，请参见 使用索引对查询结果进行排序。 前缀 索引前缀是索引字段的开始子集。例如，假设以下复合索引: { \"item\": 1, \"location\": 1, \"stock\": 1 } 索引具有以下索引前缀： { item: 1 } { item: 1, location: 1 } 对于复合索引，MongoDB可以使用索引来支持对索引前缀的查询。这样，MongoDB可以将索引用于以下字段的查询： the item field, the item field and the location field, the item field and the location field and the stock field. MongoDB还可以使用索引来支持对item和 stock字段的查询，因为item字段对应于一个前缀。但是，在支持查询方面，索引的效率不如只支持item和stock的索引。 然而，MongoDB不能使用索引来支持查询，包括以下字段，因为没有item字段，列出的字段都不对应前缀索引: the location field, the stock field, or the location and stock fields. 如果你有一个集合,复合索引和索引的前缀(例如:{a:1,b: 1}和{a:1}),如果指数都没有sparse或唯一约束,那么你可以删除索引的前缀(例如{a:1})。MongoDB将在所有使用前缀索引的情况下使用复合索引。 索引交集 从2.6版本开始，MongoDB可以使用索引交集来完成查询。是创建支持查询的复合索引，还是依赖索引交集，这取决于系统的具体情况。有关更多细节，请参见 索引交集和复合索引。 其他注意事项 在索引构建期间，应用程序可能会遇到性能下降，包括对集合的读/写访问受限。有关索引构建过程的更多信息，，请参见 “填充集合上的索引构建”，包括“ 复制环境中的索引构建”部分。 一些驱动程序可能使用NumberLong(1)而不是 1将规范指定为索引。这对结果索引没有任何影响。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/Multikey-Indexes.html":{"url":"docs/Indexes/Multikey-Indexes.html","title":"Multikey Indexes","keywords":"","body":"多键索引 在本页面 创建多键索引 索引界限 唯一多键索引 局限性 例子 为了索引包含数组值的字段，MongoDB为数组中的每个元素创建一个索引键。这些多键索引支持对数组字段的高效查询。多键索引可以在包含标量值[1](例如字符串、数字)和嵌套文档的数组上构造。 标量值指的是既不是嵌入式文档也不是数组的值。 创建多键索引 使用 db.collection.createIndex()方法创建一个多键索引: db.coll.createIndex( { : } ) MongoDB自动创建一个多键索引，如果任何索引字段是一个数组;您不需要显式地指定多键类型。 3.4版本的改变:仅针对WiredTiger和内存存储引擎， 从MongoDB 3.4开始，对于使用MongoDB 3.4或更高版本创建的多键索引，MongoDB会跟踪哪个索引字段或哪些字段导致一个索引成为多键索引。跟踪这些信息允许MongoDB查询引擎使用更紧密的索引边界。 索引界限 如果索引是多键的，那么索引边界的计算遵循特殊规则。有关多键索引边界的详细信息，请参见多键索引边界。 唯一多键索引 对于唯一索引，唯一约束适用于集合中的各个单独文档，而不是在单个文档中。 由于unique约束适用于单独的文档，对于 唯一多键索引，只要文档的索引键值不复制另一个文档的索引键值，文档可能具有导致重复索引键值的数组元素。 有关更多信息，请参见跨单独文档的唯一约束。 局限性 复合多键索引 对于复合多键索引，每个索引文档最多只能有一个索引字段，其值是一个数组。那就是: 如果文档的多个待索引字段是数组，则无法创建复合多键索引。例如，考虑一个包含以下文档的集合: { _id: 1, a: [ 1, 2 ], b: [ 1, 2 ], category: \"AB - both arrays\" } 因为a和b字段都是数组，所以不能在集合上创建复合多键索引{a: 1, b: 1}。 或者，如果复合多键索引已经存在，则不能插入违反此限制的文档。 假设一个包含以下文档的集合： { _id: 1, a: [1, 2], b: 1, category: \"A array\" } { _id: 2, a: 1, b: [1, 2], category: \"B array\" } 允许使用复合多键索引{A: 1, b: 1}，因为对于每个文档，只有一个复合多键索引的字段是一个数组;也就是说，没有文档同时包含a和b字段的数组值。 但是，在创建复合多键索引之后，如果您试图插入一个a和b字段都是数组的文档，MongoDB将导致插入失败。 如果字段是文档数组，则可以索引嵌入的字段以创建复合索引。例如，考虑一个包含以下文档的集合: { _id: 1, a: [ { x: 5, z: [ 1, 2 ] }, { z: [ 1, 2 ] } ] } { _id: 2, a: [ { x: 5 }, { z: 4 } ] } 你可以在{\"a.x\": 1, \"a.z\": 1 }上创建一个复合索引。数组最多只能有一个索引字段的限制也适用。 有关示例，请参见带有嵌入式文档的索引数组。 也可以看看 跨单独文档的唯一约束 单个字段上的唯一索引 排序 由于MongoDB 3.6中数组字段排序行为的改变，当对多键索引的数组排序时，查询计划包括一个阻塞排序阶段。新的排序行为可能会对性能产生负面影响。 在阻塞排序中，在生成输出之前，排序步骤必须使用所有输入。在非阻塞排序或索引排序中，排序步骤扫描索引以按请求的顺序生成结果。 分片键 不能指定多键索引为分片键。 但是，如果分片键索引是复合索引的前缀，那么如果其他键中的一个(即不属于切分键的键)索引了数组，那么复合索引就可以变成复合多键索引。复合多键索引会对性能产生影响。 Hashed索引 Hashed索引不能为多键。 覆盖查询 多键索引不能覆盖对数组字段的查询。 然而，从3.6开始，如果索引跟踪哪个或哪个字段导致索引为多键，那么多键索引可以覆盖对非数组字段的查询。在MongoDB 3.4或更高版本的存储引擎上创建的多键索引，而不是MMAPv1[#]_跟踪该数据。 从4.2版本开始，MongoDB删除了已弃用的MMAPv1存储引擎。 整体查询数组字段 当一个查询过滤器为一个数组指定了一个精确的匹配，MongoDB可以使用multikey索引来查找查询数组的第一个元素，但是不能使用multikey索引扫描来查找整个数组。相反，在使用multikey索引查找查询数组的第一个元素之后，MongoDB检索相关的文档，并筛选其数组与查询中的数组匹配的文档。 例如，假设一个包含以下文档的inventory集合: { _id: 5, type: \"food\", item: \"aaa\", ratings: [ 5, 8, 9 ] } { _id: 6, type: \"food\", item: \"bbb\", ratings: [ 5, 9 ] } { _id: 7, type: \"food\", item: \"ccc\", ratings: [ 9, 5, 8 ] } { _id: 8, type: \"food\", item: \"ddd\", ratings: [ 9, 5 ] } { _id: 9, type: \"food\", item: \"eee\", ratings: [ 5, 9, 5 ] } 该集合在ratings字段上有一个多键索引: db.inventory.createIndex( { ratings: 1 } ) 下面的查询查找ratings字段为数组[5,9]的文档: db.inventory.find( { ratings: [ 5, 9 ] } ) MongoDB可以使用多键索引来查找ratings数组中任何位置有5的文档。然后，MongoDB检索这些文档，筛选ratings数组等于查询数组的文档[5,9]。 $expr $expr 不支持多键索引。 例子 索引基本数组 假设一个包含以下文档的survey集合: { _id: 1, item: \"ABC\", ratings: [ 2, 5, 9 ] } 在ratings上创建索引: db.survey.createIndex( { ratings: 1 } ) 由于ratings字段包含一个数组，ratings的索引是多键的。多键索引包含以下三个索引键，每个都指向同一个文档: 2， 5， 9。 数组索引与嵌入式文件 可以在包含嵌套对象的数组字段上创建多键索引。 假设使用以下形式的文档进行inventory收集: { _id: 1, item: \"abc\", stock: [ { size: \"S\", color: \"red\", quantity: 25 }, { size: \"S\", color: \"blue\", quantity: 10 }, { size: \"M\", color: \"blue\", quantity: 50 } ] } { _id: 2, item: \"def\", stock: [ { size: \"S\", color: \"blue\", quantity: 20 }, { size: \"M\", color: \"blue\", quantity: 5 }, { size: \"M\", color: \"black\", quantity: 10 }, { size: \"L\", color: \"red\", quantity: 2 } ] } { _id: 3, item: \"ijk\", stock: [ { size: \"M\", color: \"blue\", quantity: 15 }, { size: \"L\", color: \"blue\", quantity: 100 }, { size: \"L\", color: \"red\", quantity: 25 } ] } ... 以下操作在stock.size 和stock.quantity字段上创建一个多键索引： db.inventory.createIndex( { \"stock.size\": 1, \"stock.quantity\": 1 } ) 复合多键索引可以支持具有谓词的查询，这些谓词既包括索引字段，也包括仅包括索引前缀“stock”的谓词。，如以下例子所示: db.inventory.find( { \"stock.size\": \"M\" } ) db.inventory.find( { \"stock.size\": \"S\", \"stock.quantity\": { $gt: 20 } } ) 有关MongoDB如何组合多键索引边界的详细信息，请参见多键索引边界。有关复合索引和前缀的行为的更多信息，请参见复合索引和前缀。 复合多键索引也可以支持排序操作，例如下面的例子: db.inventory.find( ).sort( { \"stock.size\": 1, \"stock.quantity\": 1 } ) db.inventory.find( { \"stock.size\": \"M\" } ).sort( { \"stock.quantity\": 1 } ) 有关复合索引和排序操作的行为的更多信息，请参见使用索引对查询结果进行排序。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/Multikey-Indexes/Multikey-Index-Bounds.html":{"url":"docs/Indexes/Multikey-Indexes/Multikey-Index-Bounds.html","title":"Multikey Index Bounds","keywords":"","body":"多键索引范围 在本页面 多键索引的交集边界 多键索引的复合边界 索引扫描的边界定义查询期间要搜索的索引部分。当索引上存在多个谓词时，MongoDB将尝试通过交集或复合的方式组合这些谓词的边界，以产生具有更小边界的扫描。 多键索引的交集边界 边界交集指的是多个边界的逻辑连接(即,和)。例如，给定两个边界[[3，∞]]和[[-∞，6]]，边界的交集得到[[3,6]]。 给定一个索引数组字段，请考虑一个查询，该查询在数组上指定多个谓词，并且可以使用 多键索引。如果联接连接谓词，则MongoDB可以与多键索引边界 相交 $elemMatch。 给定索引数组字段，考虑一个在数组上指定多个谓词并可以使用 多键索引的查询。如果一个$elemMatch连接谓词，MongoDB可以交叉多键索引边界。 例如，一个集合survey包含带有一个字段item和一个数组字段的文档 ratings： { _id: 1, item: \"ABC\", ratings: [ 2, 9 ] } { _id: 2, item: \"XYZ\", ratings: [ 4, 3 ] } 在ratings数组上创建一个多键索引: db.survey.createIndex( { ratings: 1 } ) 下面的查询使用$elemMatch要求数组至少包含一个匹配这两个条件的元素: db.survey.find( { ratings : { $elemMatch: { $gte: 3, $lte: 6 } } } ) 分别取谓词: 大于或等于3的谓词(即$gte: 3)的边界为[[3，∞]]; 小于或等于6谓词(即$lte: 6)的边界为[[-∞，6]]。 因为查询使用$elemMatch来连接这些谓词，MongoDB可以交叉边界到: ratings: [ [ 3, 6 ] ] 如果查询没有将数组字段的条件与$elemMatch连接起来，MongoDB就不能与多键索引边界相交。考虑以下查询: db.survey.find( { ratings : { $gte: 3, $lte: 6 } } ) 查询在ratings数组中搜索至少一个大于或等于3的元素和至少一个小于或等于6的元素。因为单个元素不需要同时满足两个条件，所以MongoDB不相交边界，使用[[3，∞]]或[[-∞，6]]。MongoDB不保证它选择这两个边界中的哪一个。 多键索引的复合边界 复合边界是指对复合索引的多个键使用边界。例如，给定一个复合索引{a: 1, b: 1}，其中a字段的界值为[[3，∞]]，b字段的界值为[[-∞，6]]，复合这些界值可以得到两个界值的使用: { a: [ [ 3, Infinity ] ], b: [ [ -Infinity, 6 ] ] } 如果MongoDB不能复合这两个边界，MongoDB总是按照前场的边界约束索引扫描，在这种情况下，a:[[3，∞]]。 数组字段的复合索引 考虑一个复合的多键索引；即复合索引，其中索引字段之一是数组。例如，一个集合survey包含带有一个字段item和一个数组字段的文档 ratings： { _id: 1, item: \"ABC\", ratings: [ 2, 9 ] } { _id: 2, item: \"XYZ\", ratings: [ 4, 3 ] } 在item字段和ratings字段上创建复合索引: db.survey.createIndex( { item: 1, ratings: 1 } ) 下面的查询在索引的两个键上指定一个条件: db.survey.find( { item: \"XYZ\", ratings: { $gte: 3 } } ) 分别取谓词: 谓词\"XYZ\"的边界是[[\"XYZ\"， \"XYZ\"]]; 评级:{$gte: 3}谓词的边界是[[3，∞]]; MongoDB可以复合这两个边界使用的组合边界: { item: [ [ \"XYZ\", \"XYZ\" ] ], ratings: [ [ 3, Infinity ] ] } 对标量索引字段的范围查询(WiredTiger) 3.4版本的改变:仅针对WiredTiger和内存存储引擎 从MongoDB 3.4开始，对于使用MongoDB 3.4或更高版本创建的多键索引，MongoDB会跟踪哪个索引字段或哪些字段导致一个索引成为多键索引。跟踪这些信息允许MongoDB查询引擎使用更紧密的索引边界 上述复合索引位于标量字段item和数组字段ratings: db.survey.createIndex( { item: 1, ratings: 1 } ) 对于WiredTiger和内存中的存储引擎，如果一个查询操作在MongoDB 3.4或更高版本中创建的复合多键索引的索引标量字段上指定多个谓词，MongoDB将与字段的边界相交。 例如，下面的操作指定了标量字段的范围查询以及数组字段的范围查询: db.survey.find( { item: { $gte: \"L\", $lte: \"Z\"}, ratings : { $elemMatch: { $gte: 3, $lte: 6 } } } ) MongoDB将item到[[“L”，“Z”]]和评级到[[3.0,6.0]]的边界相交，使用以下的组合边界: \"item\" : [ [ \"L\", \"Z\" ] ], \"ratings\" : [ [3.0, 6.0] ] 再举一个例子，考虑标量字段属于嵌套文档的位置。例如，一个集合survey包含以下文档： { _id: 1, item: { name: \"ABC\", manufactured: 2016 }, ratings: [ 2, 9 ] } { _id: 2, item: { name: \"XYZ\", manufactured: 2013 }, ratings: [ 4, 3 ] } 在标量字段“item.name”和“item”上创建复合多键索引。数组字段ratings: db.survey.createIndex( { \"item.name\": 1, \"item.manufactured\": 1, ratings: 1 } ) 考虑以下操作，它在标量字段上指定查询谓词: db.survey.find( { \"item.name\": \"L\" , \"item.manufactured\": 2012 } ) 对于这个查询，MongoDB可以使用以下的组合边界: \"item.name\" : [ [\"L\", \"L\"] ], \"item.manufactured\" : [ [2012.0, 2012.0] ] 早期版本的MongoDB不能合并标量字段的这些边界。 对嵌入文档数组中的字段进行复合索引 如果数组包含嵌入的文档，要对嵌入文档中包含的字段进行索引，请使用索引规范中的虚线字段名。例如，给定以下嵌入文档数组: ratings: [ { score: 2, by: \"mn\" }, { score: 9, by: \"anon\" } ] 分数字段的虚线字段名是“ratings.score”。 非数组字段和数组字段的复合边界 考虑一个包含字段item和数组字段ratings的文档的集合survey2: { _id: 1, item: \"ABC\", ratings: [ { score: 2, by: \"mn\" }, { score: 9, by: \"anon\" } ] } { _id: 2, item: \"XYZ\", ratings: [ { score: 5, by: \"anon\" }, { score: 7, by: \"wv\" } ] } 在非数组字段item和数组ratings中的两个字段上创建复合索引。score和ratings.by: db.survey2.createIndex( { \"item\": 1, \"ratings.score\": 1, \"ratings.by\": 1 } ) 下面的查询为所有三个字段指定了一个条件: db.survey2.find( { item: \"XYZ\", \"ratings.score\": { $lte: 5 }, \"ratings.by\": \"anon\" } ) 分别取谓词: 谓词\"XYZ\"的边界是[[\"XYZ\"， \"XYZ\"]]; {$lte: 5}谓词的边界是[[-∞，5]]; by: \"anon\"谓词的边界是[\"anon\"， \"anon\"]。 MongoDB的可以复合边界为item与键或者为边界\"ratings.score\"或界限为\"ratings.by\"取决于查询谓词和索引关键字的值，。MongoDB不保证与item 领域的界限。例如，MongoDB将选择将item边界与\"ratings.score\"边界复合 ： { \"item\" : [ [ \"XYZ\", \"XYZ\" ] ], \"ratings.score\" : [ [ -Infinity, 5 ] ], \"ratings.by\" : [ [ MinKey, MaxKey ] ] } 或者，MongoDB可以选择将item范围与 \"ratings.by\"范围进行组合： { \"item\" : [ [ \"XYZ\", \"XYZ\" ] ], \"ratings.score\" : [ [ MinKey, MaxKey ] ], \"ratings.by\" : [ [ \"anon\", \"anon\" ] ] } 然而，为了复合“评级”的界限。带有“ratings.by”边界的“score”。查询必须使用$elemMatch。有关更多信息，请参见 数组中索引字段的复合边界。 数组中索引字段的复合边界 将同一个数组的索引键的边界复合在一起: 索引键必须共享相同的字段路径，但不包括字段名称。 查询必须使用该路径上的$elemMatch在字段上指定谓词。 对于嵌入文档中的字段，虚线字段名，例如“a.b.c”.d\"，是d的字段路径。要复合同一个数组的索引键的边界，$elemMatch必须在到但不包括字段名本身的路径上;即.“a.b.c”。 例如，在ratings.score和ratings.by字段创建一个符合索引： db.survey2.createIndex( { \"ratings.score\": 1, \"ratings.by\": 1 } ) 字段\"ratings.score\"和\"ratings.by\"共享字段路径ratings。以下查询使用$elemMatch的字段ratings，以要求所述阵列包含至少有一个元素匹配这两个条件: db.survey2.find( { ratings: { $elemMatch: { score: { $lte: 5 }, by: \"anon\" } } } ) 分别取谓词: { $lte: 5 }谓词的边界是[-∞，5]; by: \"anon\"谓词的边界是[\"anon\"， \"anon\"] MongoDB可以复合这两个边界使用的组合边界: { \"ratings.score\" : [ [ -Infinity, 5 ] ], \"ratings.by\" : [ [ \"anon\", \"anon\" ] ] } 查询没有$elemMatch 如果查询没有将索引数组字段的条件与$elemMatchh连接起来，MongoDB就不能复合它们的边界。考虑以下查询: db.survey2.find( { \"ratings.score\": { $lte: 5 }, \"ratings.by\": \"anon\" } ) 因为数组中嵌入的单个文档不需要同时满足这两个条件，所以MongoDB不复合边界。使用复合索引时，如果MongoDB不能约束索引的所有字段，MongoDB总是约束索引的前导字段，这里是“ratings.score”: { \"ratings.score\": [ [ -Infinity, 5 ] ], \"ratings.by\": [ [ MinKey, MaxKey ] ] } $elemMatch在不完整路径上 如果查询没有在嵌入字段的路径上指定$elemMatch，最多但不包括字段名，MongoDB不能复合来自同一数组的索引键的边界。 例如，集合survey3包含一个字段item和一个数组字段ratings的文档: { _id: 1, item: \"ABC\", ratings: [ { scores: [ { q1: 2, q2: 4 }, { q1: 3, q2: 8 } ], loc: \"A\" }, { scores: [ { q1: 2, q2: 5 } ], loc: \"B\" } ] } { _id: 2, item: \"XYZ\", ratings: [ { scores: [ { q1: 7 }, { q1: 2, q2: 8 } ], loc: \"B\" } ] } 在ratings.scores.q1和ratings.scores.q2字段上创建一个复合索引。 db.survey3.createIndex( { \"ratings.scores.q1\": 1, \"ratings.scores.q2\": 1 } ) 字段\"ratings.scores.q1\"和\"ratings.scores.q2\"共享字段路径\"ratings.scores\"，并且$elemMatch必须在该路径上。 但是，下面的查询使用了$elemMatch，但不是在必需的路径上: db.survey3.find( { ratings: { $elemMatch: { 'scores.q1': 2, 'scores.q2': 8 } } } ) 因此，MongoDB 无法混合边界，并且 \"ratings.scores.q2\"在索引扫描期间该字段将不受限制。要增加界限，查询必须$elemMatch在路径上使用\"ratings.scores\"： db.survey3.find( { 'ratings.scores': { $elemMatch: { 'q1': 2, 'q2': 8 } } } ) Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/Text-Indexes.html":{"url":"docs/Indexes/Text-Indexes.html","title":"Text Indexes","keywords":"","body":"文本索引 在本页面 概述 版本 创建文本索引 不区分大小写 变音符号不敏感 标记化分隔符 索引条目 支持的语言和停用词 sparse 属性 限制条件 存储要求和性能成本 文字搜索支持 MONGODB地图搜索 Atlas Search可以很容易地在MongoDB数据上构建快速、基于相关性的搜索功能。在MongoDB Atlas上试试吧，这是我们的完全托管数据库服务。 概述 MongoDB提供文本索引以支持对字符串内容的文本搜索查询。text索引可以包含任何值为字符串或字符串元素数组的字段。 版本 文本索引版本 描述 版本3 MongoDB引入了text索引的第3版。版本3是text在MongoDB 3.2和更高版本中创建的索引的默认版本。 版本2 MongoDB 2.6引入了text索引的版本2 。版本2是text在MongoDB 2.6和3.0系列中创建的索引的默认版本。 版本1 MongoDB 2.4引入了text索引的版本1 。MongoDB 2.4仅支持版本1。 要覆盖默认版本并指定其他版本，请在创建索引时包括该选项。{ \"textIndexVersion\": } 要覆盖默认版本并指定不同的版本，在创建索引时包括选项{\"textIndexVersion\":}。 创建文本索引 重要 一个集合最多可以有一个 text索引。 若要创建text索引，请使用 db.collection.createIndex()方法。若要索引包含字符串或字符串元素数组的字段，请包含该字段并在索引文档中指定字符串字面量“text”，如下例所示: db.reviews.createIndex( { comments: \"text\" } ) 您可以为索引建立多个字段的text索引。以下示例text在字段subject和 comments上创建索引： db.reviews.createIndex( { subject: \"text\", comments: \"text\" } ) 复合索引可以包含文本索引键和升序/降序索引键。有关更多信息，请参见复合索引。 为了删除text索引，请使用索引名称。有关更多信息，请参见 使用索引名称删除文本索引。 指定权重 对于文本索引，索引字段的权重表示该字段相对于其他索引字段在文本搜索分数方面的重要性。 对于文档中的每个索引字段，MongoDB将匹配的数量乘以权重并对结果进行求和。然后，MongoDB使用这个总和计算文档的分数。有关按文本分数返回和排序的详细信息，请参阅$meta操作符。 索引字段的默认权重为1。要调整索引字段的权重，请在db.collection.createIndex()方法中包含权重选项。 有关使用权重控制文本搜索结果的更多信息，请参见使用权重控制搜索结果。 通配符文本索引 注意 通配符文本索引不同于通配符索引。通配符索引不支持使用$text操作符的查询。 尽管通配符文本索引和通配符索引共享通配符$**字段模式，但它们是不同的索引类型。仅通配符文本索引支持$text运算符。 在多个字段上创建文本索引时，还可以使用通配符说明符($**)。通过通配符文本索引，MongoDB为集合中每个文档包含字符串数据的每个字段建立索引。下面的示例使用通配符创建一个文本索引: db.collection.createIndex( { \"$**\": \"text\" } ) 该索引允许对所有具有字符串内容的字段进行文本搜索。如果不清楚在文本索引中包含哪些字段或用于特殊查询，那么这种索引对于高度非结构化数据非常有用。 通配符文本索引是多个字段上的文本索引。因此，您可以在创建索引期间为特定字段分配权重，以控制结果的排序。有关使用权重控制文本搜索结果的详细信息，请参见 使用权重控制搜索结果。 通配符文本索引(与所有文本索引一样)可以是复合索引的一部分。例如，下面在字段a以及通配符上创建一个复合索引: db.collection.createIndex( { a: 1, \"$**\": \"text\" } ) 与所有复合文本索引一样，由于a位于文本索引键之前，为了使用该索引执行$text搜索，查询谓词必须包含一个相等匹配条件a。有关复合文本索引的信息，请参见复合文本索引。 不区分大小写 在版本3.2中更改 版本3文本索引支持常用的`C语言、简单的S`语言，对于土耳其语言，支持Unicode 8.0字符数据库大小写折叠中指定的特殊T大小写折叠。 此案的大小写扩展文本索引包括字符不区分大小写的区分标志,如 é和É,从非拉丁字母和字符,如“И”和“и”西里尔字母。 文本索引的版本3也不支持变音符号。因此，索引也不区分 é, É, e, and E. 以前版本的文本索引只对[A-z]不区分大小写;例如，只对非变音符拉丁字符不区分大小写。对于所有其他字符，早期版本的文本索引将它们视为不同的字符。 变音符号不敏感 在版本3.2中更改 在版本3中，text索引不区分音素。即，索引不包含变音符号和它们的未标记的对应，如字符区分é，ê和 e。更具体地说，文本索引去除Unicode 8.0字符数据库道具列表中分类为变音符号的字符。 text索引的第3版对带有变音符号的字符也不区分大小写。这样，索引也没有区分之间é，É，e，和E。 text索引的早期版本将带变音符号的字符视为不同的字符。 标记化分隔符 在版本3.2中更改 对于符号化，第3版text索引使用下分类的分隔符Dash，Hyphen，Pattern_Syntax， Quotation_Mark，Terminal_Punctuation，和White_Space中 的Unicode 8.0字符数据库道具列表。 在Unicode 8.0字符数据库Prop列表中，版本3文本索引使用分界符分类在破折号、连字符、Pattern_Syntax、Quotation_Mark、Terminal_Punctuation和White_Space中。 例如，如果给定的一个字符串，该索引对待，和空格作为分隔符。\"Il a dit qu'il «était le meilleur joueur du monde»\"``text``«``» 例如，如果给定一个字符串“Il a dit qu'il«etait le meilleur joueur du monde»”，文本索引将«,»和空格作为分隔符。 该指数治疗的早期版本«作为术语的一部分 \"«était\"，and»作为长期的一部分\"monde»\"。 索引条目 文本索引对索引项的索引字段中的术语进行标记和词根处理。文本索引在集合中每个文档的每个索引字段中为每个唯一的词根项存储一个索引项。索引使用简单的特定语言的后缀词干。 支持的语言和停用词 MongoDB支持多种语言的文本搜索。text指数下降特定语言的停用词（如英语，the，an， a，and，等）和使用简单的语言特定的后缀而产生。有关支持的语言的列表，请参见文本搜索语言。 如果您将语言值指定为\"none\"，则text索引将使用简单的标记化，不包含停止词列表和词干分析。 要为文本索引指定一种语言，请参见 为文本索引指定语言。 sparse属性 text索引总是sparse并且忽略 sparse选项。如果文档缺少text索引字段（或者该字段是null或为空数组），则MongoDB不会将文档条目添加到text索引中。对于插入，MongoDB会插入文档，但不会添加到text索引中。 对于包含text索引键和其他类型的键的复合索引，只有text索引字段才能确定索引是否引用文档。其他键不能确定索引是否引用文档。 限制条件 每个集合有一个文本索引 一个集合最多可以有一个 text索引。 文字搜索和提示 如果查询包含$text查询表达式，则不能使用hint()。 文本索引和排序 排序操作无法从text索引获得排序顺序，即使从复合文本索引也无法获得排序顺序；即排序操作不能使用文本索引中的顺序。 复合索引 复合索引可以包含文本索引键和升序/降序索引键。但是，这些复合索引有以下限制: 复合文本索引不能包含任何其他特殊索引类型，例如多键或 地理空间索引字段。 如果复合文本索引在文本索引键之前包含键，那么要执行$text搜索，查询谓词必须包含前面键的相等匹配条件。 在创建复合文本索引时，必须在索引规范文档中邻接列出所有文本索引键。 另请参见文本索引和排序。 有关复合文本索引的示例，请参见 限制扫描的条目数。 删除文本索引 要删除text索引，请将索引名称传递给 db.collection.dropIndex()方法。要获取索引的名称，请运行该db.collection.getIndexes()方法。 有关text索引的默认命名方案以及覆盖默认名称的信息，请参见 为文本Index指定名称。 排序选项 text索引仅支持简单的二进制比较，不支持排序规则。 要在具有非简单排序规则的集合上创建文本索引，必须在创建索引时显式指定{collation: {locale: \"simple\"}}。 存储要求和性能成本 文本索引有以下存储要求和性能成本: text索引可以很大。对于每个插入的文档，每个索引字段中的每个唯一后词形词都包含一个索引条目。 构建text索引与构建大型多键索引非常相似，并且比在相同数据上构建简单的有序（标量）索引要花更长的时间。 在text现有集合上建立较大索引时，请确保对打开文件描述符的限制足够高。请参阅建议的设置。 text 索引会影响插入吞吐量，因为MongoDB必须在每个新源文档的每个索引字段中为每个唯一的词干词添加一个索引条目。 此外，text索引不存储短语或有关文档中单词接近度的信息。结果，当整个集合放入RAM中时，短语查询将更有效地运行。 文本搜索支持 该text指数支持$text查询操作。有关文本搜索的示例，请参见。有关聚合管道中操作的示例，请参见聚合管道中的 文本搜索。$text reference page$text 文本索引支持$text查询操作。有关文本搜索的示例，请参见 $text reference page。有关聚合管道中的$text操作示例，请参见聚合管道中的文本搜索。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/Text-Indexes/Specify-a-Language-for-Text-Index.html":{"url":"docs/Indexes/Text-Indexes/Specify-a-Language-for-Text-Index.html","title":"Specify a Language for Text Index","keywords":"","body":"为文本索引指定语言 在本页面 指定text索引的默认语言 text为多种语言的集合创建索引 本教程描述了如何指定与文本索引关联的默认语言，以及如何为包含不同语言文档的集合创建文本索引。 指定text索引的默认语言 与索引数据相关联的默认语言决定了解析词根(即词干分析)和忽略停止词的规则。索引数据的默认语言是英语。 要指定不同的语言，请在创建文本索引时使用default_language选项。有关default_language可用的语言，请参阅文本搜索语言。 下面的示例为quotes集合在内容字段上创建了一个文本索引，并将default_language设置为西班牙语: db.quotes.createIndex( { content : \"text\" }, { default_language: \"spanish\" } ) text为多种语言的集合创建索引 指定文档内的索引语言 如果集合包含使用不同语言的文档或嵌入文档，则在文档或嵌入文档中包含名为language的字段，并将该文档或嵌入文档的语言指定为其值。 构建text索引时，MongoDB将为该文档或嵌入式文档使用指定的语言： 文档中指定的语言将覆盖text索引的默认语言。 嵌入式文档中的指定语言将覆盖附件文档中指定的语言或索引的默认语言。 有关支持的语言列表，请参见文本搜索语言。 例如，一个集合quotes包含多语言文档，根据需要包括language文档和/或嵌入文档中的字段： { _id: 1, language: \"portuguese\", original: \"A sorte protege os audazes.\", translation: [ { language: \"english\", quote: \"Fortune favors the bold.\" }, { language: \"spanish\", quote: \"La suerte protege a los audaces.\" } ] } { _id: 2, language: \"spanish\", original: \"Nada hay más surrealista que la realidad.\", translation: [ { language: \"english\", quote: \"There is nothing more surreal than reality.\" }, { language: \"french\", quote: \"Il n'y a rien de plus surréaliste que la réalité.\" } ] } { _id: 3, original: \"is this a dagger which I see before me.\", translation: { language: \"spanish\", quote: \"Es este un puñal que veo delante de mí.\" } } 如果您使用默认的英语语言在quote字段上创建了一个文本索引。 db.quotes.createIndex( { original: \"text\", \"translation.quote\": \"text\" } ) 然后，对于包含该language 字段的文档和嵌入文档，text索引使用该语言来解析词干和其他语言特征。 对于不包含该language字段的嵌入式文档， 如果封闭的文档包含该language字段，则索引将文档的语言用于嵌入式文档。 否则，索引将为嵌入文档使用默认语言。 对于不包含该language字段的文档，索引使用默认语言，即英语。 使用任何字段来指定文档的语言 要使用非语言名称的字段，请在创建索引时包含language_override选项。 例如，下面的命令使用idioma作为字段名而不是language: db.quotes.createIndex( { quote : \"text\" }, { language_override: \"idioma\" } ) quotes集合的文档可以在idioma字段中指定一种语言： { _id: 1, idioma: \"portuguese\", quote: \"A sorte protege os audazes\" } { _id: 2, idioma: \"spanish\", quote: \"Nada hay más surrealista que la realidad.\" } { _id: 3, idioma: \"english\", quote: \"is this a dagger which I see before me\" } Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/Text-Indexes/Specify-Name-for-text-Index.html":{"url":"docs/Indexes/Text-Indexes/Specify-Name-for-text-Index.html","title":"Specify Name for text Index","keywords":"","body":"指定文本索引的名称 在本页面 指定text索引名称 使用索引名称删除text索引 索引的默认名称由与串联的每个索引字段名称组成_text。例如，下面的命令创建一个text上的字段索引content，users.comments和 users.profiles： 索引的默认名称由每个索引字段名和_text连接起来组成。例如，下面的命令在字段content、users.comments和users.profiles上创建一个文本索引: db.collection.createIndex( { content: \"text\", \"users.comments\": \"text\", \"users.profiles\": \"text\" } ) 索引的默认名称是： \"content_text_users.comments_text_users.profiles_text\" 指定text索引名称 您可以将name选项传递给 db.collection.createIndex()方法： db.collection.createIndex( { content: \"text\", \"users.comments\": \"text\", \"users.profiles\": \"text\" }, { name: \"MyTextIndex\" } ) 使用索引名称删除text索引 无论是文本索引具有默认名称或指定一个名称为文本索引，删除该文本索引，通过索引名称的db.collection.dropIndex()方法。 例如，考虑以下操作创建的索引: db.collection.createIndex( { content: \"text\", \"users.comments\": \"text\", \"users.profiles\": \"text\" }, { name: \"MyTextIndex\" } ) 然后，要删除此文本索引，请将名称传递\"MyTextIndex\"给 db.collection.dropIndex()方法，如下所示： db.collection.dropIndex(\"MyTextIndex\") 若要获取索引的名称，请使用 db.collection.getIndexes()方法。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/Text-Indexes/Control-Search-Results-with-Weights.html":{"url":"docs/Indexes/Text-Indexes/Control-Search-Results-with-Weights.html","title":"Control Search Results with Weights","keywords":"","body":"用权重控制搜索结果 文本搜索为索引字段中包含搜索词的每个文档分配一个分数。分数决定了文档与给定搜索查询的相关性。 对于文本索引，索引字段的权重表示该字段相对于其他索引字段在文本搜索分数方面的重要性。 对于文档中的每个索引字段，MongoDB将匹配的数量乘以权重并对结果进行求和。然后，MongoDB使用这个总和计算文档的分数。有关按文本分数返回和排序的详细信息，请参阅 $meta操作符。 索引字段的默认权重为1。要调整索引字段的权重，请在db.collection.createIndex()方法中包含权重选项。 警告 仔细选择权重，以防止需要重新索引。 集合blog包含以下文档： { _id: 1, content: \"This morning I had a cup of coffee.\", about: \"beverage\", keywords: [ \"coffee\" ] } { _id: 2, content: \"Who doesn't like cake?\", about: \"food\", keywords: [ \"cake\", \"food\", \"dessert\" ] } 要为内容字段和关键字字段创建具有不同字段权重的文本索引，请包含createIndex()方法的权重选项。例如，下面的命令在三个字段上创建一个索引，并为其中两个字段分配权重: db.blog.createIndex( { content: \"text\", keywords: \"text\", about: \"text\" }, { weights: { content: 10, keywords: 5 }, name: \"TextIndex\" } ) 文本索引有以下字段和权重: content的权重是10， keywords的权重为5， about的默认权重为1。 这些权重表示索引字段之间的相对重要性。例如，content字段中的term匹配有: 2倍(即10:5)的影响，作为一个词匹配的关键字字段 10倍(即10:1)的影响，作为一场关于领域的学期比赛的影响。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/Text-Indexes/Limit-the-Number-of-Entries-Scanned.html":{"url":"docs/Indexes/Text-Indexes/Limit-the-Number-of-Entries-Scanned.html","title":"Limit the Number of Entries Scanned","keywords":"","body":"限制扫描条目的数量 本教程描述了如何创建索引来限制对包含$text表达式和相等条件的查询扫描的索引条目的数量。 集合inventory包含以下文档： { _id: 1, dept: \"tech\", description: \"lime green computer\" } { _id: 2, dept: \"tech\", description: \"wireless red mouse\" } { _id: 3, dept: \"kitchen\", description: \"green placemat\" } { _id: 4, dept: \"kitchen\", description: \"red peeler\" } { _id: 5, dept: \"food\", description: \"green apple\" } { _id: 6, dept: \"food\", description: \"red potato\" } 考虑由各个部门执行文本搜索的通用用例，例如: db.inventory.find( { dept: \"kitchen\", $text: { $search: \"green\" } } ) 为了限制文本搜索只扫描特定部门内的那些文档，创建一个复合索引，首先在字段dept上指定一个升序/降序索引键，然后在字段描述上指定一个文本索引键: db.inventory.createIndex( { dept: 1, description: \"text\" } ) 然后，特定部门内的文本搜索将限制索引文档的扫描。例如，下面的查询只扫描那些dept = kitchen的文档: db.inventory.find( { dept: \"kitchen\", $text: { $search: \"green\" } } ) 注意 复合text索引不能包含任何其他特殊索引类型，例如多键或 地理空间索引字段。 如果复合text索引在 索引键之前包含键，则要text执行$text搜索，查询谓词必须在前面的键上包含相等匹配条件。 创建复合text索引时，所有text索引键必须在索引规范文档中相邻列出。 也可以看看 文字索引 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/Wildcard-Indexes.html":{"url":"docs/Indexes/Wildcard-Indexes.html","title":"Wildcard Indexes","keywords":"","body":"通配符索引 在本页面 创建通配符索引 注意事项 行为 限制条件 通配符索引查询/排序支持 MongoDB支持在一个或一组字段上创建索引，以支持查询。由于MongoDB支持动态模式，应用程序可以查询不能提前知道名称或任意名称的字段。 MongoDB版本中的新功能： 4.2 MongoDB 4.2引入了通配符索引，以支持针对未知或任意字段的查询。 考虑一个应用程序，该应用程序在该userMetadata字段下捕获用户定义的数据 并支持查询该数据： { \"userMetadata\" : { \"likes\" : [ \"dogs\", \"cats\" ] } } { \"userMetadata\" : { \"dislikes\" : \"pickles\" } } { \"userMetadata\" : { \"age\" : 45 } } { \"userMetadata\" : \"inactive\" } 管理员希望创建索引来支持对userMetadata的任何子字段的查询。 在通配符索引userMetadata 可以支持单场查询userMetadata， userMetadata.likes，userMetadata.dislikes，和 userMetadata.age： db.userData.createIndex( { \"userMetadata.$**\" : 1 } ) 该索引可以支持以下查询： db.userData.find({ \"userMetadata.likes\" : \"dogs\" }) db.userData.find({ \"userMetadata.dislikes\" : \"pickles\" }) db.userData.find({ \"userMetadata.age\" : { $gt : 30 } }) db.userData.find({ \"userMetadata\" : \"inactive\" }) userMetadata上的非通配符索引只能支持对userMetadata的查询。 重要 通配符索引并非旨在替代基于工作负载的索引计划。有关创建索引以支持查询的更多信息，请参见创建索引以支持查询。有关通配符索引限制的完整文档，请参阅 通配符索引限制。 创建通配符索引 重要 该featureCompatibilityVersion必须创建通配符索引。有关设置fCV的说明，请参阅 在MongoDB 4.4部署上设置功能兼容版本。mongod 4.2 可以使用createIndexes数据库命令或其shell助手createIndex()或createIndexes()创建通配符索引。 在字段上创建通配符索引 索引特定字段的值: db.collection.createIndex( { \"fieldA.$**\" : 1 } ) 使用这个通配符索引，MongoDB将索引fieldA的所有值。如果字段是嵌套的文档或数组，通配符索引将递归到文档/数组中，并存储文档/数组中所有字段的值。 例如，product_catalog集合中的文档可能包含product_attributes字段。product_attributes字段可以包含任意嵌套的字段，包括嵌入的文档和数组: { \"product_name\" : \"Spy Coat\", \"product_attributes\" : { \"material\" : [ \"Tweed\", \"Wool\", \"Leather\" ] \"size\" : { \"length\" : 72, \"units\" : \"inches\" } } } { \"product_name\" : \"Spy Pen\", \"product_attributes\" : { \"colors\" : [ \"Blue\", \"Black\" ], \"secret_feature\" : { \"name\" : \"laser\", \"power\" : \"1000\", \"units\" : \"watts\", } } } 下面的操作在product_attributes字段上创建一个通配符索引: db.products_catalog.createIndex( { \"product_attributes.$**\" : 1 } ) 通配符索引可以支持对product_attributes或其内嵌字段的任意单字段查询: db.products_catalog.find( { \"product_attributes.size.length\" : { $gt : 60 } } ) db.products_catalog.find( { \"product_attributes.material\" : \"Leather\" } ) db.products_catalog.find( { \"product_attributes.secret_feature.name\" : \"laser\" } ) 注意 特定于路径的通配符索引语法与该wildcardProjection选项不兼容 。有关更多信息，请参见通配符索引的选项。 有关示例，请参见在单字段路径上创建通配符索引。 在所有字段上创建通配符索引 要索引文档中所有字段的值(不包括_id)，指定“$**”作为索引键: db.collection.createIndex( { \"$**\" : 1 } ) 使用这个通配符索引，MongoDB为集合中每个文档的所有字段建立索引。如果给定字段是嵌套的文档或数组，通配符索引将递归到文档/数组中，并存储文档/数组中所有字段的值。 有关示例，请参见在所有字段路径上创建通配符索引。 注意 _id默认情况下，通配符索引会忽略该字段。要将_id字段包括 在通配符索引中，必须在wildcardProjection文档中明确包含它。有关更多信息，请参见通配符索引的选项。 在多个特定字段上创建通配符索引 索引一个文档中多个特定字段的值: db.collection.createIndex( { \"$**\" : 1 }, { \"wildcardProjection\" : { \"fieldA\" : 1, \"fieldB.fieldC\" : 1 } } ) 使用这个通配符索引，MongoDB为集合中每个文档的指定字段的所有值建立索引。如果给定字段是嵌套的文档或数组，通配符索引将递归到文档/数组中，并存储文档/数组中所有字段的值。 注意 通配符索引不支持在wildcardProjection文档中混合包含和排除语句，除非明确包含该_id字段。有关详细信息 wildcardProjection，请参阅通配符索引选项。 有关示例，请参阅在通配符索引覆盖范围中包括特定字段。 创建排除多个特定字段的通配符索引 要为文档中除特定字段路径之外的所有字段的字段建立索引，请执行以下操作 ： db.collection.createIndex( { \"$**\" : 1 }, { \"wildcardProjection\" : { \"fieldA\" : 0, \"fieldB.fieldC\" : 0 } } ) 使用这个通配符索引，MongoDB为集合中每个文档的所有字段建立索引，不包括指定的字段路径。如果给定字段是嵌套的文档或数组，通配符索引将递归到文档/数组中，并存储文档/数组中所有字段的值。 有关示例，请参见从通配符索引覆盖率中忽略特定字段。 注意 通配符索引不支持在wildcardProjection文档中混合包含和排除语句，除非明确包含该_id字段。有关详细信息 wildcardProjection，请参阅通配符索引选项。 注意事项 通配符索引可以在任何给定查询谓词中最多支持一个字段。有关通配符索引查询支持的更多信息，请参见通配符索引查询/排序支持。 该featureCompatibilityVersion必须创建通配符索引。有关设置fCV的说明，请参阅 在MongoDB 4.4部署上设置功能兼容版本。mongod 4.2 通配符索引默认情况下省略_id字段。要在通配符索引中包含_id字段，必须显式地将其包含在wildcardProjection文档中(即{“_id”:1})。 您可以在一个集合中创建多个通配符索引。 通配符索引可能与集合中的其他索引覆盖相同的字段。 通配符索引是sparse索引，即使索引字段包含空值，也仅包含具有索引字段的文档的条目。 行为 通配符索引在索引对象(例如嵌入的文档)或数组字段时有特定的行为: 如果该字段是对象，则通配符索引会下降到该对象中并为其内容建立索引。通配符索引继续下降到它遇到的任何其他嵌入式文档中。 如果该字段是一个数组，则通配符索引将遍历该数组并索引每个元素： 如果数组中的元素是对象，则通配符索引会下降到该对象中以如上所述索引其内容。 如果该元素是一个数组--也就是说，其被直接嵌入父阵列内的阵列-然后通配符指数并 不能遍历嵌入式阵列，但索引的整个阵列作为一个单一的值。 对于所有其他字段，将原始（非对象/数组）值记录到索引中。 通配符索引将继续遍历任何其他嵌套对象或数组，直到达到原始值（即不是对象或数组的字段）为止。然后，它将索引此原始值以及该字段的完整路径。 例如，考虑以下文档： { \"parentField\" : { \"nestedField\" : \"nestedValue\", \"nestedObject\" : { \"deeplyNestedField\" : \"deeplyNestedValue\" }, \"nestedArray\" : [ \"nestedArrayElementOne\", [ \"nestedArrayElementTwo\" ] ] } } 包含parentField的通配符索引记录了以下条目: \"parentField.nestedField\" : \"nestedValue\" \"parentField.nestedObject.deeplyNestedField\" : \"deeplyNestedValue\" \"parentField.nestedArray\" : \"nestedArrayElementOne\" \"parentField.nestedArray\" : [\"nestedArrayElementTwo\"] 注意，记录parentField.nestedArray不包含每个元素的数组位置。当将元素记录到索引中时，通配符索引会忽略数组元素的位置。通配符索引仍然可以支持包含显式数组索引的查询。有关更多信息，请参见 具有显式数组索引的查询。 有关嵌套对象的通配符索引行为的更多信息，请参见嵌套对象。 有关嵌套数组的通配符索引行为的更多信息，请参见嵌套数组。 嵌套对象 当通配符索引遇到嵌套对象时，它下降到该对象并对其内容进行索引。例如: { \"parentField\" : { \"nestedField\" : \"nestedValue\", \"nestedArray\" : [\"nestedElement\"] \"nestedObject\" : { \"deeplyNestedField\" : \"deeplyNestedValue\" } } } 包含parentField的通配符索引向下遍历对象并索引其内容: 对于本身就是对象（即嵌入式文档）的每个字段，请进入该对象以为其内容编制索引。 对于每个是数组的字段，遍历该数组并为其内容建立索引。 对于所有其他字段，将原始（非对象/数组）值记录到索引中。 通配符索引继续遍历任何附加的嵌套对象或数组，直到它到达一个基本值(即一个不是对象或数组的字段)。然后，它为这个原始值以及该字段的完整路径建立索引。 给定样本文档，通配符索引将以下记录添加到索引中： \"parentField.nestedField\" : \"nestedValue\" \"parentField.nestedObject.deeplyNestedField\" : \"deeplyNestedValue\" \"parentField.nestedArray\" : \"nestedElement\" 有关嵌套数组的通配符索引行为的更多信息，请参见嵌套数组。 嵌套数组 当通配符索引遇到嵌套数组时，它尝试遍历该数组以索引其元素。如果数组本身是父数组(即嵌入式数组)中的一个元素，通配符索引会将整个数组记录为一个值，而不是遍历其内容。例如: { \"parentArray\" : [ \"arrayElementOne\", [ \"embeddedArrayElement\" ], \"nestedObject\" : { \"nestedArray\" : [ \"nestedArrayElementOne\", \"nestedArrayElementTwo\" ] } ] } 包含parentArray的通配符索引向下到数组中遍历和索引它的内容: 对于作为数组（即嵌入式数组）的每个元素，将整个数组索引为一个值。 对于作为对象的每个元素，请进入该对象以遍历并为其内容编制索引。 对于所有其他字段，将原始（非对象/数组）值记录到索引中。 通配符索引继续遍历任何附加的嵌套对象或数组，直到它到达一个基本值(即一个不是对象或数组的字段)。然后，它为这个原始值以及该字段的完整路径建立索引。 给定样本文档，通配符索引将以下记录添加到索引中： \"parentArray\" : \"arrayElementOne\" \"parentArray\" : [\"embeddedArrayElement\"] \"parentArray.nestedObject.nestedArray\" : \"nestedArrayElementOne\" \"parentArray.nestedObject.nestedArray\" : \"nestedArrayElementTwo\" 注意，记录parentField.nestedArray不包含每个元素的数组位置。当将元素记录到索引中时，通配符索引会忽略数组元素的位置。通配符索引仍然可以支持包含显式数组索引的查询。有关更多信息，请参见 具有显式数组索引的查询。 也可以看看：Nested Depth for BSON Documents 限制条件 您不能使用通配符索引来分片集合。在要分片的一个或多个字段上创建一个非通配符索引。有关分片键选择的更多信息，请参见分片 键。 您不能创建复合索引。 您不能为通配符索引指定以下属性： TTL Unique 您不能使用通配符语法创建以下索引类型： 2d（地理空间） 2dsphere（地理空间） Hashed 重要 通配符索引与通配符文本索引不同并且不兼容 。通配符索引不能支持使用$text运算符的查询。 有关通配符索引创建限制的完整文档，请参阅 不兼容的索引类型或属性。 通配符索引查询/排序支持 覆盖查询 仅当满足以下所有条件时，通配符索引才能支持覆盖的查询 ： 查询计划者选择通配符索引来满足查询谓词。 查询谓词恰好指定了通配符索引覆盖的一个字段。 该投影显式排除_id并仅包括查询字段。 指定的查询字段永远不会是数组。 考虑employees集合上的以下通配符索引： db.products.createIndex( { \"$**\" : 1 } ) 下面的操作查询单个字段的姓，并从结果文档中抽取所有其他字段: db.products.find( { \"lastName\" : \"Doe\" }, { \"_id\" : 0, \"lastName\" : 1 } ) 假设指定的lastName对象永远不是数组，MongoDB可以使用$**通配符索引来支持覆盖查询。 包含多个字段的查询谓词 通配符索引最多可以支持一个查询谓词字段。那是： MongoDB无法使用非通配符索引来满足查询谓词的一部分，而不能使用通配符索引来满足另一部分。 MongoDB无法使用一个通配符索引来满足查询谓词的一部分，而使用另一个通配符索引来满足另一部分。 即使单个通配符索引可以支持多个查询字段，MongoDB也可以使用通配符索引来仅支持其中一个查询字段。解析所有其余字段而没有索引。 但是，MongoDB可以使用相同的通配符索引来满足查询$or或聚合 $or运算符的每个独立参数。 查询和排序 MongoDB可以使用通配符索引来满足sort()，只有当所有这些都是真的: 查询计划者选择通配符索引来满足查询谓词。 该sort()指定唯一的查询谓词场。 指定的字段永远不会是数组。 如果不满足上述条件，则MongoDB无法使用通配符索引进行排序。MongoDB不支持sort 需要与查询谓词不同的索引的操作。有关更多信息，请参见索引交集和排序。 考虑以下products集合上的通配符索引: db.products.createIndex( { \"product_attributes.$**\" : 1 } ) 下面的操作查询单个字段product_attributes.price和种类在同一领域: db.products.find( { \"product_attributes.price\" : { $gt : 10.00 } }, ).sort( { \"product_attributes.price\" : 1 } ) 假设指定的price对象永远不是数组，MongoDB可以使用product_attributes.$**通配符索引来满足find()和sort()。 不支持的查询模式 通配符索引不支持查询条件，该条件检查字段是否不存在。 通配符索引不支持查询条件，该条件检查字段是否等于文档或数组 通配符索引不能支持检查字段是否不等于null的查询条件。 有关详细信息，请参阅不支持的查询和聚合模式。 用明确的数组索引查询 MongoDB通配符索引不会在索引期间记录数组中任何给定元素的数组位置。但是，MongoDB仍然可以选择通配符索引来回答包含具有一个或多个显式数组索引（例如，parentArray.0.nestedArray.0）的字段路径的查询 。由于为每个连续的嵌套数组定义索引范围的复杂性越来越高，因此，如果该路径包含的8显式数组索引不多，MongoDB不会考虑使用通配符索引来回答查询中的给定字段路径。MongoDB仍然可以考虑使用通配符索引来回答查询中的其他字段路径。 例如： { \"parentObject\" : { \"nestedArray\" : [ \"elementOne\", { \"deeplyNestedArray\" : [ \"elementTwo\" ] } ] } } MongoDB可以选择一个通配符索引，其中包括parentObject，以满足以下查询: \"parentObject.nestedArray.0\" : \"elementOne\" \"parentObject.nestedArray.1.deeplyNestedArray.0\" : \"elementTwo\" 如果查询谓词中的给定字段路径指定了8个以上的显式数组索引，则MongoDB不会考虑使用通配符索引来回答该字段路径。相反，MongoDB要么选择另一个符合条件的索引来回答查询，要么执行集合扫描。 请注意，通配符索引本身对索引时遍历文档的深度没有任何限制；该限制仅适用于明确指定确切数组索引的查询。通过发出没有显式数组索引的相同查询，MongoDB可以选择通配符索引来回答该查询： \"parentObject.nestedArray\" : \"elementOne\" \"parentObject.nestedArray.deeplyNestedArray\" : \"elementTwo\" 也可以看看 Nested Depth for BSON Documents Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/Wildcard-Indexes/Wildcard-Index-Restrictions.html":{"url":"docs/Indexes/Wildcard-Indexes/Wildcard-Index-Restrictions.html","title":"Wildcard Index Restrictions","keywords":"","body":"通配符索引限制 在本页面 不兼容的索引类型或属性 不支持的查询和聚合模式 分片 不兼容的索引类型或属性 通配符索引不支持以下索引类型或属性： 复合 TTL 文本 2d（地理空间） 2dsphere（地理空间） Hashed Unique 注意 通配符索引与通配符文本索引不同，也不兼容。通配符索引不支持使用$text操作符的查询。 不支持的查询和聚合模式 字段不存在 通配符索引是sparse的，不索引空字段。因此通配符索引不支持查询字段不存在的文档。 例如，考虑一个在product_attributes上具有通配符索引的集合目录。通配符索引不能支持以下查询: db.inventory.find( {\"product_attributes\" : { $exists : false } } ) db.inventory.aggregate([ { $match : { \"product_attributes\" : { $exists : false } } } ]) 字段等于文档或数组 通配符索引为文档或数组的内容生成条目，而不是文档/数组本身。因此通配符索引不能支持精确的文档/数组相等匹配。通配符索引可以支持查询字段等于空文档{}的位置。 例如，考虑一个在 product_attributes 上具有通配符索引的集合目录。通配符索引不能支持以下查询: db.inventory.find({ \"product_attributes\" : { \"price\" : 29.99 } } ) db.inventory.find({ \"product_attributes.tags\" : [ \"waterproof\", \"fireproof\" ] } ) db.inventory.aggregate([{ $match : { \"product_attributes\" : { \"price\" : 29.99 } } }]) db.inventory.aggregate([{ $match : { \"product_attributes.tags\" : [\"waterproof\", \"fireproof\" ] } } }]) 字段不等于文档或数组 通配符索引为文档或数组的内容生成条目，而不是文档/数组本身。因此通配符索引不能支持精确的文档/数组不等匹配。 例如，考虑一个在product_attributes上具有通配符索引的集合目录。通配符索引不能支持以下查询: db.inventory.find( { $ne : [ \"product_attributes\", { \"price\" : 29.99 } ] } ) db.inventory.find( { $ne : [ \"product_attributes.tags\", [ \"waterproof\", \"fireproof\" ] ] } ) db.inventory.aggregate([{ $match : { $ne : [ \"product_attributes\", { \"price\" : 29.99 } ] } }]) db.inventory.aggregate([{ $match : { $ne : [ \"product_attributes.tags\", [ \"waterproof\", \"fireproof\" ] ] } }]) 字段不等于null 如果给定字段是集合中任何文档中的数组，通配符索引不能支持查询该字段不等于null的文档。 例如，考虑一个在product_attributes上具有通配符索引的集合目录。如果product_attributes通配符索引不能支持以下查询。标签是集合中任意文档的数组: db.inventory.find( { $ne : [ \"product_attributes.tags\", null ] } ) db.inventory.aggregate([{ $match : { $ne : [ \"product_attributes.tags\", null ] } }]) 分片 您不能使用通配符索引来分片集合。在要分片的一个或多个字段上创建一个非通配符索引。有关分片键选择的更多信息，请参见分片 键。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/2dsphere-Indexes.html":{"url":"docs/Indexes/2dsphere-Indexes.html","title":"2dsphere Indexes","keywords":"","body":"2dsphere索引 在本页面 概述 版本号 注意事项 创建2dsphere索引概述 2dsphere索引支持计算类似地球的球体上的几何形状的查询。2dsphere索引支持所有MongoDB地理空间查询：包含、相交和邻近度查询。 有关地理空间查询的更多信息，请参见地理空间查询。 2dsphere索引支持存储为GeoJSON对象和旧版坐标对的数据(另请参阅2dsphere索引字段限制)。对于遗留坐标对，索引将数据转换为GeoJSONPoint。 版本号 2dsphere索引版本 描述 版本3 MongoDB 3.2引入了一个版本3的2dsphere索引。版本3是在MongoDB 3.2和更高版本中创建的2dsphere索引的默认版本。 版本2 MongoDB 2.6引入了2dsphere索引的版本2。版本2是在MongoDB 2.6和3.0系列中创建的2dsphere索引的默认版本。 要覆盖默认版本并指定其他版本，请在创建索引时包含选项{“ 2dsphereIndexVersion”：}。 sparse属性 版本2和更高版本的2dsphere索引始终为sparse且忽略sparse选项。如果文档缺少2dsphere索引所在字段（或者该字段为null或空数组），则MongoDB不会将文档条目添加到索引中。对于插入，MongoDB会插入文档，但不添加到2dsphere索引。对于包含2dsphere索引键以及其他类型键的复合索引，该索引是否引用文档只取决于2dsphere索引字段。 对于包含2dsphere索引键和其他类型的键的复合索引，只有2dsphere索引字段确定索引是否引用文档。 MongoDB的早期版本仅支持2dsphere (Version 1)索引。 默认情况下，2dsphere (Version 1)索引不是sparse索引，并且拒绝该字段为空的文档。 其他GeoJSON对象 版本2和更高版本的2dsphere索引包含对其他GeoJSON对象的支持：MultiPoint，MultiLineString，MultiPolygon和GeometryCollection。有关所有受支持的GeoJSON对象的详细信息，请参见GeoJSON对象。 注意事项 geoNear和$geoNear的限制 从MongoDB 4.0开始，您可以为$geoNear管道指定一个key选项以明确指示要使用的索引字段路径。这使得$geoNear在具有多个2dsphere索引或多个2d索引的文档中也能被使用： 如果您的集合具有多个2dsphere索引或多个2d索引，则必须使用key选项来指定使用哪个索引字段路径。 如果未指定key，您将无法使用多个2dsphere索引或多个2d索引。 因为没有指定key时，在多个2d索引或2dsphere索引中选择索引将变得无法明确。 注意 如果您不指定key，您将最多只能拥有一个2dsphere索引或一个2dsphere索引，MongoDB首先寻找2d索引。 如果不存在2d索引，则MongoDB会寻找2dsphere索引。 分片键限制 对集合做分片时，不能将2dsphere索引用作分片键。 但是，您可以通过使用一个不同的字段作为分片键来在分片集合上创建地理空间索引。 2dsphere索引字段限制 具有2dsphere索引的字段必须包含坐标对或GeoJSON形式的数据。如果您尝试插入一个在2dsphere索引字段中包含非几何数据的文档，或者在一个索引字段中包含非几何数据的集合上构建2dsphere索引，该操作将失败。 创建2dsphere索引 要创建2dsphere索引，请使用db.collection.createIndex() 方法并指定字符串\"2dsphere\"作为索引类型： db.collection.createIndex( { : \"2dsphere\" } ) 其中的是其值为GeoJSON对象或旧式坐标对的字段。 与只能引用一个位置字段和另一个字段的复合2d索引不同的是，复合2dsphere索引可以引用多个位置字段及非位置字段。 以下示例，基于一个places集合，该集合的文档将位置数据以GeoJSON Point形式存储在loc字段中： db.places.insert( { loc : { type: \"Point\", coordinates: [ -73.97, 40.77 ] }, name: \"Central Park\", category : \"Parks\" } ) db.places.insert( { loc : { type: \"Point\", coordinates: [ -73.88, 40.78 ] }, name: \"La Guardia Airport\", category : \"Airport\" } ) 创建2dsphere索引 以下操作在位置字段loc上创建一个2dsphere索引： db.places.createIndex( { loc : \"2dsphere\" } ) 使用2dsphere索引键创建复合索引 复合索引可以包含2dsphere索引键和非地理空间索引键。例如，以下操作将创建一个复合索引，其中第一个键loc是2dsphere索引键，其余键category和names是非地理空间索引键，并分别指定降序（-1）和升序（1）。 db.places.createIndex( { loc : \"2dsphere\" , category : -1, name: 1 } ) 与2d索引不同，复合2dsphere索引不需要将位置字段作为第一个索引字段。 例如： db.places.createIndex( { category : 1 , loc : \"2dsphere\" } ) Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/2dsphere-Indexes/Query-a-2dsphere-Index.html":{"url":"docs/Indexes/2dsphere-Indexes/Query-a-2dsphere-Index.html","title":"Query a 2dsphere Index","keywords":"","body":"查询一个2dsphere索引 在本页面 多边形绑定的GeoJSON对象 GeoJSON对象的交集 接近GeoJSON点 球体上定义的圆内的点 以下各节描述了2dsphere索引支持的查询。 多边形绑定的GeoJSON对象 该$geoWithin操作符查询在GeoJSON多边形中找到的位置数据。您的位置数据必须以GeoJSON格式存储。使用以下语法: db..find( { : { $geoWithin : { $geometry : { type : \"Polygon\" , coordinates : [ ] } } } } ) 下面的例子选择了全部存在于GeoJSON多边形中的所有点和形状: db.places.find( { loc : { $geoWithin : { $geometry : { type : \"Polygon\" , coordinates : [ [ [ 0 , 0 ] , [ 3 , 6 ] , [ 6 , 1 ] , [ 0 , 0 ] ] ] } } } } ) GeoJSON对象的交集 该$geoIntersects操作符查询与指定GeoJSON对象相交的位置。如果交点非空，则该位置与该对象相交。这包括具有共享优势的文档。 该$geoIntersects操作符使用以下语法: db..find( { : { $geoIntersects : { $geometry : { type : \"\" , coordinates : [ ] } } } } ) 下面的示例使用$geoIntersects选择与coordinates数组定义的多边形相交的所有索引点和形状。 db.places.find( { loc : { $geoIntersects : { $geometry : { type : \"Polygon\" , coordinates: [ [ [ 0 , 0 ] , [ 3 , 6 ] , [ 6 , 1 ] , [ 0 , 0 ] ] ] } } } } ) 接近GeoJSON点 接近查询返回最接近定义点的点，并按距离对结果进行排序。对GeoJSON数据的接近度查询需要一个2dsphere索引。 要查询与GeoJSON点的接近程度，请使用任一 $near运算符。距离以米为单位。 该$near使用的语法如下： db..find( { : { $near : { $geometry : { type : \"Point\" , coordinates : [ , ] } , $maxDistance : } } } ) 有关示例，请参见$near。 参见$nearSphere操作符和:pipeline:$geoNear聚合管道阶段。 球体上定义的圆内的点 要在球体的“球冠”中选择所有网格坐标，请$geoWithin与$centerSphere运算符一起使用 。指定一个包含以下内容的数组： 圆心的网格坐标 圆的半径，以弧度为单位。要计算弧度，请参见 使用球面几何计算距离。 使用以下语法： db..find( { : { $geoWithin : { $centerSphere : [ [ , ] , ] } } } ) 下面的示例查询网格坐标并返回所有半径为经度 88 W 和纬度 30 N 的10英里内的文档。示例将10英里的距离转换为弧度，通过除以地球近似的赤道半径3963.2英里: db.places.find( { loc : { $geoWithin : { $centerSphere : [ [ -88 , 30 ] , 10 / 3963.2 ] } } } ) Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/2d-Indexes.html":{"url":"docs/Indexes/2d-Indexes.html","title":"2d Indexes","keywords":"","body":"2d索引 在本页面 注意事项 行为 sparse 属性 归类选项 2d对在二维平面上存储为点的数据使用索引。该2d索引适用于MongoDB 2.2及更早版本中使用的旧式坐标对。 在以下情况下使用2d索引： 您的数据库具有来自MongoDB 2.2或更早版本的旧版旧版坐标对，并且 您不打算将任何位置数据存储为GeoJSON对象。 有关地理空间查询的更多信息，请参见 地理空间查询。 注意事项 从MongoDB 4.0开始，您可以key在$geoNear管道阶段指定一个选项 以指示要使用的索引字段路径。这允许将该$geoNear阶段用在具有多个2d索引和/或多个 2dsphere索引的集合上： 如果您的集合具有多个2d索引和/或多个 2dsphere索引，则必须使用该key选项来指定要使用的索引字段路径。 如果不指定key，则不能有多个 2d索引和/或多个2dsphere索引，因为如果没有使用key，则多个2d索引或 2dsphere索引之间的索引选择是不明确的。 注意 如果未指定key，并且最多只有一个 2d索引索引和/或只有一个2d索引索引，则MongoDB首先会寻找2d要使用的索引。如果2d索引不存在，则MongoDB查找2dsphere要使用的索引。 2d如果您的位置数据包含GeoJSON对象，请不要使用索引。要同时在旧式坐标对 和 GeoJSON对象上建立索引，请使用2dsphere索引。 分片集合时，不能将2d索引用作分片键。但是，可以通过使用其他字段作为分片键在分片集合上创建地理空间索引。 行为 该2d索引支持在平坦的欧几里德平面上进行的计算。该2d索引还支持球体（例如） 上的仅距离计算$nearSphere，但是对于 球体（例如）上的几何计算$geoWithin，请将数据存储为GeoJSON对象并使用 2dsphere索引。 甲2d索引可以参考两个字段。第一个必须是位置字段。阿2d化合物索引构造该第一选择的位置字段的查询，然后过滤由附加标准的那些结果。复合2d索引可以涵盖查询。 sparse属性 2d索引总是稀疏的，并且忽略稀疏选项。如果文档缺少2d索引字段（或者该字段是null或为空数组），则MongoDB不会将文档条目添加到 2d索引中。对于插入，MongoDB会插入文档，但不会添加到2d索引中。 对于包含2d索引键和其他类型的键的复合索引，只有2d索引字段才能确定索引是否引用文档。 排序规则选项 2d索引仅支持简单的二进制比较，不支持排序规则选项。 要2d在具有非简单排序规则的集合上创建索引，必须在创建索引时明确指定。{collation: {locale: \"simple\"} } Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/2d-Indexes/Create-a-2d-Index.html":{"url":"docs/Indexes/2d-Indexes/Create-a-2d-Index.html","title":"Create a 2d Index","keywords":"","body":"创建一个2d索引 在本页面 定义2d索引的位置范围 定义2d索引的位置精度 要构建一个地理空间的 2d 索引，使用db.collection.createIndex()方法并指定 2d 。使用以下语法: db..createIndex( { : \"2d\" , : } , { } ) 2d 索引使用以下可选的索引规范选项: { min : , max : , bits : } 定义2d索引的位置范围 默认情况下， 2d 索引假定经度和纬度，边界为[-180 , 180)。如果文档包含的坐标数据超出了指定的范围，MongoDB将返回一个错误。 重要 默认边界允许应用程序插入纬度大于90或小于-90的无效文档。对于这些无效点的地理空间查询行为没有定义。 在 2d 索引上，你可以改变位置范围。 您可以创建一个 2d 地理空间索引，其中包含默认位置范围之外的位置范围。在创建索引时使用' min '和' max '选项。使用以下语法: db.collection.createIndex( { : \"2d\" } , { min : , max : } ) 定义“2d”索引的位置精度 默认情况下，传统坐标对的“2d”索引使用26位精度，使用默认的-180到180的范围，相当于2英尺或60厘米的精度。精度由用于存储位置数据的geohash值的位大小来度量。您可以配置精度最高为32位的地理空间索引。 索引精度不影响查询精度。实际的网格坐标总是在最终的查询处理中使用。降低精度的优点是插入操作的处理开销更低，占用的空间更少。更高精度的一个优点是查询扫描索引的较小部分以返回结果。 若要配置默认位置以外的位置精度，请在创建索引时使用 bits 选项。使用下面的语法: db..createIndex( { : \"\"} , { bits : } ) 有关geohash值的内部信息，请参见计算2d索引的geohash值。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/2d-Indexes/Query-a-2d-Index.html":{"url":"docs/Indexes/2d-Indexes/Query-a-2d-Index.html","title":"Query a 2d Index","keywords":"","body":"查询一个“2d”索引 在本页面 在平面上定义的形状内的点 球体上定义的圆内的点 接近平面上的一点 在平面上精确匹配 下面的部分描述了 2d 索引支持的查询。 在平面上定义的形状内的点 要选择平面上给定形状中的所有旧坐标对，请使用$geoWithin操作符和一个形状操作符。使用以下语法: db..find( { : { $geoWithin : { $box|$polygon|$center : } } } ) 下面查询由左下角的[0,0]和右上角的[100,100]定义的矩形内的文档。 db.places.find( { loc : { $geoWithin : { $box : [ [ 0 , 0 ] , [ 100 , 100 ] ] } } } ) 下面查询以[-74,40.74]为圆心，半径为10的圆内的文档: db.places.find( { loc: { $geoWithin : { $center : [ [-74, 40.74 ] , 10 ] } } } ) 关于每种形状的语法和示例，请看下面: $box $polygon $center (defines a circle) 球体上定义的圆内的点 由于遗留的原因，MongoDB支持平面“2d”索引上的基本球形查询。通常，球形计算应该使用2dsphere索引，如2dsphere索引中所述。 要在球体的“球冠”中查询传统坐标对，请$geoWithin与$centerSphere运算符一起使用。指定一个包含以下内容的数组： 圆心的网格坐标 圆的半径，以弧度为单位。要计算弧度，请参见 使用球面几何计算距离。 使用以下语法: db..find( { : { $geoWithin : { $centerSphere : [ [ , ] , ] } } } ) 下面的示例查询返回以经度 88 W 和纬度 30 N 为半径的10英里范围内的所有文档。这个例子通过将距离除以地球赤道半径3963.2英里来将距离转换为弧度: db..find( { loc : { $geoWithin : { $centerSphere : [ [ 88 , 30 ] , 10 / 3963.2 ] } } } ) 接近平面上的一点 接近查询返回最接近定义点的遗留坐标对，并按距离对结果排序。使用$near操作符。操作符需要一个 2d 索引。 $near操作符使用以下语法: db..find( { : { $near : [ , ] } } ) 例如，请参见$near。 在平面上的精确匹配 不能使用2d索引返回坐标对的精确匹配。在存储坐标的字段上使用升序或降序标量索引，以返回准确的匹配。 在下面的例子中，find()操作将返回一个精确匹配的位置，如果你有一个{'loc': 1}索引: db..find( { loc: [ , ] } ) 该查询将返回值为[， ]的所有文档。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/2d-Indexes/2d-Index-Internals.html":{"url":"docs/Indexes/2d-Indexes/2d-Index-Internals.html","title":"2d Index Internals","keywords":"","body":"2d索引内部 在本页面 2d索引的Geohash值的计算 2d索引的多位置文档 本文对MongoDB的 2d 地理空间索引的内部原理进行了更深入的解释。本材料不是正常操作或应用程序开发所必需的，但对于故障排除和进一步理解可能很有用。 2d索引的Geohash值的计算 当你创建一个地理空间索引遗留坐标对,MongoDB计算地理散列的坐标对在指定位置范围和geohash值然后索引。 要计算geohash值，可以递归地将二维映射划分为象限。然后为每个象限分配一个两比特的值。例如，四个象限的两位表示为: 01 11 00 10 这些两位值(00，01，10，和11)表示每个象限和每个象限内的所有点。对于具有两位分辨率的geohash，位于左下象限的所有点的geohash值都为 00 。左上角象限的geohash值为 01 。右下角和右上角的geohash值分别为 10 和 11 。 为了提供额外的精度，继续将每个象限划分为子象限。每个子象限都将包含象限的geohash值与子象限的值连接起来。右上象限的geohash为 11 ，子象限的geohash分别为(从左上方向顺时针方向): 1101 、 1111 、 1110 和 1100 。 用于“2d”索引的多位置文档 注意 索引可以覆盖文档中的多个地理空间字段，并且可以使用MultiPoint嵌入式文档表示点列表。 虽然 2d 地理空间索引在文档中不支持多个地理空间字段，但您可以使用多键索引在单个文档中索引多个坐标对。在最简单的例子中，你可能有一个字段。(例如:locs)，它包含一个坐标数组，如下例所示: db.places.save( { locs : [ [ 55.5 , 42.3 ] , [ -74 , 44.74 ] , { lng : 55.5 , lat : 42.3 } ] } ) 数组的值可以是数组(如[55.5,42.3])，也可以是嵌入文档(如{lng: 55.5, lat: 42.3})。 然后可以在 locs 字段上创建地理空间索引，如下所示: db.places.createIndex( { \"locs\": \"2d\" } ) 您还可以将位置数据建模为嵌入文档中的一个字段。在这种情况下，文档将包含一个字段(例如。' address ')，它包含一个文档数组，其中每个文档都有一个字段(例如。' loc: ')保存位置坐标。例如: db.records.save( { name : \"John Smith\", addresses : [ { context : \"home\" , loc : [ 55.5, 42.3 ] } , { context : \"work\", loc : [ -74 , 44.74 ] } ] } ) 然后可以在 addresses 上创建地理空间索引。字段如下例所示: db.records.createIndex( { \"addresses.loc\": \"2d\" } ) Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/2d-Indexes/Calculate-Distance-Using-Spherical-Geometry.html":{"url":"docs/Indexes/2d-Indexes/Calculate-Distance-Using-Spherical-Geometry.html","title":"Calculate Distance Using Spherical Geometry","keywords":"","body":"使用球面几何计算距离 警告 对于球形查询，使用' 2dsphere '索引结果。 对球形查询使用“2d”索引可能会导致不正确的结果，例如对环绕极点的球形查询使用“2d”索引。 2d索引支持在欧几里得平面(平面)上计算距离的查询。索引还支持以下查询操作符和命令，计算距离使用球面几何: 注意 虽然“2d”索引支持使用球面距离的基本查询，但如果您的数据主要是经度和纬度，请考虑移动到“2dsphere”索引。 $nearSphere $centerSphere $near $geoNear带有选择的流水线级spherical: true 重要 上述操作使用弧度表示距离。其他球形查询操作符则不是这样，比如' $geoWithin '。 要使球形查询运算符正常运行，必须将距离转换为弧度，并将弧度转换为应用程序使用的距离单位。 转换: 到弧度的距离：用与距离测量相同的单位将距离除以球体（例如地球）的半径。 弧度到距离：将弧度乘以要转换距离的单位制中球体（例如地球）的半径。 地球的赤道半径大约为3,963.2英里或6,378.1公里。 以下查询将从places集合中返回半径为“100”英里的圆心“[-74,40.74]”所描述的圆内的文档: db.places.find( { loc: { $geoWithin: { $centerSphere: [ [ -74, 40.74 ] , 100 / 3963.2 ] } } } ) 注意 如果指定纬度和经度坐标，请先列出经度，再列出纬度: 有效经度值在‘-180’和‘180’之间，包括两者。 有效纬度值在' -90 '和' 90 '之间，两者都包括。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/geoHaystack-Indexes.html":{"url":"docs/Indexes/geoHaystack-Indexes.html","title":"geoHaystack Indexes","keywords":"","body":"geoHaystack索引 在本页面 行为 sparse 属性 创建geoHaystack索引 “geoHaystack”索引是一种特殊的索引，优化后可以在小范围内返回结果。“geoHaystack”索引提高了使用平面几何图形查询的性能。 对于使用球形几何的查询，2dsphere索引比haystack索引更好。2dsphere索引允许字段重新排序；geoHaystack索引要求第一个字段为位置字段。另外，geoHaystack 索引只能通过命令使用，因此总是一次返回所有结果。 行为 geoHaystack索引从同一地理区域创建文档的“存储桶”，以提高限于该区域的查询的性能。geoHaystack索引中的每个存储段都包含在给定经度和纬度指定邻近范围内的所有文档。 sparse属性 geoHaystack索引默认为sparse，忽略sparse: true选项。如果一个文档缺少一个geoHaystack索引字段(或者该字段是“null”或空数组)，MongoDB不会为该文档添加一个条目到geoHaystack索引中。对于插入，MongoDB插入文档，但不添加到geoHaystack索引。 geoHaystack索引包括一个geoHaystack索引键和一个非地理空间索引键;但是，只有geoHaystack索引字段决定索引是否引用文档。 排序选项 geoHaystack索引只支持简单的二进制比较，不支持collation。 要在具有非简单排序规则的集合上创建geoHaystack索引，必须在创建索引时显式指定{collation: {locale: \"simple\"}}。 创建geoHaystack索引 要创建geoHaystack索引，请参见创建Haystack索引。有关查询haystack索引的信息和示例，请参见查询haystack索引。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/geoHaystack-Indexes/Create-a-Haystack-Index.html":{"url":"docs/Indexes/geoHaystack-Indexes/Create-a-Haystack-Index.html","title":"Create a Haystack Index","keywords":"","body":"创建Haystack索引 弃用 MongoDB 4.4不支持geoHaystack索引和地理搜索命令。使用$geoNear或$geoWithin 的2d索引。 haystack索引必须引用两个字段:位置字段和第二个字段。第二个字段用于精确匹配。Haystack索引基于位置和对单个附加条件的精确匹配返回文档。这些索引不一定适合于将最近的文档返回到特定位置。 要构建一个haystack索引，请使用以下语法: db.coll.createIndex( { : \"geoHaystack\" , : 1 } , { bucketSize : } ) 要构建haystack索引，必须在创建索引时指定' bucketSize '选项。' bucketSize '为' 5 '创建一个索引，该索引将指定经度和纬度的5个单位内的位置值分组。“bucketSize”还决定了索引的粒度。您可以根据数据的分布调整参数，以便通常只搜索很小的区域。bucket定义的区域可以重叠。文档可以存在于多个桶中。 例子 如果您有一个包含类似以下字段的文档集合: { _id : 100, pos: { lng : 126.9, lat : 35.2 } , type : \"restaurant\"} { _id : 200, pos: { lng : 127.5, lat : 36.1 } , type : \"restaurant\"} { _id : 300, pos: { lng : 128.0, lat : 36.7 } , type : \"national park\"} 下面的操作创建了一个带有bucket的haystack索引，该bucket将键存储在一个经度或纬度单位内。 db.places.createIndex( { pos : \"geoHaystack\", type : 1 } , { bucketSize : 1 } ) 这个索引将值为200的“_id”字段存储在两个不同的存储桶中: 在包含“_id”字段值为“100”的文档的bucket中 在包含“_id”字段值为“300”的文档的bucket中 要使用haystack索引进行查询，可以使用 geoSearch 命令。参见查询Haystack索引. 默认情况下，使用haystack索引的查询返回50个文档。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/geoHaystack-Indexes/Query-a-Haystack-Index.html":{"url":"docs/Indexes/geoHaystack-Indexes/Query-a-Haystack-Index.html","title":"Query a Haystack Index","keywords":"","body":"查询Haystack索引 弃用 MongoDB 4.4不支持geoHaystack索引和 geoSearch 命令。使用2d索引或 $geoWithin 代替。 Haystack索引是一种特殊的2d地理空间索引，优化后可以在小区域内返回结果。要创建一个haystack索引，请参见创建一个haystack索引。 要查询一个haystack索引，使用 geoSearch 命令。您必须为geoSearch指定坐标和附加字段。例如，要返回示例点附近的type字段中值为restaurant的所有文档，命令如下: db.runCommand( { geoSearch : \"places\" , search : { type: \"restaurant\" } , near : [-74, 40.74] , maxDistance : 10 } ) 注意 Haystack索引不适合查询最接近特定位置的完整文档列表。与存储桶大小相比，最近的文档可能更远。 请注意 haystack索引目前不支持球形查询操作。 find()方法不能访问haystack索引。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/Hashed-Indexes.html":{"url":"docs/Indexes/Hashed-Indexes.html","title":"Hashed Indexes","keywords":"","body":"Hashed 索引 在本页面 Hashing 函数 创建Hashed索引 注意事项 Hashed索引使用索引字段值的hashes来维护条目。 Hashed索引支持使用hashes的分片键进行分片。基于Hashed的分片使用字段的散列索引作为分片键，以便跨分片集群对数据进行分区。 使用hashed的分片键对集合进行分片会导致数据分布更加随机。有关更多详细信息，请参见Hashed分片。 Hashing 函数 Hashed索引使用hashing函数来计算索引字段值的哈希。hashing函数折叠嵌入式文档并计算整个值的hash，但不支持多键（即数组）索引。 提示： MongoDB在解析使用已排序索引的查询时自动计算hashed值。应用程序不需要计算hashes。 创建Hashed索引 要创建hashed索引，请指定 hashed 作为索引键的值，如下例所示: db.collection.createIndex( { _id: \"hashed\" } ) 注意事项 MongoDB支持任何单个字段的 hashed 索引。hashing函数折叠嵌入的文档并计算整个值的hash值，但不支持多键(即.数组)索引。 您不能创建具有hashed索引字段的复合索引，也不能在索引上指定唯一约束hashed；但是，您可以hashed在同一字段上创建索引和升序/降序（即非哈希）索引：MongoDB将对范围查询使用标量索引。 253 限制 注意 MongoDB hashed索引在散列之前将浮点数截断为64位整数。例如，hashed指数将存储用于持有的值的字段的值相同2.3，2.2和2.9。为避免冲突，请不要hashed对无法可靠转换为64位整数（然后再返回到浮点数）的浮点数使用索引。MongoDB hashed索引不支持大于253的浮点值。 要查看键的hashed值是多少，请参阅convertShardKeyToHashed()。 查看键对应的hashed请查看convertShardKeyToHashed()。 PowerPC 和263 对于hashed索引，MongoDB 4.2确保PowerPC上浮点值263的hashed值与其他平台一致。 尽管不支持字段上可能包含大于253的浮点值的hashed索引，但客户端仍然可以在索引字段值为263的地方插入文档。 db.adminCommand(\"listDatabases\").databases.forEach(function(d){ let mdb = db.getSiblingDB(d.name); mdb.getCollectionInfos({ type: \"collection\" }).forEach(function(c){ let currentCollection = mdb.getCollection(c.name); currentCollection.getIndexes().forEach(function(idx){ let idxValues = Object.values(Object.assign({}, idx.key)); if (idxValues.includes(\"hashed\")) { print(\"Hashed index: \" + idx.name + \" on \" + idx.ns); printjson(idx); }; }); }); }); 要检查索引字段是否包含值263，对集合和索引字段执行以下操作: 如果一个collection中的索引字段数据内容仅是数值，不存在任何文档： ```powershell // substitute the actual collection name for // substitute the actual indexed field name for db..find( { : Math.pow(2,63) } ); - 如果一个collection中的索引字段是文档(或者数值)，可以执行： ```powershell // substitute the actual collection name for // substitute the actual indexed field name for db..find({ $where: function() { function findVal(obj, val) { if (obj === val) return true; for (const child in obj) { if (findVal(obj[child], val)) { return true; } } return false; } return findVal(this., Math.pow(2, 63)); } }) Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/Index-Properties.html":{"url":"docs/Indexes/Index-Properties.html","title":"Index Properties","keywords":"","body":"索引特性 索引的unique特性 开启unique选项，索引对应字段具有唯一性，对应字段拒绝重复值。除唯一性约束外，在功能上，索引的unique特性可与其他特性交替使用。 索引的Partial特性 3.2版本新特性 特性相关选项设置后，将仅索引集合中满足指定筛选表达式的文档。对集合中的文档子集创建索引，设置了partial特性的索引将占用更低的存储，并降低mongodb创建索引和维护索引的性能开销。 在功能上，索引的Partial特性是sparse特性的超集，当一个索引同时拥有两种特性时，以Partial特性优先。 索引的Sparse特性 索引的 sparse 特性确保只对存在索引字段的文档创建索引。创建索引时将会跳过那些没有对应字段值的文档。 你或许可以将sparse选项和unique选项结合使用，以防止索引字段插入重复值，并对对应索引字段缺失的文档不创建索引，提升数据库效率。 索引的TTL特性 索引的TTL特性，允许MongoDB在一定时间后自动从集合中移除文档。这非常适合某些类型的信息，例如：机器生成的事件数据、日志和会话信息，这些信息只需要在数据库中保留有限的时间。 有关实现说明，请参见：Expire Data from Collections by Setting TTL Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/Index-Properties/TTL-Indexes.html":{"url":"docs/Indexes/Index-Properties/TTL-Indexes.html","title":"TTL Indexes","keywords":"","body":"TTL索引 在本页面 行为 限制 请注意 如果您要删除文档以节省存储成本，考虑MongoDB Atlas中的Online Archive。在线归档自动将不经常访问的数据归档到完全托管的S3 bucket，从而实现经济有效的数据分层。 TTL索引是一种特殊的单字段索引，MongoDB可以使用它在一定的时间或特定的时钟时间后自动从集合中删除文档。数据过期对于某些类型的信息很有用，比如机器生成的事件数据、日志和会话信息，这些信息只需要在数据库中保存有限的时间。 要创建一个TTL索引,使用db.collection.createIndex ()方法expireAfterSeconds选项字段的值是一个日期或一个数组,其中包含日期值. 例如，要在eventlog集合的lastModifiedDate字段上创建一个TTL索引，在mongo shell中使用以下操作: db.eventlog.createIndex( { \"lastModifiedDate\": 1 }, { expireAfterSeconds: 3600 } ) 行为 过期的数据 TTL索引会在指定的秒数之后使文档过期；即:过期阈值是索引字段值加上指定的秒数。 如果字段是一个数组，并且索引中有多个日期值，MongoDB使用数组中的最低(即最早)日期值来计算过期阈值。 如果文档中的索引字段不是date或包含日期值的数组，文档将不会过期。 如果文档不包含索引字段，则文档将不会过期。 删除操作 在后台线程中的mongod读取索引中的值并从集合中删除过期的document。 当TTL线程处于活动状态时，您将db.currentOp()在数据库概要分析器的输出或数据中看到删除操作。 删除操作的时间 一旦索引在主数据库上构建完成，MongoDB就开始删除过期的文档。有关索引构建过程的更多信息，请参见填充集合上的索引构建。 TTL索引不能保证过期数据在过期时立即删除。在文档过期和MongoDB从数据库中删除文档之间可能存在延迟。 删除过期文档的后台任务每60秒运行一次。因此，文档可能在文档到期和后台任务运行之间保持在集合中。 因为移除操作的持续时间取决于你的mongod实例的工作负载，过期的数据可能存在一段时间超过运行后台任务的60秒周期。 复制集 在副本集成员上，仅当成员处于primary状态时，TTL后台线程才会删除文档。当成员处于辅助状态时，TTL背景线程处于空闲状态。次要成员从主要成员复制删除操作。 支持查询 TTL索引支持查询的方式与非TTL索引相同。 限制 TTL索引是单字段索引。复合索引不支持TTL，并且忽略该 expireAfterSeconds选项。 该_id字段不支持TTL索引。 您无法在上限集合上创建TTL索引，因为MongoDB无法从上限集合中删除文档。 您不能用于createIndex()更改expireAfterSeconds现有索引的值。而是将 collModdatabase命令与indexcollection标志一起使用 。否则，要更改现有索引的选项的值，必须首先删除索引并重新创建。 如果某个字段已经存在非TTL单字段索引，则无法在同一字段上创建TTL索引，因为您无法创建具有相同键规范且仅选项不同的索引。要将非TTL单字段索引更改为TTL索引，必须首先删除该索引，然后使用该expireAfterSeconds选项重新创建 。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/Index-Properties/TTL-Indexes/Expire-Data-from-Collections-by-Setting-TTL.html":{"url":"docs/Indexes/Index-Properties/TTL-Indexes/Expire-Data-from-Collections-by-Setting-TTL.html","title":"Expire Data from Collections by Setting TTL","keywords":"","body":"通过设置TTL使集合中的数据过期 在本页面 程序 本文介绍了MongoDB的“生存时间”或TTL集合特性。TTL集合使它可能存储数据在MongoDB和有' mongod '自动删除数据后指定的秒数或在一个特定的时钟时间。 数据过期对于某些类别的信息很有用，包括机器生成的事件数据、日志和会话信息，这些信息只需要持续有限的一段时间。 一个特殊的TTL索引属性支持TTL集合的实现。TTL特性依赖于' mongod '中的一个后台线程，该线程读取索引中的日期类型值并从集合中删除过期的document。 程序 若要创建TTL索引，请在其值为日期或包含日期值的数组 的字段上使用db.collection.createIndex()带有expireAfterSeconds选项 的 方法 。 请注意 TTL索引是单个字段索引。复合索引不支持TTL属性。有关TTL索引的更多信息，请参见TTL索引。 You can modify the expireAfterSeconds of an existing TTL index using the collMod command. 在指定的秒数之后使文档过期 要在索引字段之后的指定秒数过期数据，在保存BSON日期类型值或BSON日期类型对象数组的字段上创建一个TTL索引，并在expireAfterSeconds字段中指定一个正的非零值。当' expireAfterSeconds '字段中的秒数超过索引字段中指定的时间时,文档将过期。 例如，下面的操作在“log_events”集合的“createdAt”字段上创建一个索引，并指定“expireAfterSeconds”的值“3600”，将过期时间设置为“createdAt”指定的时间之后一小时。 db.log_events.createIndex( { \"createdAt\": 1 }, { expireAfterSeconds: 3600 } ) 当向“log_events”集合添加文档时，将“createdAt”字段设置为当前时间: db.log_events.insert( { \"createdAt\": new Date(), \"logEvent\": 2, \"logMessage\": \"Success!\" } ) 当文档的createdAt值大于expireAfterSeconds中指定的秒数时，MongoDB将自动从log_events集合中删除文档。 在特定的时钟时间时过期文档 要使文档在特定的时钟时间过期，首先在一个字段上创建一个TTL索引，该字段包含BSON日期类型的值或BSON日期类型对象的数组和指定expireAfterSeconds值为0。对于集合中的每个文档，将索引日期字段设置为与文档应该过期的时间对应的值。如果索引日期字段包含过去的日期，MongoDB认为文档过期。 例如，以下操作在“log_events”集合的“expireAt”字段上创建一个索引，并指定“expireAfterSeconds”的值为“0”: db.log_events.createIndex( { \"expireAt\": 1 }, { expireAfterSeconds: 0 } ) 对于每个文档，将expireAt的值设置为与文档应该过期的时间对应。例如，下面的 insert() 操作添加了一个应该在July 22, 2013 14:00:00到期的文档。 db.log_events.insert( { \"expireAt\": new Date('July 22, 2013 14:00:00'), \"logEvent\": 2, \"logMessage\": \"Success!\" } ) 当文档' expireAt的值大于expireAfterSeconds中指定的秒数时，MongoDB将自动从log_events集合中删除文档。在本例中是“0”秒。因此，数据在指定的expireAt值过期。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/Index-Properties/Unique-Indexes.html":{"url":"docs/Indexes/Index-Properties/Unique-Indexes.html","title":"Unique Indexes","keywords":"","body":"唯一索引 在本页面 创建唯一索引 行为 唯一索引确保索引字段不会存储重复值;例如，强制索引字段的唯一性。默认情况下，MongoDB在创建集合期间在_id字段上创建一个唯一的索引。 新的内部格式 从MongoDB 4.2开始，对于4.2（或更高版本）的featureCompatibilityVersion（fCV），MongoDB使用一种新的内部格式来存储与早期MongoDB版本不兼容的唯一索引。新格式适用于现有的唯一索引以及新创建/重建的唯一索引。 创建唯一索引 要创建一个唯一的索引，使用db.collection.createIndex()方法，并将unique选项设置为true。 db.collection.createIndex( , { unique: true } ) 单个字段上的唯一索引 例如，要在members集合的user_id字段上创建一个唯一的索引，在mongo shell中使用以下操作: db.members.createIndex( { \"user_id\": 1 }, { unique: true } ) 独特的复合索引 您还可以在复合索引上强制执行唯一约束。如果您在复合索引上使用唯一约束，那么MongoDB将对索引键值的组合执行惟一性。 例如，要在members集合的groupNumber， lastname和firstname字段上创建一个唯一的索引，在mongo shell中使用以下操作: db.members.createIndex( { groupNumber: 1, lastname: 1, firstname: 1 }, { unique: true } ) 创建的索引强制groupNumber、lastname和firstname值的组合的唯一性。 再举一个例子，考虑一个包含以下文档的集合: { _id: 1, a: [ { loc: \"A\", qty: 5 }, { qty: 10 } ] } 创建一个独特的复合multikey索引在a.loc和a.qty: db.collection.createIndex( { \"a.loc\": 1, \"a.qty\": 1 }, { unique: true } ) 唯一索引允许将以下文档插入到集合中，因为索引强制a.loc和a.qty值组合的唯一性： db.collection.insert( { _id: 2, a: [ { loc: \"A\" }, { qty: 5 } ] } ) db.collection.insert( { _id: 3, a: [ { loc: \"A\", qty: 10 } ] } ) 也可以看看： 跨不同文档的唯一约束和唯一索引和丢失字段 行为 限制 如果集合已经包含了违反索引的唯一约束的数据，MongoDB不能在指定的索引字段上创建一个唯一索引。 不能在hashed索引上指定唯一的约束。 在复制集和分片集群上建立唯一索引 对于复制集和分片集群，使用滚动过程创建唯一索引需要在过程中停止对集合的所有写操作。如果不能在过程中停止对集合的所有写操作，则不要使用滚动过程。相反，在集合上建立你的唯一索引: db.collection.createIndex()在主数据库上发布副本集， db.collection.createIndex()在分片mongos群集上发出。 跨不同文档的唯一约束 唯一约束适用于集合中的不同文档。也就是说，唯一索引防止单独的文档对索引键具有相同的值。 因为约束适用于单独的文档,一个独特的多键索引,一个文档可能数组元素,导致重复索引键值,只要文档不重复的索引键值的另一个文档。在本例中，重复索引条目只插入索引一次。 例如，考虑一个包含以下文档的集合: { _id: 1, a: [ { loc: \"A\", qty: 5 }, { qty: 10 } ] } { _id: 2, a: [ { loc: \"A\" }, { qty: 5 } ] } { _id: 3, a: [ { loc: \"A\", qty: 10 } ] } 在a.loc和a.qty上创建唯一的复合多键索引： db.collection.createIndex( { \"a.loc\": 1, \"a.qty\": 1 }, { unique: true } ) 如果集合中的其他文档的索引 key value 为{ \"a.loc\": \"B\", \"a.qty\": null }，则唯一索引允许将以下文档插入到集合中。 db.collection.insert( { _id: 4, a: [ { loc: \"B\" }, { loc: \"B\" } ] } ) 唯一索引和丢失字段 如果文档在唯一索引中没有索引字段的值，索引将为该文档存储空值。由于唯一的约束，MongoDB将只允许一个没有索引字段的文档。如果有多个文档没有索引字段的值或缺少索引字段，索引构建将失败，并出现重复键错误。 例如，一个集合在x上有一个唯一的索引: db.collection.createIndex( { \"x\": 1 }, { unique: true } ) 如果集合中没有包含缺少x字段的文档，唯一索引允许插入没有x字段的文档: db.collection.insert( { y: 1 } ) 但是，如果集合中已经包含了一个没有字段x的文档，则在插入一个没有字段x的文档时出现唯一的索引错误: db.collection.insert( { z: 1 } ) 由于违反了字段x值的唯一约束，操作无法插入文档: WriteResult({ \"nInserted\" : 0, \"writeError\" : { \"code\" : 11000, \"errmsg\" : \"E11000 duplicate key error index: test.collection.$a.b_1 dup key: { : null }\" } }) 也可以看看： Unique Partial Indexes 独特的部分索引 3.2版本新增. 部分索引只索引集合中满足指定筛选器表达式的文档。如果您同时指定了partialFilterExpression和一个unique约束，唯一约束只适用于满足筛选器表达式的文档。 如果文档不满足筛选条件，则具有唯一约束的部分索引不会阻止插入不满足唯一约束的文档。例如，请参阅带有唯一约束的部分索引。 分片集群和唯一索引 您不能在hashed索引上指定唯一的约束。 对于一个范围分片集合，只有以下索引可以是唯一的: 分片键上的索引 一个复合索引，其中片键是一个前缀 默认_id索引；不过，该_id指数仅实施每碎片的唯一性约束，如果该_id字段是不是分片键或片键的前缀。 唯一性和_ID索引 如果_id字段不是分片键或分片键的前缀，_id索引只对每个分片强制唯一性约束，而对各个分片强制而不是。 唯一的索引约束意味着: 对于要分片的集合，如果该集合有其他唯一索引，则不能对该集合进行分片。 对于已经分片的集合，不能在其他字段上创建唯一索引。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/Index-Properties/Partial-Indexes.html":{"url":"docs/Indexes/Index-Properties/Partial-Indexes.html","title":"Partial Indexes","keywords":"","body":"部分索引 在本页面 创建部分索引 行为 限制 例子 新版本3.2. 部分索引只索引集合中满足指定筛选器表达式的文档。通过索引集合中文档的子集，部分索引可以降低存储需求，并降低创建和维护索引的性能成本。 创建部分索引 使用db.collection.createIndex()方法和'partialFilterExpression'选项。“partialFilterExpression”选项接受指定筛选条件的文档，使用: 等式表达式（即 运算符），field: value$eq $exists: true 表达， $gt，$gte，$lt，$lte表情， $type 表达式， $and 只在顶层操作符 例如，下面的操作创建一个复合索引，该索引只对“rating”字段大于5的文档进行索引。 db.restaurants.createIndex( { cuisine: 1, name: 1 }, { partialFilterExpression: { rating: { $gt: 5 } } } ) 你可以为所有的MongoDB索引类型,指定一个partialFilterExpression选项. 行为 查询范围 如果使用索引导致结果集不完整，则MongoDB不会将部分索引用于查询或排序操作。 若要使用部分索引，查询必须将筛选器表达式(或指定筛选器表达式子集的经过修改的筛选器表达式)作为其查询条件的一部分。 例如，给定以下索引: db.restaurants.createIndex( { cuisine: 1 }, { partialFilterExpression: { rating: { $gt: 5 } } } ) 下面的查询可以使用索引，因为查询谓词包含条件“rating: {$gte: 8}”，它匹配索引筛选器表达式“rating: {$gt: 5}”匹配的文档子集: db.restaurants.find( { cuisine: \"Italian\", rating: { $gte: 8 } } ) 但是，以下查询不能在“cuisine”字段上使用部分索引，因为使用该索引会导致不完整的结果集。具体来说，查询谓词包括条件rating: {$lt: 8}，而索引有过滤器rating: {$gt: 5}。也就是说，查询{cuisine: \"Italian\"， rating: {$lt: 8}}匹配的文档(例如，一家评级为1的意大利餐厅)比编入索引的文档更多。 db.restaurants.find( { cuisine: \"Italian\", rating: { $lt: 8 } } ) 类似地，以下查询不能使用部分索引，因为查询谓词不包括筛选器表达式，并且使用索引将返回不完整的结果集。 db.restaurants.find( { cuisine: \"Italian\" } ) 与“sparse”索引进行比较 提示 部分索引代表sparse索引提供的功能的超集，应优先于sparse索引。 部分索引提供了一种比sparse索引索引更有表现力的机制来指定索引哪些文档。 Sparse索引根据索引字段的存在性选择文档进行索引，对于复合索引则根据索引字段的存在性选择文档。 部分索引根据指定的筛选器确定索引项。过滤器可以包括索引键以外的字段，并可以指定条件，而不仅仅是存在检查。例如，部分索引可以实现与sparse索引相同的行为: db.contacts.createIndex( { name: 1 }, { partialFilterExpression: { name: { $exists: true } } } ) 此部分索引支持与“name”字段上的sparse索引相同的查询。 但是，部分索引还可以在索引键以外的字段上指定筛选器表达式。例如，下面的操作创建了一个部分索引，其中索引在name字段上，但是过滤器表达式在email字段上: db.contacts.createIndex( { name: 1 }, { partialFilterExpression: { email: { $exists: true } } } ) 为了让查询优化器选择此部分索引，查询谓词必须包含“name”字段上的条件，以及“email”字段上的非空匹配。 例如，下面的查询可以使用索引，因为它包括' name '字段上的条件和' email '字段上的非空匹配: db.contacts.find( { name: \"xyz\", email: { $regex: /\\.org$/ } } ) 但是，以下查询不能使用索引，因为它在“email”字段上包含了一个null匹配，这是过滤器表达式{email: {$exists: true}}不允许的: db.contacts.find( { name: \"xyz\", email: { $exists: false } } ) 限制 在MongoDB中，您不能创建仅在选项上有所不同的多个索引版本。因此，您不能创建仅因过滤器表达式而不同的多个部分索引。 您不能同时指定partialFilterExpression选项和sparse选项。 MongoDB 3.0或更早版本不支持部分索引。要使用部分索引，必须使用MongoDB 3.2或更高版本。对于分片集群或复制集，所有节点必须是版本3.2或更高。 _id索引不能是部分索引。 分片键索引不能是部分索引。 例子 在集合上创建部分索引 考虑包含类似于以下文档的集合restaurants { \"_id\" : ObjectId(\"5641f6a7522545bc535b5dc9\"), \"address\" : { \"building\" : \"1007\", \"coord\" : [ -73.856077, 40.848447 ], \"street\" : \"Morris Park Ave\", \"zipcode\" : \"10462\" }, \"borough\" : \"Bronx\", \"cuisine\" : \"Bakery\", \"rating\" : { \"date\" : ISODate(\"2014-03-03T00:00:00Z\"), \"grade\" : \"A\", \"score\" : 2 }, \"name\" : \"Morris Park Bake Shop\", \"restaurant_id\" : \"30075445\" } 您可以在borough和cuisine字段上添加部分索引，仅选择索引rating.grade 字段为的文档A： db.restaurants.createIndex( { borough: 1, cuisine: 1 }, { partialFilterExpression: { 'rating.grade': { $eq: \"A\" } } } ) 然后，对restaurants集合的以下查询使用部分索引返回Bronx中rating.grade等于的餐厅A： db.restaurants.find( { borough: \"Bronx\", 'rating.grade': \"A\" } ) 但是，以下查询不能使用部分索引，因为查询表达式不包含该rating.grade字段： db.restaurants.find( { borough: \"Bronx\", cuisine: \"Bakery\" } ) 具有唯一约束的部分索引 部分索引仅索引集合中符合指定过滤器表达式的文档。如果同时指定 partialFilterExpression和约束，则唯一约束仅适用于满足过滤器表达式的文档。如果文档不符合过滤条件，则具有唯一约束的部分索引不会阻止插入不符合唯一约束的文档。 例如，集合users包含以下文档: { \"_id\" : ObjectId(\"56424f1efa0358a27fa1f99a\"), \"username\" : \"david\", \"age\" : 29 } { \"_id\" : ObjectId(\"56424f37fa0358a27fa1f99b\"), \"username\" : \"amanda\", \"age\" : 35 } { \"_id\" : ObjectId(\"56424fe2fa0358a27fa1f99c\"), \"username\" : \"rajiv\", \"age\" : 57 } 下面的操作创建了一个索引，该索引在“username”字段上指定了一个unique constraint和一个部分过滤表达式age: {$gte: 21}。 db.users.createIndex( { username: 1 }, { unique: true, partialFilterExpression: { age: { $gte: 21 } } } ) 由于指定用户名的文档已经存在，且“age”字段大于21，因此索引防止插入以下文档: db.users.insert( { username: \"david\", age: 27 } ) db.users.insert( { username: \"amanda\", age: 25 } ) db.users.insert( { username: \"rajiv\", age: 32 } ) 但是，允许使用重复用户名的以下文档，因为唯一约束只适用于“age”大于或等于21的文档。 db.users.insert( { username: \"david\", age: 20 } ) db.users.insert( { username: \"amanda\" } ) db.users.insert( { username: \"rajiv\", age: null } ) Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/Index-Properties/Case-Insensitive-Indexes.html":{"url":"docs/Indexes/Index-Properties/Case-Insensitive-Indexes.html","title":"Case Insensitive Indexes","keywords":"","body":"不分大小写索引 在本页面 行为 例子 创建不区分大小写的索引 具有默认排序规则的集合中的区分大小写的索引 3.4版本新功能 不区分大小写索引支持执行不考虑大小写的字符串比较的查询。 通过指定“collation”参数作为选项，可以使用' db.collection.createIndex() '创建大小写不敏感索引。例如: db.collection.createIndex( { \"key\" : 1 }, { collation: { locale : , strength : } } ) 要为区分大小写的索引指定排序规则，请包括: locale:指定语言规则。参见Collation locale获取可用locale列表。 strength:确定比较规则。值“1”或“2”表示排序规则不区分大小写。 有关其他排序字段，请参见collation。 行为 使用不区分大小写的索引不会影响查询的结果，但可以提高性能;请参阅Indexes以获得关于索引成本和收益的详细讨论。 若要使用指定排序规则的索引，查询和排序操作必须指定与索引相同的排序规则。如果集合定义了排序规则，所有查询和索引都会继承该排序规则，除非它们显式指定不同的排序规则。 例子 创建不区分大小写的索引 使用一个不分大小写指数在一组没有默认排序,创建一个索引排序和“strength”参数设置为“1”或“2”(见排序的strength参数的详细描述)。必须在查询级别指定相同的排序规则，才能使用索引级别的排序规则。 下面的示例创建一个没有默认排序规则的集合，然后在“type”字段上使用大小写不敏感排序规则添加索引。 db.createCollection(\"fruit\") db.fruit.createIndex( { type: 1}, { collation: { locale: 'en', strength: 2 } } ) 要使用索引，查询必须指定相同的排序规则。 db.fruit.insert( [ { type: \"apple\" }, { type: \"Apple\" }, { type: \"APPLE\" } ] ) db.fruit.find( { type: \"apple\" } ) // does not use index, finds one result db.fruit.find( { type: \"apple\" } ).collation( { locale: 'en', strength: 2 } ) // uses the index, finds three results db.fruit.find( { type: \"apple\" } ).collation( { locale: 'en', strength: 1 } ) // does not use the index, finds three results 具有默认排序规则的集合中的区分大小写的索引 使用默认排序规则创建集合时，除非指定不同的排序规则，否则随后创建的所有索引都会继承该排序规则。所有没有指定不同排序规则的查询也继承默认排序规则。 下面的示例使用默认排序规则创建名为“names”的集合，然后在“first_name”字段上创建索引。 db.createCollection(\"names\", { collation: { locale: 'en_US', strength: 2 } } ) db.names.createIndex( { first_name: 1 } ) // inherits the default collation 插入少量名称: db.names.insert( [ { first_name: \"Betsy\" }, { first_name: \"BETSY\"}, { first_name: \"betsy\"} ] ) 对该集合的查询默认情况下使用指定的排序规则，如果可能还使用索引。 db.names.find( { first_name: \"betsy\" } ) // inherits the default collation: { collation: { locale: 'en_US', strength: 2 } } // finds three results 上述操作使用集合的默认排序规则并查找所有三个文档。它使用' first_name '字段上的索引以获得更好的性能。 通过在查询中指定不同的排序规则，仍然可以对这个集合执行区分大小写的搜索: db.names.find( { first_name: \"betsy\" } ).collation( { locale: 'en_US' } ) // does not use the collection's default collation, finds one result 上面的操作只找到一个文档，因为它使用的排序规则没有指定strength值。它不使用集合的默认排序规则或索引。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/Index-Properties/Sparse-Indexes.html":{"url":"docs/Indexes/Index-Properties/Sparse-Indexes.html","title":"Sparse Indexes","keywords":"","body":"Sparse索引 在本页面 创建sparse索引 行为 例子 Sparse索引只包含有索引字段的文档的条目，即使索引字段包含空值。索引会跳过任何缺少索引字段的文档。索引是“稀疏的”，因为它不包括一个集合的所有文档。相反，非稀疏索引包含集合中的所有文档，为那些不包含索引字段的文档存储空值。 重要的 从MongoDB 3.2开始，MongoDB提供了创建部分索引的选项。部分索引提供了sparse索引功能的超集。如果你正在使用MongoDB 3.2或更高版本，部分索引应该比稀疏索引更受欢迎。 创建sparse索引 要创建一个“sparse”索引，使用db.collection.createIndex()方法，并将“sparse”选项设置为“true”。例如，下面的操作在mongo shell中创建了一个稀疏的索引在xmpp_id字段的地址集合: db.addresses.createIndex( { \"xmpp_id\": 1 }, { sparse: true } ) 索引不会索引不包含“xmpp_id”字段的文档。 注意 不要将MongoDB中的sparse索引与其他数据库中的块级索引混淆。可以将它们看作具有特定过滤器的密集索引。 行为 “Sparse”索引和不完整结果 如果sparse索引会导致查询和排序操作的结果集不完整，MongoDB将不会使用该索引，除非hint()明确指定该索引。 例如，查询{x: {$exists: false}}不会在x字段上使用sparse索引，除非有明确提示。参见集合上的稀疏索引不能返回完整的结果了解详细的行为示例。 Changed in version 3.4. 如果在执行集合中所有文档的count()(i.e.带有空查询谓词)时包含 sparse索引count()，则即使sparse索引导致计数不正确，也会使用sparse索引。 db.collection.insert({ _id: 1, y: 1 } ); db.collection.createIndex( { x: 1 }, { sparse: true } ); db.collection.find().hint( { x: 1 } ).count(); 要获得正确的计数，在对集合中的所有文档执行计数时，不要使用sparse索引的“hint()”。 db.collection.find().count(); db.collection.createIndex({ y: 1 }); db.collection.find().hint({ y: 1 }).count(); 默认情况下是“sparse”的索引 2dsphere(版本2)， 2d， geoHaystack和文本索引始终为sparse。 Sparse复合索引 Sparse复合索引只包含升序/降序索引键将索引一个文档，只要该文档包含至少一个键。 包含一个地理空间的稀疏的复合索引键(即2 dsphere, 2d,或geoHaystack索引键)连同升序/降序索引键,只有地理空间的存在领域(s)文档中确定索引文档的引用。 对于包含text索引键和升序/降序索引键的sparse复合索引，只有“text”索引字段的存在决定该索引是否引用一个文档。 “Sparse”和“unique”属性 一个“sparse”和unique索引可以防止集合的文档具有一个字段的重复值，但允许多个文档忽略该键。 例子 在集合上创建sparse索引 考虑一个包含以下文档的集合“scores”: { \"_id\" : ObjectId(\"523b6e32fb408eea0eec2647\"), \"userid\" : \"newbie\" } { \"_id\" : ObjectId(\"523b6e61fb408eea0eec2648\"), \"userid\" : \"abby\", \"score\" : 82 } { \"_id\" : ObjectId(\"523b6e6ffb408eea0eec2649\"), \"userid\" : \"nina\", \"score\" : 90 } 集合在“score”字段上有一个sparse索引: db.scores.createIndex( { score: 1 } , { sparse: true } ) 然后，下面对scores集合的查询使用sparse索引返回score字段小于(' $lt ')的文档90: db.scores.find( { score: { $lt: 90 } } ) 由于userid的文档\"newbie\"不包含该 score字段，因此不满足查询条件，因此查询可以使用sparse索引返回结果： { \"_id\" : ObjectId(\"523b6e61fb408eea0eec2648\"), \"userid\" : \"abby\", \"score\" : 82 } 集合上的sparse索引不能返回完整的结果 考虑一个包含以下文档的集合“scores”: { \"_id\" : ObjectId(\"523b6e32fb408eea0eec2647\"), \"userid\" : \"newbie\" } { \"_id\" : ObjectId(\"523b6e61fb408eea0eec2648\"), \"userid\" : \"abby\", \"score\" : 82 } { \"_id\" : ObjectId(\"523b6e6ffb408eea0eec2649\"), \"userid\" : \"nina\", \"score\" : 90 } 集合在“score”字段上有一个sparse索引: db.scores.createIndex( { score: 1 } , { sparse: true } ) 因为userid的文档 \"newbie\"不包含score字段，所以sparse索引不包含该文档的条目。 考虑以下查询返回scores集合中的所有文档，按score字段排序: db.scores.find().sort( { score: -1 } ) 即使是按索引字段排序，MongoDB也不会选择sparse索引来完成查询，以返回完整的结果: { \"_id\" : ObjectId(\"523b6e6ffb408eea0eec2649\"), \"userid\" : \"nina\", \"score\" : 90 } { \"_id\" : ObjectId(\"523b6e61fb408eea0eec2648\"), \"userid\" : \"abby\", \"score\" : 82 } { \"_id\" : ObjectId(\"523b6e32fb408eea0eec2647\"), \"userid\" : \"newbie\" } 要使用sparse索引，显式地用hint()指定索引: db.scores.find().sort( { score: -1 } ).hint( { score: 1 } ) 使用索引只返回那些带有score字段的文档: { \"_id\" : ObjectId(\"523b6e6ffb408eea0eec2649\"), \"userid\" : \"nina\", \"score\" : 90 } { \"_id\" : ObjectId(\"523b6e61fb408eea0eec2648\"), \"userid\" : \"abby\", \"score\" : 82 } 也可以看看： explain() 和 Analyze Query Performance 具有唯一约束的sparse索引 考虑一个包含以下文档的集合scores: { \"_id\" : ObjectId(\"523b6e32fb408eea0eec2647\"), \"userid\" : \"newbie\" } { \"_id\" : ObjectId(\"523b6e61fb408eea0eec2648\"), \"userid\" : \"abby\", \"score\" : 82 } { \"_id\" : ObjectId(\"523b6e6ffb408eea0eec2649\"), \"userid\" : \"nina\", \"score\" : 90 } 您可以使用以下操作在score字段上创建一个unique constraint和sparse过滤器: db.scores.createIndex( { score: 1 } , { sparse: true, unique: true } ) 该索引将允许插入具有该score字段唯一值或不包含该score字段的文档。这样，鉴于scores集合中现有的文档，索引允许进行以下插入操作： db.scores.insert( { \"userid\": \"AAAAAAA\", \"score\": 43 } ) db.scores.insert( { \"userid\": \"BBBBBBB\", \"score\": 34 } ) db.scores.insert( { \"userid\": \"CCCCCCC\" } ) db.scores.insert( { \"userid\": \"DDDDDDD\" } ) 但是，索引不允许添加以下文件，因为文件已经存在，其score值为82和90: db.scores.insert( { \"userid\": \"AAAAAAA\", \"score\": 82 } ) db.scores.insert( { \"userid\": \"BBBBBBB\", \"score\": 90 } ) Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/Index-Builds-on-Populated-Collections.html":{"url":"docs/Indexes/Index-Builds-on-Populated-Collections.html","title":"Index Builds on Populated Collections","keywords":"","body":"在填充的集合上建立索引 在本页面 行为 索引构建对数据库性能的影响 复制集中的索引构建 构建失败和恢复 监视进行中的索引构建 终止进行中的索引构建 索引建立过程 MongoDB 4.2版本新变化 针对已填充的集合的MongoDB索引构建需要对该集合的排他性读写锁定。需要对集合进行读取或写入锁定的操作必须等待，直到mongod释放锁定为止 。MongoDB 4.2使用了优化的构建过程，该过程仅在索引构建的开始和结束时持有排他锁。其余的构建过程将产生交错的读写操作。 索引构建过程总结如下: 初始化 mongod 进程对正在编制索引的集合使用独占锁。所有对该集合的读写操作将阻塞直到mongod 进程释放锁。在此期间，应用程序无法访问集合。 数据摄取和加工 mongod进程释放上一过程中获取的所有锁，然后针对被索引的集合获取一系列意向锁。在此期间，应用程序可以对集合发出读写操作。 清理 mongod进程释放上一过程中获取的所有锁，然后针对被索引集合获取独占锁。这时将阻塞对该集合所有读写操作直到mongod进程释放锁。应用程序此时无法访问该集合。 完成 mongod进程标记索引状态为已可用，然后释放索引构建过程中的所有锁。 索引构建过程中的加锁描述细节参见Index Build Process章节。更深入了解MongoDB的加锁行为参见FAQ: Concurrency。 行为 MongoDB 4.2索引构建完全替代了以前MongoDB版本中支持的索引构建过程。如果指定为createIndexes 或它的shell助手createIndexes()和createIndexes()， MongoDB会忽略后台索引构建选项。 与前景和背景构建进行比较 MongoDB的早期版本支持在前台或后台构建索引。前台索引构建速度很快，能够生成更高效的索引数据结构，但是需要在构建期间阻塞对被索引的集合的父数据库的所有读写访问。后台索引构建速度较慢，效率较低，但允许在构建过程中对数据库及其集合进行读写访问。 MongoDB 4.2版本变化 MongoDB 4.2索引构建只在构建过程的开始和结束时对被索引的集合获得独占锁，以保护元数据的更改。构建过程的其余部分使用后台索引构建的生成行为来最大化构建期间对集合的读写访问。4.2索引构建仍然产生高效的索引数据结构，尽管有更宽松的锁定行为。 MongoDB 4.2的索引构建性能至少与后台索引构建相当。对于在构建过程中很少或没有收到更新的工作负载，4.2索引构建构建的速度可以与基于相同数据的前台索引构建的速度一样快。 使用db.currentOp() 命令监视正在进行的索引构建的进度。 索引构建期间的冲突约束 对集合具有强制约束作用的索引，例如：unique 索引， mongod进程会在索引构建完成后对所有预先存在的和并发写入的文档进行约束性检查。如果任何文档违反了索引约束条件，mongod进程将终止构建并抛出错误。 举例：对inventory集合的product_sku属性构建unique特性索引。如果任意文档的product_sku属性有重复值，索引构建过程仍可成功开始，如果在构建结束时仍然存在任何冲突，mongod进程会终止构建并抛出错误。 类似的，在索引构建的过程中，应用程序可成功对inventory集合写入product_sku属性值重复的文档。如果在构建结束时存在任何索引约束冲突，mongod进程会终止构建并抛出错误。 降低因违反约束而导致索引生成失败的风险： 校验集合中没有违反索引约束的文档。 停止所有可能违反该集合索引约束条件的应用程序写入操作。 索引构建对数据库性能的影响 高负载写入时的索引构建 在目标集合处于高负载写入状态时执行索引构建操作，会造成写入性能下降和更长的索引构建时间。 考虑指定一个维护窗口用于构建索引，在此期间停止或减少对目标集合的写入操作。以减少索引生成过程对性能的潜在负面影响。 可用系统内存不足时的索引构建 命令支持在集合上构建多个索引。createIndexes命令同时使用内存和磁盘上的临时文件空间完成索引构建。createIndexes命令默认的内存使用限制是500MB，该空间在所有使用createIndexes命令生成的索引之间共享。一旦在构建索引时到达该空间限制，createIndexes命令将使用--dbpath目录下_tmp文件夹下的临时磁盘文件空间，用于完成索引构建。 你可以自定义maxIndexBuildMemoryUsageMegabytes参数，更改该空间大小限制。设置更高的内存空间可以在索引大小超500MB时更快完成索引构建。当然，该参数设置过高也会导致占用太多无用内存造成系统内存错误。 如果主机内存有限，你可能需要安排一个维护期，增加整个系统内存，再更改mongod进程中的内存参数设置。 复制集中的索引构建 尽量减少建立索引对以下方面的影响: 复制集中，使用滚动索引生成策略，如Build Indexes on Replica Sets章节所述。 拥有分片复制集的分片集群中，使用滚动索引生成策略，如Build Indexes on Sharded Clusters章节所述。 你可以在primary节点执行索引构建。索引生成完成后，secondaries节点进行复制并开始索引构建。复制集中在开始构建索引之前请注意如下风险： Secondaries节点可能不进行同步 Secondary节点的索引构建将阻塞应用正在执行的对构建索引集合的事务操作。 mongod进程在构建索引完成前将无法使用任何oplog。 如果索引生成在执行操作或命令时持有独占锁，则对被索引集合的复制写操作也可能被延迟到索引构建完成之后。mongod 进程无法使用任何oplog直到锁释放。如果复制延迟时间超过secondary节点的oplog window，secondary将不进行同步，需要通过resynchronization来恢复。 在构建索引之前，使用rs.printReplicationInfo()命令鉴别每个副本集成员配置的时间区间中可处理的oplog大小。你可以增大oplog大小increase the oplog size，降低不同步的概率。例如，设置oplog的窗口可以覆盖72个小时的操作记录，只要确保secondary节点可以容忍这么久的复制延迟。 或者在维护时间窗口中执行索引构建，应用程序停止对该索引集合的所有事物操作、写操作和元数据操作。 Secondary节点的索引构建可能造成读写操作延迟 MongoDB 4.2索引生成过程的开始和结束时获取正在索引的集合的独占锁。当secondary节点索引生成持有独占锁时，该secondary节点将暂停任何读写操作，直到索引生成释放该锁为止。 索引生成完成后，辅助进程索引将删除 在secondary节点完成索引构建的复制之前，在primary节点删除索引，将不会中断secondary节点的构建。当secondary节点执行索引删除的复制操作时，其须等待之前的索引生成操作执行复制完毕。此外，由于索引删除是集合上的元数据操作，因此索引删除会暂停该secondary节点上的复制。 构建失败和恢复 单个mongod进程的索引构建中断 如果mongod进程在索引构建时终止了，索引构建任务和所有进程将丢失。重启mongod进程不会重新执行索引构建，你必须重新运行createIndex() 操作来重启索引构建。 Primary节点mongod进程的索引构建中断 如果primary节点在索引构建时停止了，索引构建任务和所有进程将丢失。你必须重新运行createIndex() 操作来重启索引构建。 Secondary节点mongod进程的索引构建中断 如果secondary节点在索引构建时停止了，索引构建任务将保留。重启 mongod进程将恢复索引构建并从头重新开始。 启动进程会在任意已恢复的索引生成之后暂停。所有操作，包括复制将进入等待直到索引构建完成。如果secondary节点的oplog未在时间窗口区间完成缩影索引构建的复制，secondary不再进行这部分oplog的复制集的同步，需要resynchronization恢复。 如果你重启了mongod进程作为独立的复制集节点实例或删除--replSetName)。mongod进程仍将从头恢复索引构建。你可以使用storage.indexBuildRetry配置文件设置或写入命令行参数--noIndexBuildRetry。 MONGODB 4.0以上版本 你不能对副本集中的一个mongod进程实例，设置storage.indexBuildRetry选项 或 --noIndexBuildRetry选项。 构建过程中的回滚 从4.0版本开始，MongoDB在任意正在执行索引构建的进程完成后进行rollback。 监视进行中的索引构建 你可以在mongo shell中执行db.currentOp()命令，查看索引构建操作的状态。筛选当前操作中的索引创建操作，参见Active Indexing Operations操作。 msg包含了索引构建当前阶段的完成百分比。 终止进行中的索引构建 终止primary节点或单个 mongod 进程中正在执行的索引构建命令，请在mongo进程中使用db.killOp()命令。当终止索引生成时，db.killOp()命令可能不会立即执行，并可能在大部分索引生成操作完成后执行。 你无法终止一个已经在复制集secondary节点进行复制的索引构建操作。你必须首先在primary节点drop删除索引。secondary节点将复制删除操作并在索引构建完成后删除索引。所用复制操作将阻塞直到索引构建完成并执行完删除操作。 尽量降低复制集和拥有复制集的分片集群的构建索引影响，参见： 在复制集上建立索引 在分片群集上建立索引索引建立过程 如下表格描述索引构建过程中的每个阶段： 阶段 描述 Lock mongod 进程获得索引集合的独占X锁。该集合的所有读写操作被阻塞，包括应用程序对该集合所有复制写操作或者元数据指令。mongod进程不会释放独占锁。 初始化 mongod进程在该初始状态创建三个数据结构：初始索引元数据项。一张临时表（\"side writes table\"），用来存储构建过程中对索引集合进行写入时生成的key。一张临时表(“constraint violation table”)，用于存储可能导致重复键约束冲突的所有文档。 Lock mongod 进程将之前获取的独占锁X降级为意图独占锁IX，[mongod]进程周期性的释放该锁，允许进行交错读写操作。 扫描集合 mongod进程对集合中每个文档生成一个key，并将该key存储到外部分类器中，如果 mongod进程在集合扫描期间发现重复key，它会将该key存储在constraint violation表中以备后续处理。如果mongod进程在生成key时遇到任何其他错误，构建将失败并出现错误。一旦mongod进程完成集合扫描，它将分类的key转储到索引中。 进程端写入表 mongod 使用先进先出方式处理Side Writes Table表中数据，如果遇到重复key，将该key写入constraint violation table表以备后续处理。如果mongod进程在处理键时出现任何异常错误，构建将失败。对于每个在索引构建过程中写入集合的文档，mongod进程都会给该文档生成一个key，并将其存储到side write table表中。mongod使用快照系统设置要处理的key的数量限制。 Lock mongod进程将索引集合上的意图独占锁IX升级为共享S锁。这会阻塞该集合的所有写操作，包括应用程序对该集合的任何复制写操作或元数据操作。 处理完临时端写表 mongod进程继续处理Side Writes Table表中的存量数据。mongod进程在该阶段可能会暂停复制。如果遇到重复key，将该key写入constraint violation table表以备后续处理。如果mongod进程在处理键时出现任何异常错误，构建将失败。 Lock mongod进程将索引集合的共享S锁升级成独占X锁。该集合的所有读写操作被阻塞，包括应用程序对该集合所有复制写操作或者元数据指令操作。mongod进程不会释放独占锁。 下侧写表 mongod在处理完Side Write Table表中所有数据后将其删除。如果遇到重复key，将该key写入constraint violation table表以备后续处理。如果mongod进程在处理键时出现任何异常错误，构建将失败。 流程约束违规表 mongod进程使用先入先出的方式处理Constraint Violation Table表中数据，之后删除该表。如果其中任何键仍然出现重复键错误，mongod将终止构建并抛出错误。mongod进程在处理完Constraint Violation Table表后或出现重复键约束时将删除该表。 将索引标记为就绪 mongod将索引元数据更新为可使用状态。 Lock mongod进程释放该索引集合的独占X锁。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/Index-Builds-on-Populated-Collections/Rolling-Index-Builds-on-Replica-Sets.html":{"url":"docs/Indexes/Index-Builds-on-Populated-Collections/Rolling-Index-Builds-on-Replica-Sets.html","title":"Rolling Index Builds on Replica Sets","keywords":"","body":"在复制集上建立索引 在本页面 注意事项 前提条件 程序 索引构建会影响复制集的性能。默认情况下，MongoDB 4.4及以后版本在所有承载数据的复制集成员上同时构建索引。对于不能容忍由于索引构建而导致性能下降的工作负载，可以考虑使用以下过程以滚动方式构建索引。 滚动索引构建一次最多抽取一个复制集成员(从辅助成员开始)，并在该成员上作为独立的索引构建。构建滚动索引至少需要一次复制集的选择。 注意事项 唯一索引 要使用以下过程创建唯一索引，必须在此过程中停止对集合的所有写操作。 如果在此过程中不能停止对集合的所有写操作，请不要使用此页面上的过程。相反，通过在主节点上为一个副本集发出' db.collection.createIndex() '来在该集合上构建你的唯一索引。 Oplog大小 确保您的oplog足够大，以允许索引或重新索引操作完成，而不会落后太多而无法跟上。参见oplog sizing文档了解更多信息。 前提条件 用于构建唯一索引 要使用以下过程创建唯一索引，必须在索引构建期间停止对集合的所有写操作。否则，复制集成员之间的数据可能会不一致。如果不能停止对集合的所有写操作，请不要使用以下过程创建唯一索引。 程序 重要 以下以滚动方式构建索引的过程适用于复制集部署，而不适用分片集群。有关分片集群的过程，请参阅在分片集群上构建滚动索引。 A. 停止一个辅助节点并作为独立节点重新启动 停止与辅助节点关联的mongod进程。进行以下配置更新后重新启动： 配置文件 如果您正在使用配置文件，请进行以下配置更新: 注释掉replication.replSetName选项。 更改net.port到一个不同的端口。[1]记录原始的端口设置作为注释。 在setParameter部分设置参数' disablelogicalicalsessioncacherefresh '为' true '。 例如，更新后的副本集成员配置文件将包括如下示例所示的内容: net: bindIp: localhost, port: 27217 # port: 27017 #replication: # replSetName: myRepl setParameter: disableLogicalSessionCacheRefresh: true 其他设置（例如storage.dbPath等）保持不变。 并重新启动: mongod --config 命令行选项 如果使用命令行选项，请进行以下配置更新: 删除---复制集。 修改---端口到另一个端口。 在---setParameter选项中设置参数disableLogicalSessionCacheRefresh为true 例如，如果你的复制集成员通常运行在默认端口27017和----replSet选项，你应该指定一个不同的端口，省略----replSet选项，并设置disableLogicalSessionCacheRefresh参数为true: mongod --port 27217 --setParameter disableLogicalSessionCacheRefresh=true 其他设置（例如--dbpath等）保持不变。 B. 建立索引 直接连接到mongod实例作为一个独立的运行在新的端口上，并为这个实例创建新的索引。 例如，将mongo连接到实例，然后使用createIndex()来username在records集合的字段上创建升序索引： db.records.createIndex( { username: 1 } ) C. 重新启动程序mongod作为复制集成员 索引构建完成后，关闭mongod 实例。撤消以独立版本启动时所做的配置更改，以返回其原始配置并以复制集的成员身份重新启动。 重要 一定要删除' disableLogicalSessionCacheRefresh '参数。 例如，重新启动复制集成员: 配置文件 如果您正在使用配置文件: 恢复到原始端口号。 取消replication.replSetName的注释。 删除setParameter中的参数' disableLogicalSessionCacheRefresh '。 例如： copycopied net: bindIp: localhost, port: 27017 replication: replSetName: myRepl Other settings (e.g. storage.dbPath, etc.) remain the same. 并重新启动 mongod --config 命令行选项 如果您正在使用配置文件: 恢复到原始端口号 包括----replSet选项。 删除参数disableLogicalSessionCacheRefresh。 例如： mongod --port 27017 --replSet myRepl 其他设置（例如--dbpath等）保持不变。 D.重复其余的步骤 一旦该成员赶上集合中的其他成员，请对其余的次要成员一次重复一个成员的过程： A.停止一个辅助节点并以独立方式重新启动 B.建立索引 C.重新启动程序mongod作为副本集成员 E. 在主服务器上构建索引 当所有的辅助服务器都有了新的索引时，从主服务器下走一步，使用上面描述的过程作为一个独立的程序重新启动它，并在前主服务器上构建索引: 使用mongo shell中的rs.stepDown()方法mongo降低主数据库的性能。成功降级后，当前的主节点将成为辅助节点，复制集成员将选择新的主节点。 A.停止一个辅助节点并以独立方式重新启动 B.建立索引 C.重新启动程序mongod作为副本集成员 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/Index-Builds-on-Populated-Collections/Rolling-Index-Builds-on-Sharded-Clusters.html":{"url":"docs/Indexes/Index-Builds-on-Populated-Collections/Rolling-Index-Builds-on-Sharded-Clusters.html","title":"Rolling Index Builds on Sharded Clusters","keywords":"","body":"在分片群集上建立滚动索引 在本页面 注意事项 前提条件 程序 附加信息 索引构建会影响分片集群的性能。默认情况下，MongoDB 4.4及以后版本在所有承载数据的复制集成员上同时构建索引。基于分片集群的索引仅发生在那些包含被索引的集合数据的分片上。对于不能容忍由于索引构建而导致性能下降的工作负载，可以考虑使用以下过程以滚动方式构建索引。 滚动索引构建一次最多取出一个碎片复制集成员(从辅助成员开始)，并在该成员上作为一个独立的成员构建索引。构建滚动索引需要每个碎片至少进行一次复制集选择。 注意事项 唯一索引 要使用以下过程创建唯一索引，必须在此过程中停止对集合的所有写操作。 如果在此过程中无法停止对集合的所有写操作，请不要使用此页面上的过程。相反，可以通过db.collection.createIndex()在分片mongos群集上发出来在集合上构建唯一索引。 Oplog大小 确保您的oplog足够大，以允许索引或重新索引操作完成，而不会落后太多而无法跟上。参见oplog sizing文档了解更多信息。 前提条件 用于构建唯一索引 1.要使用以下过程创建唯一索引，必须在索引生成期间停止对集合的所有写操作。否则，复制集成员之间的数据可能会不一致。如果 不能停止对集合的所有写操作，请不要使用以下过程创建唯一索引。 警告 如果不能停止对集合的所有写操作，请不要使用以下过程创建唯一索引。 2.在创建索引之前，验证集合中没有文档违反索引约束。如果一个集合分布在多个切片上，而一个切片中包含有重复文档的块，那么 创建索引操作可能在没有重复的切片上成功，但在有重复的切片上失败。为了避免在多个碎片之间留下不一致的索引，可以从 mongos中发出db.collection.dropIndex()来从集合中删除索引。 程序 重要 以下以滚动方式构建索引的过程适用于分片集群部署，而不适用于复制集部署。关于复制集的过程，请参见复制集上的滚动索引构建。 A. 停止平衡器 将mongoshell连接到分片mongos 群集中的实例，然后运行sh.stopBalancer()以禁用平衡器: sh.stopBalancer() 注意 如果迁移正在进行中，系统将在停止平衡器之前完成迁移。 要验证均衡器被禁用，运行sh.getBalancerState()，如果均衡器被禁用，将返回false: sh.getBalancerState() B. 确定集合的分布 在mongoshell连接程序 mongos，刷新缓存的路由表， mongos以免返回该集合的陈旧分发信息。刷新后，运行 db.collection.getShardDistribution()要构建索引的集合。 例如，如果您想在test 数据库的records集合上使用升序索引: db.adminCommand( { flushRouterConfig: \"test.records\" } ); db.records.getShardDistribution(); 该方法输出切分分布。例如，考虑一个分片集群，有3个分片' shardA '、' shardB '和' shardC '， ' db.collection.getShardDistribution() '返回以下结果: Shard shardA at shardA/s1-mongo1.example.net:27018,s1-mongo2.example.net:27018,s1-mongo3.example.net:27018 data : 1KiB docs : 50 chunks : 1 estimated data per chunk : 1KiB estimated docs per chunk : 50 Shard shardC at shardC/s3-mongo1.example.net:27018,s3-mongo2.example.net:27018,s3-mongo3.example.net:27018 data : 1KiB docs : 50 chunks : 1 estimated data per chunk : 1KiB estimated docs per chunk : 50 Totals data : 3KiB docs : 100 chunks : 2 Shard shardA contains 50% data, 50% docs in cluster, avg obj size on shard : 40B Shard shardC contains 50% data, 50% docs in cluster, avg obj size on shard : 40B 从输出中，您只为test构建索引。记录在shardA和shardC。 C. 在包含集合块的碎片上构建索引 对于包含集合块的每个分片，遵循以下过程在分片上构建索引。 C1. 停止一个辅助设备并独立重启 对于受影响的分片，停止mongod与其辅助节点之一相关联的过程。在进行以下配置更新后重新启动: 配置文件 如果您正在使用配置文件，请进行以下配置更新: 将net.port更改为其他端口。记下原始端口设置作为注释。 注释掉该replication.replSetName选项。 注释掉该sharding.clusterRole选项。 在部分skipShardingConfigurationChecks 中将参数设置（也适用于MongoDB 3.6.3 +，3.4.11 +，3.2.19 +） truesetParameter 在设置参数部分将参数disableLogicalSessionCacheRefresh设置为true。 例如，对于一个分片复制集成员，更新后的配置文件将包括如下示例所示的内容: net: bindIp: localhost, port: 27218 # port: 27018 #replication: # replSetName: shardA #sharding: # clusterRole: shardsvr setParameter: skipShardingConfigurationChecks: true disableLogicalSessionCacheRefresh: true 并重新启动: mongod --config 其他设置(例如' storage.dbPath '等)保持不变。 命令行选项 如果使用命令行选项，请进行以下配置更新: 修改--port为其他端口。 删除--replSet。 --shardsvr如果分片成员和--configsvr配置服务器成员则删除。 在--setParameter选项中将参数skipShardingConfigurationChecks (也可用于MongoDB 3.6.3+、3.4.11+、3.2.19+)设置为true。 在 --setParameter选项中设置参数disableLogicalSessionCacheRefresh为true。 例如，重新启动不带--replSet和 --shardsvr选项的分片副本集成员。指定新的端口号，并将skipShardingConfigurationChecks和 disableLogicalSessionCacheRefresh参数都设置 为true： mongod --port 27218 --setParameter skipShardingConfigurationChecks=true --setParameter disableLogicalSessionCacheRefresh=true 其他设置（例如--dbpath等）保持不变。 C2. 建立索引 直接连接到' mongod '实例作为一个独立的运行在新的端口上，并为这个实例创建新的索引。 例如，将mongoshell连接到实例，并使用db.collection.createIndex()方法username在records 集合的字段上创建升序索引： db.records.createIndex( { username: 1 } ) C3. 重新启动程序 mongod 作为复制集成员 当索引构建完成时，关闭' mongod '实例。撤销作为独立启动时所做的配置更改，以返回原始配置并重新启动。 重要 一定要删除' skipShardingConfigurationChecks '参数和' disableLogicalSessionCacheRefresh '参数。 例如，重新启动你的复制集分片成员: 配置文件 如果您正在使用配置文件，请进行以下配置更新: 恢复为原始端口号。 取消注释replication.replSetName。 取消注释sharding.clusterRole。 skipShardingConfigurationChecks 在该setParameter部分中删除参数。 disableLogicalSessionCacheRefresh 在该setParameter部分中删除参数。 net: bindIp: localhost, port: 27018 replication: replSetName: shardA sharding: clusterRole: shardsvr 其他设置(例如' storage.dbPath '等)保持不变。 并重新启动： mongod --config 命令行选项 如果使用命令行选项，请进行以下配置更新: 恢复为原始端口号。 包括--replSet。 包括分片--shardsvr成员或--configsvr配置服务器成员。 删除参数 skipShardingConfigurationChecks。 删除参数disableLogicalSessionCacheRefresh。 例如： mongod --port 27018 --replSet shardA --shardsvr 其他设置（例如--dbpath等）保持不变。 C4. 对分片的其他次要数据重复此过程 一旦该成员赶上了集合中的其他成员，就对分片中剩余的次要成员一次重复这个过程: C1.停止一台备用服务器并独立启动 C2.建立索引 C3.重新启动程序mongod作为副本集成员 C5. 在主服务器上构建索引 当分片的所有辅助数据库都具有新索引时，请降低分片的主数据库，使用上述步骤以独立方式重新启动它，然后在前一个主数据库上建立索引: 使用外壳程序中的rs.stepDown()方法mongo降低主数据库的性能。成功降级后，当前的主节点将成为辅助节点，复制集成员将选择新的主节点。 C1.停止一台备用服务器并独立启动 C2.建立索引 C3.重新启动程序mongod作为副本集成员 D. 对其他受影响的分片重复此操作 在为切分构建完索引之后，重复C]。在包含集合块的切分上为其他受影响的切分构建索引。 一旦完成了为分片建立索引，请重复步骤 C .在包含集合块的碎片上构建索引为其他受影响的分片建立索引。 E.重新启动平衡器 为受影响的分片完成滚动索引构建后，重新启动平衡器。 将mongoshell连接到分片mongos 群集中的实例，然后运行sh.startBalancer()： sh.startBalancer() 附加信息 如果在包含集合块的每个分片上没有完全相同的索引(包括索引选项)，则分片集合具有不一致的索引。虽然在正常操作中不应该出现索引不一致的情况，但也会出现索引不一致的情况，例如: 当用户正在创建一个索引，一个“唯一”的关键约束和一个分片包含块与重复的文档。在这种情况下，创建索引操作可能在没有重复的分片上成功，但在有重复的切分上失败。 当用户以滚动方式在多个切片之间创建索引，但要么未能为关联的切片建立索引，要么不正确地建立了不同规格的索引。 从MongoDB 4.4（和4.2.6）开始，配置服务器主服务器会定期检查分片集合中各分片之间的索引不一致。要配置这些定期检查，请参阅 enableShardedIndexConsistencyCheck和 shardedIndexConsistencyCheckIntervalMS。 当在配置服务器主服务器上运行时，该命令serverStatus返回该字段 shardedIndexConsistency以报告索引不一致情况。 要检查分片集合是否具有不一致的索引，请参阅 查找分片中的不一致索引。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/Index-Intersection.html":{"url":"docs/Indexes/Index-Intersection.html","title":"Index Intersection","keywords":"","body":"索引交集 在本页面 索引前缀交集 索引交集和复合索引 索引交集和排序 MongoDB可以使用多个索引的交集来完成查询。通常，每个索引交集涉及两个索引。但是，MongoDB可以使用多个/嵌套索引交集来解析查询。 为了说明索引交集，请考虑orders具有以下索引的集合： { qty: 1 } { item: 1 } MongoDB可以使用两个索引的交集来支持以下查询： db.orders.find( { item: \"abc123\", qty: { $gt: 15 } } ) 要确定MongoDB是否使用了索引交集，运行 explain();explain()的结果将包括AND_SORTED阶段或AND_HASH阶段。 索引前缀交集 使用索引交集，MongoDB可以使用整个索引或索引前缀的交集。索引前缀是复合索引的子集，由一个或多个从索引开头开始的键组成。 考虑orders具有以下索引的集合： { qty: 1 } { status: 1, ord_date: -1 } 为了完成以下查询，它在qty字段和status字段上都指定了一个条件，MongoDB可以使用两个索引的交集: db.orders.find( { qty: { $gt: 10 } , status: \"A\" } ) 索引交集和复合索引 索引交集并不能消除创建复合索引的需要 。但是，由于复合索引中的列表顺序（即，键在索引中的列出顺序）和排序顺序（即，升序或降序）都很重要 ，因此复合索引可能不支持不包含以下内容的查询条件：该指数的前缀键，或者指定一个不同的排序顺序。 例如，如果一个集合orders具有以下复合索引，且该status字段在字段之前列出ord_date： { status: 1, ord_date: -1 } 复合索引可以支持以下查询： db.orders.find( { status: { $in: [\"A\", \"P\" ] } } ) db.orders.find( { ord_date: { $gt: new Date(\"2014-02-01\") }, status: {$in:[ \"P\", \"A\" ] } } ) 但不是以下两个查询： db.orders.find( { ord_date: { $gt: new Date(\"2014-02-01\") } } ) db.orders.find( { } ).sort( { ord_date: 1 } ) 但是，如果集合具有两个单独的索引： { status: 1 } { ord_date: -1 } 这两个索引可以单独或通过索引交集来支持所有上述四个查询。 创建支持查询的复合索引还是依赖索引交集之间的选择取决于系统的具体情况。 也可以看看 复合索引， 创建复合索引以支持多个不同的查询 索引交集和排序 当sort() 操作要求索引与查询谓词完全分开时，索引交集不适用。 例如，该orders集合具有以下索引： { qty: 1 } { status: 1, ord_date: -1 } { status: 1 } { ord_date: -1 } MongoDB不能对以下带有排序的查询使用索引交集： db.orders.find( { qty: { $gt: 10 } } ).sort( { status: 1 } ) 也就是说，MongoDB不会将索引用于查询，而将单独索引或索引用于排序。{ qty: 1 }``{ status: 1 }``{ status: 1, ord_date: -1 } 也就是说，MongoDB不使用{ qty: 1 }索引进行查询，使用单独的{ status: 1 }或{ status: 1, ord_date: -1 }索引进行排序。 然而，MongoDB可以使用索引交集来进行以下排序查询，因为索引{ status: 1, ord_date: -1 }可以完成部分查询谓词。 db.orders.find( { qty: { $gt: 10 } , status: \"A\" } ).sort( { ord_date: -1 } ) Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/Manage-Indexes.html":{"url":"docs/Indexes/Manage-Indexes.html","title":"Manage Indexes","keywords":"","body":"管理索引 Mongo Shell 在本页面 查看现有索引 删除索引 修改索引 在分片中查找不一致的索引 此页显示如何管理现有索引。有关创建索引的说明，请参阅特定索引类型页。 查看现有索引 以下部分提供了查看集合或整个数据库上现有索引的方法。 列出集合上的所有索引 要返回一个集合上所有索引的列表，使用db. collections . getindexes ()方法或类似的驱动程序的方法。 例如，要查看people集合上的所有索引，运行以下命令: db.people.getIndexes() 列出数据库的所有索引 在mongo shell中,可以使用以下操作列出数据库中所有的集合索引: db.getCollectionNames().forEach(function(collection) { indexes = db[collection].getIndexes(); print(\"Indexes for \" + collection + \":\"); printjson(indexes); }); 从3.0版本开始，MongoDB不再支持对系统的直接访问。索引集合，以前用于列出数据库中的所有索引。 列出特定类型的索引 列出所有索引的类型(例如散列,文本)集合在所有数据库,您可以使用以下操作在mongoshell: // The following finds all hashed indexes db.adminCommand(\"listDatabases\").databases.forEach(function(d){ let mdb = db.getSiblingDB(d.name); mdb.getCollectionInfos({ type: \"collection\" }).forEach(function(c){ let currentCollection = mdb.getCollection(c.name); currentCollection.getIndexes().forEach(function(idx){ let idxValues = Object.values(Object.assign({}, idx.key)); if (idxValues.includes(\"hashed\")) { print(\"Hashed index: \" + idx.name + \" on \" + idx.ns); printjson(idx); }; }); }); }); 删除索引 MongoDB提供了两种方法从集合中删除索引: db.collection.dropIndex() db.collection.dropIndexes() 删除特定的指数 要删除一个索引，使用db.collection.dropIndex()方法。 例如，下面的操作删除了 accounts 集合中的 tax-id 字段的升序索引: db.accounts.dropIndex( { \"tax-id\": 1 } ) 该操作返回一个文档，其中显示了该操作的状态: { \"nIndexesWas\" : 3, \"ok\" : 1 } 其中nIndexesWas的值反映了在删除这个索引之前的索引数量。 对于文本索引，将索引名称传递给 db.collection.dropIndex()方法。有关详细信息，请参见使用索引名称删除文本索引。 注意 从MongoDB 4.2开始，' db.collection.dropIndexes() '可以接受一个索引名称数组。 删除所有索引 你也可以使用db. collections . dropindexes ()从一个集合中删除_id索引之外的所有索引。 例如，下面的命令从 accounts 集合中删除所有索引: db.accounts.dropIndexes() 这些shell助手提供了dropIndexes 数据库命令的包装器。您的客户端库可能有一个不同的或额外的接口用于这些操作。 修改索引 要修改现有索引，您需要删除并重新创建索引。TTL索引是该规则的例外 ，可以通过collMod命令与index收集标志一起 对其进行修改。 在分片中查找不一致的索引 如果分片集合在每个包含该分片块的分片上没有完全相同的索引（包括索引选项），则该集合具有不一致的索引。虽然在正常操作中不应该出现索引不一致的情况，但也会出现索引不一致的情况，例如: 当用户创建具有unique键约束的索引并且一个分片包含具有重复文档的块时。在这种情况下，创建索引操作可能会在没有重复的分片上成功，但在没有重复的分片上不会成功。 当用户创建一个索引碎片在对面(滚动的方式(即手动构建跨多个碎片索引一个接一个地)但是无论未能构建相关碎片或是不正确的索引构建索引与不同的规范。 从MongoDB 4.2.6,配置服务器主,默认情况下,检查索引不一致在分片的碎片集合,和命令(\"serverStatus\"),主要配置服务器上运行时,返回字段shardedIndexConsistency来报告索引不一致的分片集合的数量。 如果shardedIndexConsistency报告任何索引不一致，则可以对分片集合运行以下管道，直到找到不一致为止。 注意 下面的管道用于MongoDB 4.2.4及以上版本。 定义以下聚合管道: const pipeline = [ // Get indexes and the shards that they belong to. {$indexStats: {}}, // Attach a list of all shards which reported indexes to each document from $indexStats. {$group: {_id: null, indexDoc: {$push: \"$$ROOT\"}, allShards: {$addToSet: \"$shard\"}}}, // Unwind the generated array back into an array of index documents. {$unwind: \"$indexDoc\"}, // Group by index name. { $group: { \"_id\": \"$indexDoc.name\", \"shards\": {$push: \"$indexDoc.shard\"}, // Convert each index specification into an array of its properties // that can be compared using set operators. \"specs\": {$push: {$objectToArray: {$ifNull: [\"$indexDoc.spec\", {}]}}}, \"allShards\": {$first: \"$allShards\"} } }, // Compute which indexes are not present on all targeted shards and // which index specification properties aren't the same across all shards. { $project: { missingFromShards: {$setDifference: [\"$allShards\", \"$shards\"]}, inconsistentProperties: { $setDifference: [ {$reduce: { input: \"$specs\", initialValue: {$arrayElemAt: [\"$specs\", 0]}, in: {$setUnion: [\"$$value\", \"$$this\"]}}}, {$reduce: { input: \"$specs\", initialValue: {$arrayElemAt: [\"$specs\", 0]}, in: {$setIntersection: [\"$$value\", \"$$this\"]}}} ] } } }, // Only return output that indicates an index was inconsistent, i.e. either a shard was missing // an index or a property on at least one shard was not the same on all others. { $match: { $expr: {$or: [ {$gt: [{$size: \"$missingFromShards\"}, 0]}, {$gt: [{$size: \"$inconsistentProperties\"}, 0]}, ] } } }, // Output relevant fields. {$project: {_id: 0, indexName: \"$$ROOT._id\", inconsistentProperties: 1, missingFromShards: 1}} ]; 运行要测试的分片集合的聚合管道。例如，要测试分片集合是否测试。在相关的碎片上有不一致的索引: db.getSiblingDB(\"test\").reviews.aggregate(pipeline) 如果集合的索引不一致，则该集合的聚合将返回关于不一致索引的详细信息: { \"missingFromShards\" : [ \"shardB\" ], \"inconsistentProperties\" : [ ], \"indexName\" : \"page_1_score_1\" } { \"missingFromShards\" : [ ], \"inconsistentProperties\" : [ { \"k\" : \"expireAfterSeconds\", \"v\" : 60 }, { \"k\" : \"expireAfterSeconds\", \"v\" : 600 } ], \"indexName\" : \"reviewDt_1\" } 返回的文档指出了分片集合 test.reviews 的两个不一致之处: shardB上的集合中缺少一个名为page_1_score_1的索引。 一个名为reviewDt_1的索引在集合的各个分片上具有不一致的属性，特别是expireAfterSeconds属性不同。 要解决特定分片集合中缺少索引的不一致问题 ​ 从受影响的分片上的集合中删除不正确的索引，然后重建索引。要重建索引，您可以： 在受影响的分片上为集合执行滚动索引构建。 或者 从一个mongos 实例发出一个索引构建 db.collection.createIndex()。该操作仅在没有索引的分片上构建集合的索引。 要解决索引属性在各个分片之间的差异 ​ 从受影响的分片上的集合中删除不正确的索引，并重新构建索引。重建索引，你可以: 在受影响的碎片上为集合执行滚动索引构建。 或者 从一个mongos 实例发出一个索引构建 db.collection.createIndex()。该操作仅在没有索引的碎片上构建集合的索引。 或者，如果不一致是该expireAfterSeconds属性，则可以运行collMod命令以更新秒数，而不是删除并重建索引。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/Measure-Index-Use.html":{"url":"docs/Indexes/Measure-Index-Use.html","title":"Measure Index Use","keywords":"","body":"衡量索引使用 在本页面 使用$indexStats度量索引使用 使用 explain()返回查询计划 使用hint()控制索引使用 索引指标使用$indexStats度量索引使用 使用$indexStats 聚合阶段获取关于集合中每个索引的使用情况的统计信息。例如，以下聚合操作返回关于orders集合中索引使用情况的统计信息: db.orders.aggregate( [ { $indexStats: { } } ] ) 也可参考： $indexStats 使用 explain()返回查询计划 在executionStats 模式中使用db.collection.explain() 或cursor.explain()方法返回关于查询过程的统计信息，包括使用的索引、扫描的文档数量以及查询处理所用的时间(以毫秒为单位)。 在allPlansExecution 模式下使用 db.collection.explain() 或cursor.explain()方法查看计划选择期间收集的部分执行统计信息。 也可参考： planCacheKey 使用hint()控制索引使用 要强制MongoDB为db.collection.find()操作使用特定的索引，请使用hint()方法指定该索引。将hint()方法附加到find()方法。考虑下面的例子: 代码示例如下： db.people.find( { name: \"John Doe\", zipcode: { $gt: \"63000\" } } ).hint( { zipcode: 1 } ) 查看使用特定索引的执行统计信息，在db.collection.find()语句追加的hint()方法后跟随cursor.explain()方法，代码示例如下： db.people.find( { name: \"John Doe\", zipcode: { $gt: \"63000\" } } ).hint( { zipcode: 1 } ).explain(\"executionStats\") 或者在db.collection.explain().find()方法后追加hint()方法。 db.people.explain(\"executionStats\").find( { name: \"John Doe\", zipcode: { $gt: \"63000\" } } ).hint( { zipcode: 1 } ) 在hint()方法中声明$natural参数，避免MongoDB在查询过程中使用任何索引。 db.people.find( { name: \"John Doe\", zipcode: { $gt: \"63000\" } } ).hint( { $natural: 1 } ) 索引指标 除了$indexStats聚合阶段，MongoDB提供了各种索引统计数据，您可能想要考虑分析索引使用您的数据库: 在serverStatus方法的输出结果中： metrics.queryExecutor.scanned和metrics.operation.scanAndOrder 在collStats输出结果中 totalIndexSize和indexSizes 在dbStats输出结果中 dbStats.indexes和dbStats.indexSize Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/Indexing-Strategies.html":{"url":"docs/Indexes/Indexing-Strategies.html","title":"Indexing Strategies","keywords":"","body":"索引策略 应用程序的最佳索引必须考虑许多因素，包括预期的查询类型、读写比率和系统上的空闲内存量。 在开发索引策略时，您应该对应用程序的查询有深刻的理解。在构建索引之前，要映射出将要运行的查询类型，以便构建引用这些字段的索引。索引会带来性能成本，但与频繁查询大型数据集的成本相比，它更值得。考虑应用程序中每个查询的相对频率，以及该查询是否适合使用索引。 设计索引的最佳总体策略是使用与您将在生产环境中运行的数据集相似的数据集来分析各种索引配置，以查看哪种配置性能最佳。检查为您的集合创建的当前索引，以确保它们支持您当前和计划中的查询。如果不再使用索引，请删除该索引。 通常，MongoDB只使用一个索引来完成大多数查询。然而，一个$or查询的每个子句可能使用一个不同的索引，此外，MongoDB可以使用多个索引的交集。 下面的文档介绍了索引策略: 创建索引支持查询 当索引包含查询扫描的所有字段时，索引就支持查询。创建支持查询的索引可以极大地提高查询性能。 使用索引对查询结果进行排序 为了支持高效查询，在指定索引字段的顺序和排序顺序时，请使用这里的策略。 确保索引适合RAM 当索引适合RAM时，系统可以避免从磁盘读取索引，从而获得最快的处理速度。 创建以确保选择性的查询 选择性是指查询使用索引缩小结果的能力。选择性允许MongoDB在与完成查询相关的大部分工作中使用索引。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/Indexing-Strategies/Create-Indexes-to-Support-Your-Queries.html":{"url":"docs/Indexes/Indexing-Strategies/Create-Indexes-to-Support-Your-Queries.html","title":"Create Indexes to Support Your Queries","keywords":"","body":"创建索引来支持查询 在本页面 如果所有查询都使用相同的单键，则创建单键索引 创建复合索引以支持几种不同的查询 索引使用和排序 当索引包含查询扫描的所有字段时，索引就支持查询。查询扫描的是索引而不是集合。创建支持查询的索引可以极大地提高查询性能。 本文档描述创建支持查询的索引的策略。 如果所有查询使用相同的单键，则创建单键索引 如果只查询给定集合中的单个键，则只需为该集合创建一个单键索引。例如，您可以在product集合中创建category索引: db.products.createIndex( { \"category\": 1 } ) 创建复合索引来支持几个不同的查询 如果有时只查询一个键，而有时又查询该键和第二个键的组合，那么创建复合索引比创建单键索引更有效。MongoDB将对两个查询使用复合索引。例如，您可以在category和两者上创建索引item。 db.products.createIndex( { \"category\": 1, \"item\": 1 } ) 这允许您两个选择。您可以只查询category，也可以与category组合查询item。多个字段上的单个复合索引可以支持所有搜索这些字段的“前缀”子集的查询。 例子 以下是一个集合的索引: { x: 1, y: 1, z: 1 } 以下索引可以支持查询: { x: 1 } { x: 1, y: 1 } 在某些情况下，前缀索引可能提供更好的查询性能:例如，如果' z '是一个大数组。 {x: 1, y: 1, z: 1}索引也可以支持与以下索引相同的许多查询: { x: 1, z: 1 } 此外，{x: 1, z: 1}还有其他用途。给定以下查询: db.collection.find( { x: 5 } ).sort( { z: 1} ) {x: 1, z: 1}索引同时支持查询和排序操作，而{x: 1, y: 1, z: 1}索引只支持查询。有关排序的更多信息，请参见使用索引对查询结果排序。 从2.6版本开始，MongoDB可以使用索引交集来完成查询。是创建支持查询的复合索引，还是依赖索引交集，这取决于系统的具体情况。更多细节请参见索引交集和复合索引。 索引的使用和排序 若要使用索引进行字符串比较，操作还必须指定相同的排序规则。也就是说，如果索引指定了不同的排序规则，则具有排序规则的索引不能支持对索引字段执行字符串比较的操作。 例如，集合' myColl '在字符串字段' category '上有一个索引，其排序区域设置为' fr'。 db.myColl.createIndex( { category: 1 }, { collation: { locale: \"fr\" } } ) 下面的查询操作指定了与索引相同的排序规则，可以使用索引: db.myColl.find( { category: \"cafe\" } ).collation( { locale: \"fr\" } ) 但是，以下查询操作，默认使用“simple”二进制排序器，不能使用索引: db.myColl.find( { category: \"cafe\" } ) 对于索引前缀键不是字符串、数组和嵌入文档的复合索引，指定不同排序规则的操作仍然可以使用索引来支持对索引前缀键的比较。 例如，集合' myColl '在数值字段score和price以及字符串字段category上有一个复合索引;索引是用collation locale \"fr\" 创建的，用于字符串比较: db.myColl.createIndex( { score: 1, price: 1, category: 1 }, { collation: { locale: \"fr\" } } ) 以下使用 \"simple\" 二进制排序来进行字符串比较的操作可以使用索引: db.myColl.find( { score: 5 } ).sort( { price: 1 } ) db.myColl.find( { score: 5, price: { $gt: NumberDecimal( \"10\" ) } } ).sort( { price: 1 } ) 下面的操作使用 \"simple\"二进制排序对索引的category字段进行字符串比较，可以使用索引来完成查询的score: 5部分: db.myColl.find( { score: 5, category: \"cafe\" } ) Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/Indexing-Strategies/Use-Indexes-to-Sort-Query-Results.html":{"url":"docs/Indexes/Indexing-Strategies/Use-Indexes-to-Sort-Query-Results.html","title":"Use Indexes to Sort Query Results","keywords":"","body":"使用索引对查询结果进行排序 在本页面 使用单个字段索引排序 对多个字段上排序 索引使用和排序 由于索引包含有序的记录，MongoDB可以从包含排序字段的索引中获得排序结果。MongoDB 可能使用多个索引来支持排序操作如果排序使用相同的索引作为查询谓词。 如果MongoDB不能使用一个或多个索引来获取排序顺序，MongoDB必须对数据执行阻塞排序操作。阻塞排序表示MongoDB在返回结果之前必须使用和处理所有输入文档。阻塞排序不会阻塞对集合或数据库的并发操作。 如果MongoDB要求对阻塞排序操作使用超过100 MB的系统内存，则除非查询指定cursor.allowDiskUse()（MongoDB 4.4中的New），否则MongoDB返回错误。 allowDiskUse()允许MongoDB在处理阻塞排序操作时使用磁盘上的临时文件存储超过100兆字节系统内存限制的数据。 使用索引的排序操作通常比阻塞排序具有更好的性能。有关创建索引以支持排序操作的更多信息，请参见使用索引对查询结果排序。 注意 由于在MongoDB 3.6中对数组字段排序行为的改变，当排序一个数组索引多键索引查询计划包括一个阻塞排序阶段。新的排序行为可能会对性能产生负面影响。 在阻塞排序中，在生成输出之前，排序步骤必须使用所有输入。在非阻塞排序或索引排序中，排序步骤扫描索引以按请求的顺序生成结果。 使用单个字段索引排序 如果在单个字段上有升序或降序索引，则字段上的排序操作可以是任意方向的。 例如，为一个集合records在字段“a”上创建一个升序索引: db.records.createIndex( { a: 1 } ) 这个索引可以支持对“a”的升序排序: db.records.find().sort( { a: 1 } ) 索引也可以支持以下对“a”的降序排序，以逆序遍历索引: db.records.find().sort( { a: -1 } ) 对多个字段进行排序 创建一个复合索引来支持在多个字段上排序。 可以对索引的所有键或子集指定排序;但是，排序键必须按照它们在索引中出现的相同顺序列出。例如，一个索引键模式{a: 1, b: 1}可以支持{a: 1, b: 1}上的排序，但不支持{b: 1, a: 1}上的排序。 为一个查询使用复合索引排序,指定的排序方向所有键cursor.sort ()文件必须匹配索引键模式或匹配索引键的反模式。例如，索引键模式{a: 1, b: -1}可以支持对{a: 1, b: -1}和{a: -1, b: 1}的排序，但对{a: -1, b: -1}或{a: 1, b: 1}的排序不支持。 排序和索引前缀 如果排序键对应于索引键或索引前缀，MongoDB可以使用索引对查询结果排序。复合索引的prefix是由索引键模式开头的一个或多个键组成的子集。 例如，在data集合上创建一个复合索引: db.data.createIndex( { a:1, b: 1, c: 1, d: 1 } ) 那么，以下是该索引的前缀: { a: 1 } { a: 1, b: 1 } { a: 1, b: 1, c: 1 } 下面的查询和排序操作使用索引前缀对结果进行排序。这些操作不需要在内存中对结果集排序。 例子 索引的前缀 db.data.find().sort( { a: 1 } ) { a: 1 } db.data.find().sort( { a: -1 } ) { a: 1 } db.data.find().sort( { a: 1, b: 1 } ) { a: 1, b: 1 } db.data.find().sort( { a: -1, b: -1 } ) { a: 1, b: 1 } db.data.find().sort( { a: 1, b: 1, c: 1 } ) { a: 1, b: 1, c: 1 } db.data.find( { a: { $gt: 4 } } ).sort( { a: 1, b: 1 } ) { a: 1, b: 1 } 考虑下面的例子，索引的前缀键同时出现在查询谓词和排序中: db.data.find( { a: { $gt: 4 } } ).sort( { a: 1, b: 1 } ) 在这种情况下，MongoDB可以使用索引来按照排序指定的顺序检索文档。如示例所示，查询谓词中的索引前缀可以与排序中的前缀不同。 索引的排序和非前缀子集 索引可以支持对索引键模式的非前缀子集进行排序操作。为此，查询必须在排序键之前的所有前缀键上包含相等条件。 例如，集合data有以下索引: { a: 1, b: 1, c: 1, d: 1 } 下面的操作可以使用索引来获取排序顺序: 例子 Index Prefix db.data.find( { a: 5 } ).sort( { b: 1, c: 1 } ) { a: 1 , b: 1, c: 1 } db.data.find( { b: 3, a: 4 } ).sort( { c: 1 } ) { a: 1, b: 1, c: 1 } db.data.find( { a: 5, b: { $lt: 3} } ).sort( { b: 1 } ) { a: 1, b: 1 } 如最后一个操作所示，只有排序子集之前的索引字段在查询文档中必须具有相等条件；其他索引字段可以指定其他条件。 如果查询没有在排序规范之前或重叠的索引前缀上指定相等条件，则操作将无法有效地使用索引。例如，下面的操作指定一个排序文档为{c: 1}，但是查询文档不包含前面索引字段“a”和“b”的相等匹配: db.data.find( { a: { $gt: 2 } } ).sort( { c: 1 } ) db.data.find( { c: 5 } ).sort( { c: 1 } ) 这些操作不能有效地使用索引{a: 1, b: 1, c: 1, d: 1}，甚至不能使用索引来检索文档。 索引的使用和排序 若要使用索引进行字符串比较，操作还必须指定相同的排序规则。也就是说，如果索引指定了不同的排序规则，则具有排序规则的索引不能支持对索引字段执行字符串比较的操作。 例如，集合myColl在字符串字段category上有一个索引，其排序区域设置为fr 。 db.myColl.createIndex( { category: 1 }, { collation: { locale: \"fr\" } } ) 下面的查询操作指定了与索引相同的排序规则，可以使用索引: db.myColl.find( { category: \"cafe\" } ).collation( { locale: \"fr\" } ) 但是，以下查询操作，默认使用simple二进制排序器，不能使用索引: db.myColl.find( { category: \"cafe\" } ) 对于索引前缀键不是字符串、数组和嵌入文档的复合索引，指定不同排序规则的操作仍然可以使用索引来支持对索引前缀键的比较。 例如，集合myColl在数值字段score和price以及字符串字段category上有一个复合索引;索引是用collation locale ' fr '创建的，用于字符串比较: db.myColl.createIndex( { score: 1, price: 1, category: 1 }, { collation: { locale: \"fr\" } } ) 以下使用' simple '二进制排序来进行字符串比较的操作可以使用索引: db.myColl.find( { score: 5 } ).sort( { price: 1 } ) db.myColl.find( { score: 5, price: { $gt: NumberDecimal( \"10\" ) } } ).sort( { price: 1 } ) 下面的操作使用\"simple\"二进制排序对索引的category字段进行字符串比较，可以使用索引来完成查询的score: 5部分: db.myColl.find( { score: 5, category: \"cafe\" } ) Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/Indexing-Strategies/Ensure-Indexes-Fit-in-RAM.html":{"url":"docs/Indexes/Indexing-Strategies/Ensure-Indexes-Fit-in-RAM.html","title":"Ensure Indexes Fit in RAM","keywords":"","body":"确保索引适合RAM 在本页面 仅在RAM中保存最近值的索引 为了实现最快的处理，请确保索引完全适合RAM，以便系统可以避免从磁盘读取索引。 要检查索引的大小，使用 db.collection.totalIndexSize() 帮助器，该帮助程序以字节为单位返回数据： > db.collection.totalIndexSize() 4294976499 上面的示例显示了一个接近4.3GB的索引大小。为了确保该索引适合RAM，您不仅必须拥有多于该数量的可用RAM，而且还必须为其余工作集提供RAM 。还请记住： 如果您拥有并使用多个集合，则必须考虑所有集合上所有索引的大小。索引和工作集必须能够同时装入内存。 在一些有限的情况下，索引不需要装入内存。参见只在RAM中保存最近值的索引。 也可以看看： collStats 和 db.collection.stats() 仅在RAM中保存最近值的索引 索引不必在所有情况下都完全适合RAM。如果索引字段的值随每次插入而增加，并且大多数查询选择最近添加的文档；那么MongoDB只需要将索引中保留最新或“最右边”值的部分保留在RAM中。这样可以有效地将索引用于读取和写入操作，并最大程度地减少支持索引所需的RAM数量。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/Indexing-Strategies/Create-Queries-that-Ensure-Selectivity.html":{"url":"docs/Indexes/Indexing-Strategies/Create-Queries-that-Ensure-Selectivity.html","title":"Create Queries that Ensure Selectivity","keywords":"","body":"创建以确保选择性的查询 选择性是指查询使用索引缩小结果的能力。有效的索引更具选择性，允许MongoDB使用索引来完成与完成查询相关的大部分工作。 为了确保选择性，编写限制索引字段可能的文档数量的查询。编写相对于索引数据具有适当选择性的查询。 例子 假设您有一个名为“status”的字段，其中可能的值是new和processing。如果你在“status”上添加索引，你就创建了一个低选择性的索引。索引在查找记录方面帮助不大。 根据您的查询，一种更好的策略是创建一个包含低选择性字段和另一个字段的 复合索引。例如，您可以在status和上创建复合索引created_at. 另一个选择，同样取决于您的用例，可能是使用单独的集合，每个状态一个集合。 例子 考虑一个集合上的索引{a: 1}(即键“a”按升序排序的索引)，其中“a”有三个值均匀分布在集合中: { _id: ObjectId(), a: 1, b: \"ab\" } { _id: ObjectId(), a: 1, b: \"cd\" } { _id: ObjectId(), a: 1, b: \"ef\" } { _id: ObjectId(), a: 2, b: \"jk\" } { _id: ObjectId(), a: 2, b: \"lm\" } { _id: ObjectId(), a: 2, b: \"no\" } { _id: ObjectId(), a: 3, b: \"pq\" } { _id: ObjectId(), a: 3, b: \"rs\" } { _id: ObjectId(), a: 3, b: \"tv\" } 如果你查询{a: 2, b: \"no\"}， MongoDB必须扫描3个文档在集合中返回一个匹配的结果。类似地，{a: {$gt: 1}， b: \"tv\"}的查询必须扫描6个文档，也要返回一个结果。 考虑一个集合上的相同索引，其中“a”有9 个值均匀分布在整个集合中: { _id: ObjectId(), a: 1, b: \"ab\" } { _id: ObjectId(), a: 2, b: \"cd\" } { _id: ObjectId(), a: 3, b: \"ef\" } { _id: ObjectId(), a: 4, b: \"jk\" } { _id: ObjectId(), a: 5, b: \"lm\" } { _id: ObjectId(), a: 6, b: \"no\" } { _id: ObjectId(), a: 7, b: \"pq\" } { _id: ObjectId(), a: 8, b: \"rs\" } { _id: ObjectId(), a: 9, b: \"tv\" } 如果您查询{a: 2, b: \"cd\"}， MongoDB必须只扫描一个文档来完成查询。索引和查询更具选择性，因为' a '的值是均匀分布的，和查询可以使用索引选择特定的文档。 然而，尽管 a 上的索引更具有选择性，但是像{a: {$gt: 5}， b: \"tv\"}这样的查询仍然需要扫描4个文档。 如果整体选择性很低，并且MongoDB必须读取大量文档才能返回结果，那么有些查询在没有索引的情况下可能执行得更快。要确定性能，请参阅度量索引使用。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Indexes/Indexing-Reference.html":{"url":"docs/Indexes/Indexing-Reference.html","title":"Indexing Reference","keywords":"","body":"索引参考 在本页面 mongoShell中的索引方法 索引数据库命令 地理空间查询选择器 索引查询修饰符 mongoShell中的索引方法 名称 描述 db.collection.createIndex() 在集合上建立索引。 db.collection.dropIndex() 删除集合上的指定索引。 db.collection.dropIndexes() 删除集合上的所有索引。 db.collection.getIndexes() 返回描述集合中现有索引的文档数组。 db.collection.reIndex() 重建集合上的所有现有索引。 db.collection.totalIndexSize() 报告集合上的索引使用的总大小。提供围绕输出totalIndexSize字段的包装器collStats。 cursor.explain() 报告有关游标的查询执行计划。 cursor.hint() 强制MongoDB对查询使用特定的索引。 cursor.max() 指定游标的排他上限。用于cursor.hint() cursor.min() 指定一个游标的下限值。用于cursor.hint() 索引数据库命令 名称 描述 createIndexes 为一个集合构建一个或多个索引。 dropIndexes 从集合中删除索引。 compact 对集合进行碎片整理并重建索引。 reIndex 重建集合上的所有索引。 validate 内部命令，用于扫描集合的数据并为正确性编制索引。 geoSearch 执行使用MongoDB的干草堆索引功能的地理空间查询。 checkShardingIndex 验证分片键索引的内部命令。 地理空间查询选择器 名称 描述 $geoWithin 选择边界GeoJSON几何内的几何。该2dsphere和2D指标支持 $geoWithin。 $geoIntersects 选择与GeoJSON几何形状相交的几何形状。该2dsphere索引支持 $geoIntersects。 $near 返回点附近的地理空间对象。需要地理空间索引。该2dsphere和2D指标支持 $near。 $nearSphere 返回球体上某个点附近的地理空间对象。需要地理空间索引。该2dsphere和2D指标支持 $nearSphere。 索引查询修饰符 名称 描述 $explain 强制MongoDB报告查询执行计划。请参阅explain()。 $hint 强制MongoDB使用特定索引。看到hint() $max 指定要在查询中使用的索引的排他上限。请参阅max()。 $min 指定一个包容性的下限为索引在查询中使用。请参阅min()。 $returnKey 强制光标只返回索引中包含的字段。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Security/Audit.html":{"url":"docs/Security/Audit.html","title":"Auditing","keywords":"","body":"Auditing Auditing 审计 On this page [Enable and Configure Audit Output]启用和配置审计输出(https://docs.mongodb.com/manual/core/auditing/#enable-and-configure-audit-output) [Audit Events and Filter]审计事件和过滤器(https://docs.mongodb.com/manual/core/auditing/#audit-events-and-filter) [Audit Guarantee]审计保证 (https://docs.mongodb.com/manual/core/auditing/#audit-guarantee) MongoDB Enterprise includes an auditing capability for mongod and mongos instances. The auditing facility allows administrators and users to track system activity for deployments with multiple users and applications.MongoDB 企业版包含针对 mongod 和 mongos 实例的审计功能 。审计功能使管理员和用户可以跟踪具有多个用户和多个客户端应用的 mongodb 的运行情况。 Enable and Configure Audit Output 启用和配置审计输出 The auditing facility can write audit events to the console, the syslog, a JSON file, or a BSON file. To enable auditing for MongoDB Enterprise, see Configure Auditing.审计功能可以将审计事件写入控制台console，syslog，JSON 文件或 BSON 文件。要为 MongoDB 企业版启用审计，请参阅配置审计。For information on the audit log messages, see System Event Audit Messages.有关审核日志消息的信息，请参阅系统事件审计消息。 Audit Events and Filter 审计事件和过滤器 Once enabled, the auditing system can record the following operations [1]:启用后，审计系统可以记录以下操作[1]: schema (DDL), replica set and sharded cluster, authentication and authorization, and CRUD operations (requires auditAuthorizationSuccess set to true). 模式（DDL）, 副本集集群和分片集群， 认证和授权，以及 CRUD操作（要求auditAuthorizationSuccess设置为true）。 For details on audited actions, see Audit Event Actions, Details, and Results.有关审计的操作的详细信息，请参阅审计事件操作，详细信息和结果。With the auditing system, you can set up filters to restrict the events captured. To set up filters, see Configure Audit Filters.使用审计系统，您可以设置过滤器以限制捕获的事件。要设置过滤器，请参阅“配置审计过滤器”。[1] Operations in an aborted transaction still generate audit events. However, there is no audit event that indicates that the transaction aborted.在一个被中止的事务中[1]中的操作任然会生成一个审计事件，但是没有一个审计事件指示事务被中止了。 Audit Guarantee 审计保证 The auditing system writes every audit event [2] to an in-memory buffer of audit events. MongoDB writes this buffer to disk periodically. For events collected from any single connection, the events have a total order: if MongoDB writes one event to disk, the system guarantees that it has written all prior events for that connection to disk.审计系统将每个审计事件2写入审计事件的内存缓冲区中。MongoDB定期将此缓冲区写入磁盘。对于从任何单个连接收集的事件，这些事件具有总顺序：如果MongoDB将一个事件写入磁盘，系统将保证已将该连接的所有先前事件写入磁盘。If an audit event entry corresponds to an operation that affects the durable state of the database, such as a modification to data, MongoDB will always write the audit event to disk before writing to the journal for that entry.如果审计事件条目对应的操作影响数据库的持久状态，如修改数据的操作，则MongoDB始终会在将审计事件写入磁盘之前将事件条目写入日志That is, before adding an operation to the journal, MongoDB writes all audit events on the connection that triggered the operation, up to and including the entry for the operation.也就是说，在将操作添加到日志之前，MongoDB会在触发该操作的连接上写入所有审计事件，直到并包括该操作的条目。These auditing guarantees require that MongoDB run with journaling enabled.这些审计保证要求MongoDB在journaling启用的情况下运行 。 WARNING 警告 MongoDB may lose events if the server terminates before it commits the events to the audit log. The client may receive confirmation of the event before MongoDB commits to the audit log.如果服务器在将事件提交到审计日志之前终止，则MongoDB可能会丢失事件。在MongoDB提交审计日志之前，客户端可能会收到事件确认。For example, while auditing an aggregation operation, the server might crash after returning the result but before the audit log flushes.例如，在审计聚合操作时，服务器可能在返回结果之后但在刷新审计日志之前崩溃。[2] Audit configuration can include a filter to limit events to audit.2审计配置可以包括一个筛选器，以限制要审计的事件。 附录： Configure Auditing 配置审计：https://docs.mongodb.com/manual/tutorial/configure-auditing/Configure Audit Filters 配置审计过滤器：https://docs.mongodb.com/manual/tutorial/configure-audit-filters/System Event Audit Messages 系统事件审计消息： https://docs.mongodb.com/manual/reference/audit-message/ Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Security/Audit/Configure-Audit-Filters.html":{"url":"docs/Security/Audit/Configure-Audit-Filters.html","title":"Configure Audit Filters","keywords":"","body":"Configure-Audit-Filters Configure Audit Filters¶ 配置审计过滤器¶ On this page在本页 --auditFilter Option Examples --auditFilter 选项 例子 Auditing in MongoDB AtlasMongoDB Atlas 中的审计MongoDB Atlas supports auditing for all M10 and larger clusters.MongoDB Atlas支持对所有M10和更大的集群进行审计。Atlas supports specifying a JSON-formatted audit filter as documented in Configure Audit Filters and using the Atlas audit filter builder for simplified auditing configuration.Atlas支持在配置审计过滤器中指定JSON格式的审计过滤器，并使用Atlas审计过滤器构建器来简化审计配置。To learn more, see the Atlas documentation for Set Up Database Auditing and Configure a Custom Auditing Filter.要了解更多信息，请参阅Atlas文档中的设置数据库审计和配置自定义审计过滤器。MongoDB Enterprise supports auditing of various operations.MongoDB 企业版支持审计各种操作。When enabled, the audit facility, by default, records all auditable operations as detailed in Audit Event Actions, Details, and Results.启用审计功能会默认的记录所有可审计的操作，如Audit Event Actions, Details, and Results。To specify which events to record, the audit feature includes the --auditFilter option.为了能指定那些事件需要被记录，审计功能包含--auditFilter选项。Note注意Starting in MongoDB 3.6, mongod and mongos bind to localhost by default.从mongoDB 3.6开始，mongod and mongos默认绑定localhost。If the members of your deployment are run on different hosts or if you wish remote clients to connect to your deployment, you must specify --bind_ip or net.bindIp.如果你部署的实例运行在不同的主机上或者如果你希望远程客户端连接到部署实例，你必须指定--bind_ip or net.bindIp.For more information, see Localhost Binding Compatibility Changes.更多信息，请查看Localhost 绑定兼容性更改。Before you bind to other ip addresses, consider enabling access control and other security measures listed in Security Checklist to prevent unauthorized access.绑定到其他IP地址之前，请考虑启用访问控制和“安全性检查表”中的列出的其他安全措施，以防止未经授权的访问。 --auditFilter Option¶ --auditFilter 选项¶ The --auditFilter option takes a string representation of a query document of the form:--auditFilter`选项采用以下查询文档的字符串的表示形式：copy { : , ... } 复制 { : , ... } The can be any field in the audit message, including fields returned in the param document. 可以是审计消息中的任何字段，包括param文档中返回的字段。 The is a query condition expression. 是一个查询条件表达式。 To specify an audit filter, enclose the filter document in single quotes to pass the document as a string.指定一个审计过滤器，可以将过滤器文档括在单引号中使其转成字符串。To specify the audit filter in a configuration file, you must use the YAML format of the configuration file.在配置文件中指定审计过滤器，必须使用配置文件的YAML格式。 Examples¶ 例子¶ Filter for Multiple Operation Types¶ 多种操作类型的过滤器¶ The following example audits only the createCollection and dropCollection actions by using the filter:以下示例通过使用过滤器仅审计[createCollection]和[dropCollection]操作：copy{ atype: { $in: [\"createCollection\", \"dropCollection\"] } }复制 { atype: { $in: [\"createCollection\", \"dropCollection\"] } } To specify an audit filter, enclose the filter document in single quotes to pass the document as a string.指定一个审计过滤器，可以将过滤器文档括在单引号中使其转成字符串。copymongod --dbpath data/db --auditDestination file --auditFilter '{ atype: { $in: [ \"createCollection\", \"dropCollection\" ] } }' --auditFormat BSON --auditPath data/db/auditLog.bson复制 mongod --dbpath data/db --auditDestination file --auditFilter '{ atype: { $in: [ \"createCollection\", \"dropCollection\" ] } }' --auditFormat BSON --auditPath data/db/auditLog.bson Include additional options as required for your configuration. For instance, if you wish remote clients to connect to your deployment or your deployment members are run on different hosts, specify the --bind_ip. For more information, see Localhost Binding Compatibility Changes.包括配置所需的其他选项。例如，如果您希望远程客户端连接到您的部署，或者您的部署成员在不同的主机上运行，请指定--bind_ip参数。更多信息，请参见Localhost绑定兼容性更改。To specify the audit filter in a configuration file, you must use the YAML format of the configuration file.在配置文件中指定审计过滤器，必须使用配置文件的YAML格式。copy storage: dbPath: data/db auditLog: destination: file format: BSON path: data/db/auditLog.bson filter: '{ atype: { $in: [ \"createCollection\", \"dropCollection\" ] } }' 复制 storage: dbPath: data/db auditLog: destination: file format: BSON path: data/db/auditLog.bson filter: '{ atype: { $in: [ \"createCollection\", \"dropCollection\" ] } }' Filter on Authentication Operations on a Single Database¶ 筛选单个数据库上的身份验证操作¶ The can include any field in the audit message. For authentication operations (i.e. atype: \"authenticate\"), the audit messages include a db field in the param document.可以包含审计消息中的任何字段。对于身份认证操作(即，atype: \"authenticate\")，审计消息中的param文档中包含‘db’字段。The following example audits only the authenticate operations that occur against the test database by using the filter:以下示例使用过滤器仅审计针对test数据库的身份验证操作。copy{ atype: \"authenticate\", \"param.db\": \"test\" }复制 { atype: \"authenticate\", \"param.db\": \"test\" } To specify an audit filter, enclose the filter document in single quotes to pass the document as a string.指定一个审计过滤器，可以将过滤器文档括在单引号中使其转成字符串。copymongod --dbpath data/db --auth --auditDestination file --auditFilter '{ atype: \"authenticate\", \"param.db\": \"test\" }' --auditFormat BSON --auditPath data/db/auditLog.bson复制 mongod --dbpath data/db --auth --auditDestination file --auditFilter '{ atype: \"authenticate\", \"param.db\": \"test\" }' --auditFormat BSON --auditPath data/db/auditLog.bson Include additional options as required for your configuration. For instance, if you wish remote clients to connect to your deployment or your deployment members are run on different hosts, specify the --bind_ip. For more information, see Localhost Binding Compatibility Changes.包括配置所需的其他选项。例如，如果您希望远程客户端连接到您的部署，或者您的部署成员在不同的主机上运行，请指定--bind_ip参数。更多信息，请参见Localhost绑定兼容性更改。To specify the audit filter in a configuration file, you must use the YAML format of the configuration file.在配置文件中指定审计过滤器，必须使用配置文件的YAML格式。copy storage: dbPath: data/db security: authorization: enabled auditLog: destination: file format: BSON path: data/db/auditLog.bson filter: '{ atype: \"authenticate\", \"param.db\": \"test\" }' 复制 storage: dbPath: data/db security: authorization: enabled auditLog: destination: file format: BSON path: data/db/auditLog.bson filter: '{ atype: \"authenticate\", \"param.db\": \"test\" }' To filter on all authenticate operations across databases, use the filter { atype: \"authenticate\" }.要过滤数据库中的所有身份验证操作，请使用过滤器{ atype: \"authenticate\" }。 Filter on Collection Creation and Drop Operations for a Single Database¶ 筛选单个数据库的集合创建和删除操作¶ The can include any field in the audit message. For collection creation and drop operations (i.e. atype: \"createCollection\" and atype: \"dropCollection\"), the audit messages include a namespace ns field in the param document.可以包含审计消息中的任何字段。对于集合创建和删除操作(即，atype: \"createCollection\"和atype: \"dropCollection\")，审计消息中的param文档中包含‘ns’字段。The following example audits only the createCollection and dropCollection operations that occur against the test database by using the filter:以下示例使用过滤器仅审计针对test数据库的创建集合和删除集合操作。Note注意The regular expression requires two backslashes (\\\\) to escape the dot (.).正则表达式需要两个反斜杠(\\\\)才能转义(.)copy { atype: { $in: [ \"createCollection\", \"dropCollection\" ] }, \"param.ns\": /^test\\\\./ } } 复制 { atype: { $in: [ \"createCollection\", \"dropCollection\" ] }, \"param.ns\": /^test\\\\./ } } To specify an audit filter, enclose the filter document in single quotes to pass the document as a string.将过滤器文档括在单引号中使其转成字符串来指定一个审计过滤器。copy mongod --dbpath data/db --auth --auditDestination file --auditFilter '{ atype: { $in: [ \"createCollection\", \"dropCollection\" ] }, \"param.ns\": /^test\\\\./ } }' --auditFormat BSON --auditPath data/db/auditLog.bson 复制 mongod --dbpath data/db --auth --auditDestination file --auditFilter '{ atype: { $in: [ \"createCollection\", \"dropCollection\" ] }, \"param.ns\": /^test\\\\./ } }' --auditFormat BSON --auditPath data/db/auditLog.bson Include additional options as required for your configuration. For instance, if you wish remote clients to connect to your deployment or your deployment members are run on different hosts, specify the --bind_ip. For more information, see Localhost Binding Compatibility Changes.包括配置所需的其他选项。例如，如果您希望远程客户端连接到您的部署，或者您的部署成员在不同的主机上运行，请指定--bind_ip参数。更多信息，请参见Localhost绑定兼容性更改。To specify the audit filter in a configuration file, you must use the YAML format of the configuration file.在配置文件中指定审计过滤器，必须使用配置文件的YAML格式。copy storage: dbPath: data/db security: authorization: enabled auditLog: destination: file format: BSON path: data/db/auditLog.bson filter: '{ atype: { $in: [ \"createCollection\", \"dropCollection\" ] }, \"param.ns\": /^test\\\\./ } }' 复制 storage: dbPath: data/db security: authorization: enabled auditLog: destination: file format: BSON path: data/db/auditLog.bson filter: '{ atype: { $in: [ \"createCollection\", \"dropCollection\" ] }, \"param.ns\": /^test\\\\./ } }' Filter by Authorization Role¶ 通过授权角色进行筛选¶ The following example audits operations by users with readWrite role on the test database, including users with roles that inherit from readWrite, by using the filter:以下示例通过使用过滤器来审核审计test数据库上具有[readWrite]角色的用户的操作，包括具有从[readWrite]继承的角色的用户：copy { roles: { role: \"readWrite\", db: \"test\" } } 复制 { roles: { role: \"readWrite\", db: \"test\" } } To specify an audit filter, enclose the filter document in single quotes to pass the document as a string.指定一个审计过滤器，可以将过滤器文档括在单引号中使其转成字符串。copy mongod --dbpath data/db --auth --auditDestination file --auditFilter '{ roles: { role: \"readWrite\", db: \"test\" } }' --auditFormat BSON --auditPath data/db/auditLog.bson 复制 mongod --dbpath data/db --auth --auditDestination file --auditFilter '{ roles: { role: \"readWrite\", db: \"test\" } }' --auditFormat BSON --auditPath data/db/auditLog.bson Include additional options as required for your configuration. For instance, if you wish remote clients to connect to your deployment or your deployment members are run on different hosts, specify the --bind_ip. For more information, see Localhost Binding Compatibility Changes.包括配置所需的其他选项。例如，如果您希望远程客户端连接到您的部署，或者您的部署成员在不同的主机上运行，请指定--bind_ip参数。更多信息，请参见Localhost绑定兼容性更改。To specify the audit filter in a configuration file, you must use the YAML format of the configuration file.在配置文件中指定审计过滤器，必须使用配置文件的YAML格式。copy storage: dbPath: data/db security: authorization: enabled auditLog: destination: file format: BSON path: data/db/auditLog.bson filter: '{ roles: { role: \"readWrite\", db: \"test\" } }' 复制 storage: dbPath: data/db security: authorization: enabled auditLog: destination: file format: BSON path: data/db/auditLog.bson filter: '{ roles: { role: \"readWrite\", db: \"test\" } }' Filter on Read and Write Operations¶ 读写操作中的过滤器¶ To capture read and write operations in the audit, you must also enable the audit system to log authorization successes using the 审计授权成功 parameter. [1]要在审核审计中进行捕获read和write操作，必须设置审计参数使审计系统记录身份验证成功。1Note注意Enabling auditAuthorizationSuccess degrades performance more than logging only the authorization failures.启用审计授权成功与仅记录授权失败相比会使性能下降更多。The following example audits the find(), insert(), remove(), update(), save(), and findAndModify() operations by using the filter:下面的例子用来审计find(), insert(), remove(), update(), save()和 findAndModify()这些操作，过滤器如下：copy { atype: \"authCheck\", \"param.command\": { $in: [ \"find\", \"insert\", \"delete\", \"update\", \"findandmodify\" ] } } 复制 { atype: \"authCheck\", \"param.command\": { $in: [ \"find\", \"insert\", \"delete\", \"update\", \"findandmodify\" ] } } To specify an audit filter, enclose the filter document in single quotes to pass the document as a string.指定一个审计过滤器，可以将过滤器文档括在单引号中使其转成字符串。copy mongod --dbpath data/db --auth --setParameter auditAuthorizationSuccess=true --auditDestination file --auditFilter '{ atype: \"authCheck\", \"param.command\": { $in: [ \"find\", \"insert\", \"delete\", \"update\", \"findandmodify\"] } }' --auditFormat BSON --auditPath data/db/auditLog.bson 复制 mongod --dbpath data/db --auth --setParameter auditAuthorizationSuccess=true --auditDestination file --auditFilter '{ atype: \"authCheck\", \"param.command\": { $in: [ \"find\", \"insert\", \"delete\", \"update\", \"findandmodify\"] } }' --auditFormat BSON --auditPath data/db/auditLog.bson Include additional options as required for your configuration. For instance, if you wish remote clients to connect to your deployment or your deployment members are run on different hosts, specify the --bind_ip. For more information, see Localhost Binding Compatibility Changes.包括配置所需的其他选项。例如，如果您希望远程客户端连接到您的部署，或者您的部署成员在不同的主机上运行，请指定--bind_ip参数。更多信息，请参见Localhost绑定兼容性更改。To specify the audit filter in a configuration file, you must use the YAML format of the configuration file.在配置文件中指定审计过滤器，必须使用配置文件的YAML格式。copy storage: dbPath: data/db security: authorization: enabled auditLog: destination: file format: BSON path: data/db/auditLog.bson filter: '{ atype: \"authCheck\", \"param.command\": { $in: [ \"find\", \"insert\", \"delete\", \"update\", \"findandmodify\" ] } }' setParameter: { auditAuthorizationSuccess: true } Filter on Read and Write Operations for a Collection¶ 过滤集合的读写操作¶ To capture read and write operations in the audit, you must also enable the audit system to log authorization successes using the auditAuthorizationSuccess parameter. [1]要在审核审计中进行捕获read和write操作，还必须使用审计授权成功参数使审核审计系统能够记录授权成功。 [1]Note注意Enabling auditAuthorizationSuccess degrades performance more than logging only the authorization failures.启用审计授权成功与仅记录授权失败相比，启用会使性能下降更多。The following example audits the find(), insert(), remove(), update(), save(), and findAndModify() operations for the collection orders in the database test by using the filter:下面的例子用来审计在test数据库的orders集合上的find(), insert(), remove(), update(), save(), and findAndModify()操作，过滤器如下：copy { atype: \"authCheck\", \"param.ns\": \"test.orders\", \"param.command\": { $in: [ \"find\", \"insert\", \"delete\", \"update\", \"findandmodify\" ] } } 复制 { atype: \"authCheck\", \"param.ns\": \"test.orders\", \"param.command\": { $in: [ \"find\", \"insert\", \"delete\", \"update\", \"findandmodify\" ] } } To specify an audit filter, enclose the filter document in single quotes to pass the document as a string.指定一个审计过滤器，可以将过滤器文档括在单引号中使其转成字符串。copy mongod --dbpath data/db --auth --setParameter auditAuthorizationSuccess=true --auditDestination file --auditFilter '{ atype: \"authCheck\", \"param.ns\": \"test.orders\", \"param.command\": { $in: [ \"find\", \"insert\", \"delete\", \"update\", \"findandmodify\" ] } }' --auditFormat BSON --auditPath data/db/auditLog.bson 复制 mongod --dbpath data/db --auth --setParameter auditAuthorizationSuccess=true --auditDestination file --auditFilter '{ atype: \"authCheck\", \"param.ns\": \"test.orders\", \"param.command\": { $in: [ \"find\", \"insert\", \"delete\", \"update\", \"findandmodify\" ] } }' --auditFormat BSON --auditPath data/db/auditLog.bson Include additional options as required for your configuration. For instance, if you wish remote clients to connect to your deployment or your deployment members are run on different hosts, specify the --bind_ip. For more information, see Localhost Binding Compatibility Changes.包括配置所需的其他选项。例如，如果您希望远程客户端连接到您的部署，或者您的部署成员在不同的主机上运行，请指定--bind_ip参数。有关更多信息，请参见Localhost绑定兼容性更改。To specify the audit filter in a configuration file, you must use the YAML format of the configuration file.在配置文件中指定审计过滤器，必须使用配置文件的YAML格式。copy storage: dbPath: data/db security: authorization: enabled auditLog: destination: file format: BSON path: data/db/auditLog.bson filter: '{ atype: \"authCheck\", \"param.ns\": \"test.orders\", \"param.command\": { $in: [ \"find\", \"insert\", \"delete\", \"update\", \"findandmodify\" ] } }' setParameter: { auditAuthorizationSuccess: true } 复制 storage: dbPath: data/db security: authorization: enabled auditLog: destination: file format: BSON path: data/db/auditLog.bson filter: '{ atype: \"authCheck\", \"param.ns\": \"test.orders\", \"param.command\": { $in: [ \"find\", \"insert\", \"delete\", \"update\", \"findandmodify\" ] } }' setParameter: { auditAuthorizationSuccess: true } See also也可以看看Configure Auditing, Auditing, System Event Audit Messages配置审计, 审计, 系统事件审计消息[1](1, 2) You can enable auditAuthorizationSuccess parameter without enabling --auth; however, all operations will return success for authorization checks.[1]（1，2）可以启用审计授权成功参数不启用--auth; 但是所有操作将返回成功以进行授权检查。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Security/Audit/configure-Auditing.html":{"url":"docs/Security/Audit/configure-Auditing.html","title":"configure Auditing","keywords":"","body":"configure-Auditing Configure Auditing 配置审计 On this page在本页 [Enable and Configure Audit Output]启用和配置审计输出(#enable-and-configure-audit-output) 启用和配置审计输出 Auditing in MongoDB Atlas:MONGODB ATLAS中的审计:MongoDB Atlas supports auditing for all M10 and larger clusters.MongoDB Atlas支持对所有M10更大的集群进行审计。Atlas supports specifying a JSON-formatted audit filter as documented in Configure Audit Filters and using the Atlas audit filter builder for simplified auditing configuration.Atlas支持指定“配置审计过滤器”中所述的JSON格式的审计过滤器， 并使用Atlas审计过滤器构建器来简化审计配置。To learn more, see the Atlas documentation for Set Up Database Auditing and Configure a Custom Auditing Filter.要了解更多信息，请参阅Atlas文档中的“设置数据库审计和配置自定义审计过滤器”。MongoDB Enterprise supports auditing of various operations.MongoDB 企业版支持审计各种操作。A complete auditing solution must involve all mongod server and mongos router processes.完整的审计解决方案必须涉及所有 mongod服务器 和 mongos 路由器过程。The audit facility can write audit events to the console, the syslog (option is unavailable on Windows), a JSON file, or a BSON file. For details on the audited operations and the audit log messages, see System Event Audit Messages.审计工具可以将审计事件写入到控制台、syslog（Windows上不提供该 选项）、JSON文件或BSON文件。有关审计的操作和审计日志消息的详细信息，请参阅系统事件审计消息系统事件审计消息。 Enable and Configure Audit Output¶ 启用和配置审计输出 Use the --auditDestination option to enable auditing and specify where to output the audit events.使用该--auditDestination选项可以启用审计并指定在何处输出审计事件。Warning警告For sharded clusters, if you enable auditing on mongos instances, you must enable auditing on all mongod instances in the cluster, i.e. shards and config servers.对于分片群集，如果对mongos实例启用审计，则必须对群集中的所有mongod实例（即分片和配置服务器）启用审计。 Output to Syslog¶ 输出到Syslog To enable auditing and print audit events to the syslog (option is unavailable on Windows) in JSON format, specify syslog for the --auditDestination setting. For example:要启用审计并将审计事件以JSON格式打印到syslog（在Windows上该选项不可用），请为--auditDestination设置为syslog。例如： mongod --dbpath data/db --auditDestination syslog Include additional options as required for your configuration. For instance, if you wish remote clients to connect to your deployment or your deployment members are run on different hosts, specify the --bind_ip. For more information, see Localhost Binding Compatibility Changes.包括配置所需的其他选项。例如，如果您希望远程客户端连接到您的部署，或者您的部署成员在不同的主机上运行，请指定 --bind_ip。有关更多信息，请参见 Localhost绑定兼容性更改。Important重要Before you bind to other ip addresses, consider enabling access control and other security measures listed in Security Checklist to prevent unauthorized access.绑定到其他IP地址之前，请考虑启用范围控制和其他绑定到其他IP地址之前，请考虑启用“安全性检查表” 中列出的访问控制和其他安全措施，以防止未经授权的访问。Warning警告The syslog message limit can result in the truncation of the audit messages. The auditing system will neither detect the truncation nor error upon its occurrence.syslog消息限制可能导致审计消息被截断。审计系统不会在发生截断时检测到截断或错误。You may also specify these options in the configuration file:您也可以在配置文件中指定以下选项： storage: dbPath: data/db auditLog: destination: syslog Output to Console¶ 输出到控制台 To enable auditing and print the audit events to standard output (i.e. stdout), specify console for the --auditDestination setting. For example:要启用审计并将审计事件打印到标准输出（即stdout），请为--auditDestination指定参数为'console'。例如： mongod --dbpath data/db --auditDestination console Include additional options as required for your configuration. For instance, if you wish remote clients to connect to your deployment or your deployment members are run on different hosts, specify the --bind_ip. For more information, see Localhost Binding Compatibility Changes.包括配置所需的其他选项。例如，如果您希望远程客户端连接到您的部署，或者您的部署成员在不同的主机上运行，请指定 --bind_ip。有关更多信息，请参见 Localhost绑定兼容性更改。Important重要Before you bind to other ip addresses, consider enabling access control and other security measures listed in Security Checklist to prevent unauthorized access.绑定到其他IP地址之前，请考虑启用“安全性检查表”中列出的访问控制和其他安全措施，以防止未经授权的访问。You may also specify these options in the configuration file:您也可以在配置文件中指定以下选项： storage: dbPath: data/db auditLog: destination: console Output to JSON File¶ 输出到JSON文件¶ To enable auditing and print audit events to a file in JSON format, specify the following options:要启用审计并将审计事件打印为BSON二进制格式的文件，请指定以下选项：Option Value--auditDestination file--auditFormat JSON--auditPath The output filename. Accepts either the full path name or relative path name. 选项            值 --auditDestination   file --auditFormat     JSON --auditPath       输出文件名，接受完整路径名或相对路径名。For example, the following enables auditing and records audit events to a file with the relative path name of data/db/auditLog.json:例如，以下选项启用审计并将审计事件记录到相对路径'data/db/auditLog.json'的文件中： mongod --dbpath data/db --auditDestination file --auditFormat JSON --auditPath data/db/auditLog.json Include additional options as required for your configuration. For instance, if you wish remote clients to connect to your deployment or your deployment members are run on different hosts, specify the --bind_ip. For more information, see Localhost Binding Compatibility Changes.包括配置所需的其他选项。例如，如果您希望远程客户端连接到您的部署，或者您的部署成员在不同的主机上运行，请指定--bind_ip参数。有关更多信息，请参见Localhost绑定兼容性更改。Important:重要：Before you bind to other ip addresses, consider enabling access control and other security measures listed in Security Checklist to prevent unauthorized access.绑定到其他IP地址之前，请考虑启用“安全性检查表”中列出的访问控制和其他安全措施，以防止未经授权的访问。The audit file rotates at the same time as the server log file.审计文件与服务器日志文件同时旋转。You may also specify these options in the configuration file:您也可以在配置文件中指定以下选项： storage: dbPath: data/db auditLog: destination: file format: JSON path: data/db/auditLog.json Note注意Printing audit events to a file in JSON format degrades server performance more than printing to a file in BSON format.与以BSON格式打印到文件相比，以JSON格式打印审计事件到文件的性能降低服务器性能。 Output to BSON File¶ 输出到BSON文件 ¶ To enable auditing and print audit events to a file in BSON binary format, specify the following options:要启用审计并将审计事件打印为BSON二进制格式的文件，请指定以下选项：Option Value--auditDestination file--auditFormat BSON--auditPath The output filename. Accepts either the full path name or relative path name. 选项            值 --auditDestination   file --auditFormat     BSON --auditPath        输出文件名，接受完整路径名或相对路径名。For example, the following enables auditing and records audit events to a BSON file with the relative path name of data/db/auditLog.bson:例如，以下选项启用审计并将审计事件记录到相对路径'data/db/auditLog.bson'的文件中： mongod --dbpath data/db --auditDestination file --auditFormat BSON --auditPath data/db/auditLog.bson Include additional options as required for your configuration. For instance, if you wish remote clients to connect to your deployment or your deployment members are run on different hosts, specify the --bind_ip. For more information, see Localhost Binding Compatibility Changes.Important重要Before you bind to other ip addresses, consider enabling access control and other security measures listed in Security Checklist to prevent unauthorized access.绑定到其他IP地址之前，请考虑启用“安全性检查表”中列出的访问控制和其他安全措施，以防止未经授权的访问。The audit file rotates at the same time as the server log file.审计文件与服务器日志文件同时旋转。You may also specify these options in the configuration file:您也可以在配置文件中指定以下选项： storage: dbPath: data/db auditLog: destination: file format: BSON path: data/db/auditLog.bson To view the contents of the file, pass the file to the MongoDB utility bsondump. For example, the following converts the audit log into a human-readable form and output to the terminal:要查看文件的内容，请将文件传递给MongoDB实用程序 bsondump。例如，以下内容将审计日志转换为可读格式并输出到终端： bsondump data/db/auditLog.bson See also也可以看Configure Audit Filters, Auditing, System Event Audit Messages配置审计过滤器，审计，系统事件审计消息 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Security/Audit/System-Event-Audit-Messages.html":{"url":"docs/Security/Audit/System-Event-Audit-Messages.html","title":"System Event Audit Messages","keywords":"","body":"System-Event-Audit-Messages System Event Audit Messages¶ 系统事件审核消息¶ On this page在本页 Audit Message Audit Event Actions, Details, and Results 审核消息 审核事件操作，详情和结果 Note注意Available only in MongoDB Enterprise and MongoDB Atlas.仅在MongoDB 企业版和MongoDB Atlas可用。 Audit Message¶ 审核消息¶ The event auditing feature can record events in JSON format. To configure auditing output, see Configure Auditing.事件审核功能可以用JSON格式记录事件。配置审核输出，请参阅配置审核。The recorded JSON messages have the following syntax:记录的JSON消息格式如下：copy { atype: , ts : { \"$date\": }, local: { ip: , port: }, remote: { ip: , port: }, users : [ { user: , db: }, ... ], roles: [ { role: , db: }, ... ], param: , result: } 复制 { atype: , ts : { \"$date\": }, local: { ip: , port: }, remote: { ip: , port: }, users : [ { user: , db: }, ... ], roles: [ { role: , db: }, ... ], param: , result: } Field Type Description atype string Action type. See Audit Event Actions, Details, and Results. ts document Document that contains the date and UTC time of the event, in ISO 8601 format. local document Document that contains the local ip address and the port number of the running instance. remote document Document that contains the remote ip address and the port number of the incoming connection associated with the event. users array Array of user identification documents. Because MongoDB allows a session to log in with different user per database, this array can have more than one user. Each document contains a user field for the username and a db field for the authentication database for that user. roles array Array of documents that specify the roles granted to the user. Each document contains a role field for the name of the role and a db field for the database associated with the role. param document Specific details for the event. See Audit Event Actions, Details, and Results. result integer Error code. See Audit Event Actions, Details, and Results. 字段 类型 描述 atype string 操作类型. 详情请看审核事件操作，详情和结果. ts document 文档包含日期和UTC时间格式为ISO 8601 local document 文档包含运行实例本地IP和端口 remote document 文档包含与事件相关的传入连接的远程ip和端口号 users array 数组包含一组用户识别文档。由于MongoDB允许会话以每个数据库的不同用户身份登录，因此该数组可以包含多个用户。每个文档都包含user字段记录用户名和db字段记录验证该用户的数据库名 roles array 数组包含文档，用于指定授予用户的角色。每个文档包含一个role字段记录角色名和一个db字段记录与该角色相关的数据库名 param document 事件的详细信息。请看审核事件操作，详情和结果. result integer 错误码。请看审核事件操作，详情和结果. Audit Event Actions, Details, and Results¶ 审核事件操作，详情和结果¶ The following table lists for each atype or action type, the associated param details and the result values, if any.下表列出了每种atype或操作类型，相关的param详细信息和result值(如果有)。 atype param result authenticate '' 0 - Success18 - Authentication Failed authCheck { command: , ns: ., args: } ``ns is optional.args field may be redacted.字段是可选的。args字段可能已经被修改了。 0 - Success13 - Unauthorized to perform the operation.By default, the auditing system logs only the authorization failures. To enable the system to log authorization successes, use the auditAuthorizationSuccess parameter. [1]默认情况下，审核系统仅记录授权失败。要使系统记录授权成功，请使用auditAuthorizationSuccess参数。[1] createCollection { ns: . } 0 - Success createDatabase { ns: } 0 - Success createIndex { ns: ., indexName: , indexSpec: } 0 - Success renameCollection { old: ., new: . } 0 - Success dropCollection { ns: . } 0 - Success dropDatabase { ns: } 0 - Success dropIndex { ns: ., indexName: } 0 - Success createUser { user: , db: , customData: , roles: [ { role: , db: }, ... ] }The customData field is optional. 0 - Success dropUser { user: , db: } 0 - Success dropAllUsersFromDatabase { db: } 0 - Success updateUser { user: , db: , passwordChanged: , customData: , roles: [ { role: , db: }, ... ] }The customData field is optional. 0 - Success grantRolesToUser { user: , db: , roles: [ { role: , db: }, ... ] } 0 - Success revokeRolesFromUser { user: , db: , roles: [ { role: , db: }, ... ] } 0 - Success createRole { role: , db: , roles: [ { role: , db: }, ... ], privileges: [ { resource: , actions: [ , ... ] }, ... ] }The roles and the privileges fields are optional.For details on the resource document, see Resource Document. For a list of actions, see Privilege Actions. roles和privileges字段是可选的，关于resource文档详情，请查看Resource Document.关于操作列表，请查看Privilege Actions. 0 - Success updateRole { role: , db: , roles: [ { role: , db: }, ... ], privileges: [ { resource: , actions: [ , ... ] }, ... ] }The roles and the privileges fields are optional.For details on the resource document, see Resource Document. For a list of actions, see Privilege Actions.roles和privileges字段是可选的。关于resource文档详情，请查看Resource Document.关于操作列表，请查看Privilege Actions. 0 - Success dropRole { role: , db: } 0 - Success dropAllRolesFromDatabase { db: } 0 - Success grantRolesToRole { role: , db: , roles: [ { role: , db: }, ... ] } 0 - Success revokeRolesFromRole { role: , db: , roles: [ { role: , db: }, ... ] } 0 - Success grantPrivilegesToRole { role: , db: , privileges: [ { resource: , actions: [ , ... ] }, ... ] }For details on the resource document, see Resource Document. For a list of actions, see Privilege Actions.关于resource这个字段对应的文档，请查看Resource Document.关于操作列表，请查看Privilege Actions. 0 - Success revokePrivilegesFromRole { role: , db: , privileges: [ { resource: , actions: [ , ... ] }, ... ] }For details on the resource document, see Resource Document. For a list of actions, see Privilege Actions. 0 - Success replSetReconfig { old: { _id: , version: , ... members: [ ... ], settings: { ... } }, new: { _id: , version: , ... members: [ ... ], settings: { ... } } }For details on the replica set configuration document, see Replica Set Configuration. 0 - Success enableSharding { ns: } 0 - Success shardCollection { ns: ., key: , options: { unique: } } 0 - Success addShard { shard: , connectionString: :, maxSize: }When a shard is a replica set, the connectionString includes the replica set name and can include other members of the replica set.当分片是副本集时，connectionString包含副本集集群名字和可以包含其他副本集成员。 0 - Success removeShard { shard: } 0 - Success shutdown { }Indicates commencement of database shutdown. 指明数据库开始关闭 0 - Success applicationMessage { msg: }See logApplicationMessage. 0 - Success [1] Enabling auditAuthorizationSuccess degrades performance more than logging only the authorization failures.[1]启用审核授权成功与仅记录授权失败相比，启用会使性能下降更多。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Security/Network-and-Configuration-Hardening.html":{"url":"docs/Security/Network-and-Configuration-Hardening.html","title":"Network and Configuration Hardening","keywords":"","body":"Network and Configuration Hardening Network and Configuration Hardening 网络和配置强化 [MongoDB Configuration Hardening]MongoDB 配置强化(https://docs.mongodb.com/manual/core/security-hardening/#mongodb-configuration-hardening) [Network Hardening]网络强化(https://docs.mongodb.com/manual/core/security-hardening/#network-hardening) To reduce the risk exposure of the entire MongoDB system, ensure that only trusted hosts have access to MongoDB.要降低整个 MongoDB 系统的风险暴露，请确保只有可信主机才能访问 MongoDB。 MongoDB Configuration Hardening MongoDB 配置强化 IP Binding IP绑定 Starting with MongoDB 3.6, MongoDB binaries, mongod and mongos, bind to localhost by default. From MongoDB versions 2.6 to 3.4, only the binaries from the official MongoDB RPM (Red Hat, CentOS, Fedora Linux, and derivatives) and DEB (Debian, Ubuntu, and derivatives) packages would bind to localhost by default. To learn more about this change, see Localhost Binding Compatibility Changes.从MongoDB 3.6开始，MongoDB 二进制文件, mongod 和 mongos 默认绑定本地主机(localhost)。从MongoDB 版本 2.6 到 3.4，只有官方 MongoDB RPM安装包(Red Hat，CentOS，Fedora Linux 和衍生产品)和 DEB安装包(Debian，Ubuntu 及衍生产品)中的二进制文件默认绑定到本地主机(localhost)。要了解有关此更改的更多信息，请参阅 本地主机绑定兼容性更改。WARNING：警告：Before binding to a non-localhost (e.g. publicly accessible) IP address, ensure you have secured your cluster from unauthorized access. For a complete list of security recommendations, see Security Checklist. At minimum, consider enabling authentication and hardening network infrastructure.在绑定到非本地主机(例如可公开访问的) IP 地址之前，请确保已保护数据库集群防止未经授权的访问。有关安全建议的完整列表，请参阅安全检查表。至少需要要考虑 启用身份验证 和施强化网络基础架构。WARNING：警告：Make sure that your mongod and mongos instances are only accessible on trusted networks. If your system has more than one network interface, bind MongoDB programs to the private or internal network interface.确保只能在受信任的网络上访问 mongod 和mongos实例。如果您的系统具有多个网络接口，请将 MongoDB 程序绑定到专用或内部网络接口。For more information, see IP Binding.更多的信息，参照 IP 绑定。 HTTP Status Interface and REST API HTTP状态接口和REST API Changed in version 3.6: MongoDB 3.6 removes the deprecated HTTP interface and REST API to MongoDB.3.6版本的变化： MongoDB 3.6 移除了 MongoDB数据库的HTTP Interface 和REST API。 Network Hardening 网络强化 Firewalls 防火墙 Firewalls allow administrators to filter and control access to a system by providing granular control over network communications. For administrators of MongoDB, the following capabilities are important: limiting incoming traffic on a specific port to specific systems and limiting incoming traffic from untrusted hosts.防火墙允许管理员通过提供网络通信的细粒度控制来过滤和控制对系统的访问。对于 MongoDB 的管理员，以下功能非常重要：将特定端口上的传入流量限制到特定系统，并限制来自不受信任主机的传入流量。On Linux systems, the iptables interface provides access to the underlying netfilter firewall. On Windows systems, netsh command line interface provides access to the underlying Windows Firewall. For additional information about firewall configuration, see:在 Linux 系统上，iptables 接口提供对底层 netfilter 防火墙的访问。在 Windows 系统上，netsh 命令 line 接口提供对底层 Windows 防火墙的访问。有关防火墙配置的其他信息，请参阅： [Configure Linux iptables Firewall for MongoDB]为 MongoDB 配置 Linux iptables 防火墙(https://docs.mongodb.com/manual/tutorial/configure-linux-iptables-firewall/) [Configure Windows netsh Firewall for MongoDB]为 MongoDB 配置 Windows netsh 防火墙(https://docs.mongodb.com/manual/tutorial/configure-windows-netsh-firewall/) For best results and to minimize overall exposure, ensure that only traffic from trusted sources can reach mongod and mongos instances and that the mongod and mongos instances can only connect to trusted outputs.为了获得最佳结果并最大限度地减少总体风险，请确保只有来自可靠来源的流量才能到达mongod和mongos实例，并且mongod和mongos实例只能连接到受信任的输出。 Virtual Private Networks 虚拟专用网 Virtual private networks, or VPNs, make it possible to link two networks over an encrypted and limited-access trusted network. Typically, MongoDB users who use VPNs use TLS/SSL rather than IPSEC VPNs for performance issues.虚拟专用网络或VPN使得通过加密和有限访问的可信网络连接两个网络成为可能。通常，使用 VPN 的 MongoDB 用户使用 TLS/SSL 而不是 IPSEC VPN 来解决性能问题。Depending on configuration and implementation, VPNs provide for certificate validation and a choice of encryption protocols, which requires a rigorous level of authentication and identification of all clients. Furthermore, because VPNs provide a secure tunnel, by using a VPN connection to control access to your MongoDB instance, you can prevent tampering and “man-in-the-middle” attacks.|根据配置和实现，VPN 提供证书验证和加密协议选择，这需要对所有客户端进行严格的身份验证和识别。此外，由于 VPN 提供了一个安全通道，通过使用 VPN 连接来控制对 MongoDB 实例的访问，您可以防止篡改和“中间人”攻击。 附录 IP Binding IP绑定：https://docs.mongodb.com/manual/core/security-mongodb-configuration/Configure Linux iptables Firewall for MongoDB iptables为MongoDB 配置Linux 防火墙：https://docs.mongodb.com/manual/tutorial/configure-linux-iptables-firewall/Configure Windows netsh Firewall for MongoDB netsh为MongoDB 配置Windows 防火墙：https://docs.mongodb.com/manual/tutorial/configure-windows-netsh-firewall/Implement Field Level Redaction实施字段级别修订：https://docs.mongodb.com/manual/tutorial/implement-field-level-redaction/原文链接：https://docs.mongodb.com/manual/core/security-hardening/ Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Change-Streams.html":{"url":"docs/Change-Streams.html","title":"Change Streams","keywords":"","body":"改变流 改变流 在本页面 打开变革流 修改更改流输出 查找更新操作的完整文档 恢复变更流 用例 访问控制 Event 通知 version 3.6 中的新内容。 更改流允许 applications 访问 real-time 数据更改，而没有拖尾OPLOG的复杂性和风险。 Applications 可以使用更改流来订阅集合上的所有数据更改，并立即对它们做出反应。 重要仅当启用了“多数”读取关注支持时，才能使用更改流(默认)。 打开变革流您只能针对副本 sets或分片簇打开更改流。对于分片 cluster，您必须针对mongos发出打开更改流操作。 副本集或分片 cluster 必须使用副本集协议 version 1(PV1)和WiredTiger存储引擎(可以是加密)。 以下 example 打开集合的更改流，并迭代光标以检索更改流文档。与 MongoDB 部署的连接保持打开状态时，光标将保持打开状态，直到出现以下情况之一： 游标显式关闭。 发生使 event 无效。 如果部署是分片 cluster，则删除分片可能会导致打开更改流游标关闭，并且关闭的更改流游标可能无法完全恢复。 蟒蛇下面的 Python 示例假设您有连接到 MongoDB 副本集并访问过数据库包含inventory集合。 cursor = db.inventory.watch()document = next(cursor)Java(同步)下面的 Java 示例假设您有连接到 MongoDB 副本集并访问过数据库包含inventory集合。 MongoCursor cursor = inventory.watch().iterator();ChangeStreamDocument next = cursor.next();Node.js下面的 Node.js 示例假设您有包含inventory集合的连接到 MongoDB 副本集并访问过数据库。 以下 example 使用 stream 来处理更改 events。 const collection = db.collection('inventory');const changeStream = collection.watch();changeStream.on('change', next => {// process next document});或者，您也可以使用迭代器来处理更改 events： const changeStreamIterator = collection.watch();const next = await changeStreamIterator.next(); PHP下面的示例假设您有连接到 MongoDB 副本集并访问过数据库包含inventory集合。 $changeStream = $db->inventory->watch();$changeStream->rewind(); $firstChange = $changeStream->current(); $changeStream->next(); $secondChange = $changeStream->current();发动机下面的示例假设您有连接到 MongoDB 副本集并访问过数据库包含inventory集合。 cursor = db.inventory.watch()document = await cursor.next()C#下面的 C#示例假设您有连接到 MongoDB 副本集并访问过数据库包含inventory集合。 var enumerator = inventory.Watch().ToEnumerable().GetEnumerator();enumerator.MoveNext();var next = enumerator.Current;enumerator.Dispose();红宝石下面的示例假设您有连接到 MongoDB 副本集并访问过数据库包含inventory集合。 cursor = inventory.watch.toenumnext_change = cursor.next要检索数据更改 event 通知，请迭代更改流cursor。 注意未封闭游标的生命周期为 language-dependent。 有关更改流响应文档格式的更多信息，请参见改变 Events。 修改更改流输出蟒蛇在配置更改流时，可以通过提供以下一个或多个管道阶段的 array 来控制改变流输出： $match $project $addFields $replaceRoot $redact Java(同步)在配置更改流时，可以通过提供以下一个或多个管道阶段的 array 来控制改变流输出： $match $project $addFields $replaceRoot $redact MongoClient mongoClient = new MongoClient( new MongoClientURI(\"mongodb://host1:port1,host2:port2...\")); // Select the MongoDB database and collection to open the change stream against MongoDatabase db = mongoClient.getDatabase(\"myTargetDatabase\"); MongoCollection collection = db.getCollection(\"myTargetCollection\"); // Create $match pipeline stage.List pipeline = singletonList(Aggregates.match(Filters.or(Document.parse(\"{'fullDocument.username': 'alice'}\"),Filters.in(\"operationType\", asList(\"delete\"))))); // Create the change stream cursor, passing the pipeline to the// collection.watch() method MongoCursor cursor = collection.watch(pipeline).iterator();pipeline列表包括一个$match阶段，用于过滤username为alice的任何操作，或者operationType为delete的操作。 将pipeline传递给watch()方法会在将更改流传递给指定的pipeline后将更改流指向 return 通知。 Node.js在配置更改流时，可以通过提供以下一个或多个管道阶段的 array 来控制改变流输出： $match $project $addFields $replaceRoot $redact 以下 example 使用 stream 来处理更改 events。 const pipeline = [{ $match: { 'fullDocument.username': 'alice' } },{ $addFields: { newField: 'this is an added field!' } }]; const collection = db.collection('inventory');const changeStream = collection.watch(pipeline);changeStream.on('change', next => {// process next document});或者，您也可以使用迭代器来处理更改 events： const changeStreamIterator = collection.watch(pipeline);const next = await changeStreamIterator.next(); PHP在配置更改流时，可以通过提供以下一个或多个管道阶段的 array 来控制改变流输出： $match $project $addFields $replaceRoot $redact 发动机在配置更改流时，可以通过提供以下一个或多个管道阶段的 array 来控制改变流输出： $match $project $addFields $replaceRoot $redact C#在配置更改流时，可以通过提供以下一个或多个管道阶段的 array 来控制改变流输出： $match $project $addFields $replaceRoot $redact 红宝石在配置更改流时，可以通过提供以下一个或多个管道阶段的 array 来控制改变流输出： $match $project $addFields $replaceRoot $redact 有关更改流响应文档格式的更多信息，请参见改变 Events。 查找更新操作的完整文档默认情况下，仅更改流在更新操作期间返回字段的增量。但是，您可以将更改流配置为 return 更新文档的最新 majority-committed version。蟒蛇要_return 更新文档的最新 majority-committed version，请将full_document='updateLookup'传递给db.collection.watch()方法。 在下面的 example 中，所有更新操作通知都包含一个full_document字段，该字段表示受更新操作影响的文档的当前 version。 cursor = db.inventory.watch(full_document='updateLookup')document = next(cursor)Java(同步)要_return 更新文档的最新 majority-committed version，请将FullDocument.UPDATE_LOOKUP传递给db.collection.watch.fullDocument()方法。 在下面的 example 中，所有更新操作通知都包含一个FullDocument字段，该字段表示受更新操作影响的文档的当前 version。 cursor = inventory.watch().fullDocument(FullDocument.UPDATE_LOOKUP).iterator();next = cursor.next();Node.js要_return 更新文档的最新 majority-committed version，请将{ fullDocument: 'updateLookup' }传递给collection.watch()方法。 在下面的 example 中，所有更新操作通知都包含一个fullDocument字段，该字段表示受更新操作影响的文档的当前 version。 以下 example 使用 stream 来处理更改 events。 const collection = db.collection('inventory');const changeStream = collection.watch({ fullDocument: 'updateLookup' });changeStream.on('change', next => {// process next document});或者，您也可以使用迭代器来处理更改 events： const changeStreamIterator = collection.watch({ fullDocument: 'updateLookup' });const next = await changeStreamIterator.next(); PHP要_return 更新文档的最新 majority-committed version，请将\"fullDocument' => \\MongoDB\\Operation\\ChangeStreamCommand::FULL_DOCUMENT_UPDATE_LOOKUP\"传递给watch()方法。 在下面的 example 中，所有更新操作通知都包含一个fullDocument字段，该字段表示受更新操作影响的文档的当前 version。 $changeStream = $db->inventory->watch([], ['fullDocument' => \\MongoDB\\Operation\\Watch::FULL_DOCUMENT_UPDATE_LOOKUP]);$changeStream->rewind(); $firstChange = $changeStream->current(); $changeStream->next(); $nextChange = $changeStream->current();发动机要_return 更新文档的最新 majority-committed version，请将full_document='updateLookup'传递给db.collection.watch()方法。 在下面的 example 中，所有更新操作通知都包含一个“full_document”字段，表示受更新操作影响的文档的当前 version。 cursor = db.inventory.watch(full_document='updateLookup')document = await cursor.next()C#要_return 更新文档的最新 majority-committed version，请将\"FullDocument = ChangeStreamFullDocumentOption.UpdateLookup\"传递给collection.Watch()方法。 在下面的 example 中，所有更新操作通知都包含一个FullDocument字段，该字段表示受更新操作影响的文档的当前 version。 var options = new ChangeStreamOptions { FullDocument = ChangeStreamFullDocumentOption.UpdateLookup };var enumerator = inventory.Watch(options).ToEnumerable().GetEnumerator();enumerator.MoveNext();var next = enumerator.Current;enumerator.Dispose();红宝石要_return 更新文档的最新 majority-committed version，请将full_document: 'updateLookup'传递给watch()方法。 在下面的 example 中，所有更新操作通知都包含一个full_document字段，该字段表示受更新操作影响的文档的当前 version。 cursor = inventory.watch([], full_document: 'updateLookup').to_enumnext_change = cursor.next注意有关更改流响应文档格式的更多信息，请参见改变 Events。 恢复变更流打开游标时，通过指定resumeAfter标记可以恢复更改流。对于resumeAfter标记，请使用更改流 event 文档的_id value。将_id value 传递给更改流会尝试在指定的操作之后恢复通知。 重要 如果时间戳是过去的，则 oplog 必须具有足够的历史记录来定位与令牌或时间戳关联的操作。 在使 event 无效(对于 example，集合删除或重命名)关闭流之后，您无法恢复更改流。Python在下面的 example 中，resume_token包含更改流通知 ID。 resume_after修饰符采用必须解析为恢复标记的参数。将resume_token传递给resume_after修饰符会指示更改流尝试在恢复令牌中指定的操作之后开始恢复通知。 resume_token = document.get(\"_id\")cursor = db.inventory.watch(resume_after=resume_token)document = next(cursor)Java(同步)在下面的 example 中，resumeToken包含更改流通知 ID。 resumeAfter()方法采用必须解析为恢复标记的参数。将resumeToken传递给resumeAfter()方法会指示更改流尝试在恢复令牌中指定的操作之后开始恢复通知。 BsonDocument resumeToken = next.getResumeToken();cursor = inventory.watch().resumeAfter(resumeToken).iterator();next = cursor.next();Node.js在下面的 example 中，resumeToken包含更改流通知 ID。 resumeAfter采用必须解析为恢复令牌的参数。将resumeToken传递给resumeAfter修饰符会指示更改流尝试在指定的操作之后开始恢复通知。 const collection = db.collection('inventory');const changeStream = collection.watch(); let resumeToken, newChangeStream;changeStream.on('change', next => {resumeToken = next._id;changeStream.close(); newChangeStream = collection.watch({ resumeAfter });newChangeStream.on('change', next => {// process next document});}); PHP在下面的 example 中，$resumeToken包含更改流通知 ID。 resumeAfter选项需要一个必须解析为恢复标记的 value。将$resumeToken传递给resumeAfter选项会指示更改流尝试在恢复令牌中指定的操作之后开始恢复通知。 $resumeToken = ($lastChange !== null) ? $lastChange->_id : null; if ($resumeToken === null) {throw new \\Exception('resumeToken was not found');} $changeStream = $db->inventory->watch([], ['resumeAfter' => $resumeToken]);$changeStream->rewind(); $nextChange = $changeStream->current();发动机在下面的 example 中，resume_token包含更改流通知 ID。 resume_after修饰符采用必须解析为恢复标记的参数。将resume_token传递给resume_after修饰符会指示更改流尝试在恢复令牌中指定的操作之后开始恢复通知。 resume_token = document.get(\"_id\")cursor = db.inventory.watch(resume_after=resume_token)document = await cursor.next()C#在下面的 example 中，从最后一个更改流文档中检索resumeToken并作为选项传递给Watch()方法。将resumeToken传递给Watch()方法会指示更改流尝试在恢复令牌中指定的操作之后开始恢复通知。 var resumeToken = lastChangeStreamDocument.ResumeToken;var options = new ChangeStreamOptions { ResumeAfter = resumeToken };var enumerator = inventory.Watch(options).ToEnumerable().GetEnumerator();enumerator.MoveNext();var next = enumerator.Current;enumerator.Dispose();红宝石在下面的 example 中，resume_token包含更改流通知 ID。 resume_after修饰符采用必须解析为恢复标记的参数。将resume_token传递给resume_after修饰符会指示更改流尝试在恢复令牌中指定的操作之后开始恢复通知。 resume_token = next_change['_id']cursor = inventory.watch([], resume_after: resume_token).to_enumresumed_change = cursor.next 用例变更流可以使具有相关业务系统的架构受益，一旦数据变化持久，就可以通知下游系统。例如，在实现 Extract，Transform 和 Load(ETL)服务，cross-platform 同步，协作功能和通知服务时，更改流可以为开发人员节省 time。 访问控制对于强制执行认证和授权的部署，请对要对其打开更改流的集合执行changeStream和找权限操作的用户进行身份验证。 读 built-in 角色包括支持针对集合打开更改流所需的权限。任何 built-in 角色或user-defined 角色继承读角色也可以支持打开集合的更改流。 或者，使用db.createRole创建 user-defined 角色，在目标集合上授予changeStream和找权限操作。有关更完整的文档，请参见User-Defined 角色。 要将 built-in 角色或 user-defined 角色与现有用户相关联，请使用db.grantRolesToUser()或db.updateUser()方法。您还可以在使用db.createUser()创建新用户时指定角色。 Event 通知更改流仅通知已保留到副本集中大多数 data-bearing 成员的数据更改。这可确保仅在失败方案中持久的 majority-committed 更改触发通知。 例如，考虑一个 3-member 副本集，其中一个更改流游标针对主打开。如果 client 发出 insert 操作，则只要 insert 持续存在于大多数 data-bearing 成员，更改流才会通知 application 数据更改。 Change Streams Production Recommendations 改变 Events Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Change-Streams/Change-Streams-Production-Recommendations.html":{"url":"docs/Change-Streams/Change-Streams-Production-Recommendations.html","title":"Change Streams Production Recommendations","keywords":"","body":"Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Change-Streams/Change-Event.html":{"url":"docs/Change-Streams/Change-Event.html","title":"Change Events","keywords":"","body":"Change Streams Production Recommendations 在本页面 改变 Events insert Event 更新 Event 替换 Event 删除 Event 使 Event 无效 改变 Events 以下文档表示更改流响应文档可以具有的所有可能字段。{ _id : { }, \"operationType\" : \"\", \"fullDocument\" : { }, \"ns\" : { \"db\" : \"\", \"coll\" : \" }, \"updateDescription\" : { \"updatedFields\" : { }, \"removedFields\" : [ \"\", ... ] } } 某些字段仅适用于某些操作，例如更新。以下 table 描述了更改流响应文档中的每个字段： 领域 类型 描述 _id 文献 与操作相关的元数据。恢复更改流时，将此文档用作resumeAfter的resumeAfter参数。 operationType 串 发生的操作类型。可以是以下任何值：insertdeletereplaceupdateinvalidate fullDocument 文献 该操作创建或修改的文档。对于insert和replace操作，这表示操作创建的新文档。对于delete操作，由于文档不再存在，因此省略此字段。对于update操作，仅当您将更改流配置为fullDocument设置为updateLookup时，才会显示此字段。然后，该字段表示由更新操作修改的文档的最新 majority-committed version。如果其他 majority-committed 操作在原始更新操作和完整文档查找之间修改了文档，则此文档可能与updateDescription中描述的更改不同。 ns 文献 数据库的名称空间和更改流的集合是打开的。 ns.db 串 数据库的 name。 ns.coll 串 集合的 name。 documentKey 文献 包含操作创建或修改的文档的_id的文档。对于分片集合，还会显示文档的完整分片 key。如果_id字段已经是分片 key 的一部分，则不会重复该字段。 updateDescription 文献 描述更新操作更新或删除的字段的文档。仅当operationType为update时，才会显示此文档及其字段。 updateDescription.updatedFields 文献 一个文档，其键对应于更新操作修改的字段。每个字段的 value 对应于这些字段的新 value，而不是导致新 value 的操作。 updateDescription.removedFields array 更新操作删除的 array 字段。 insert Event 以下 example 说明了insert event： { _id: { }, operationType: 'insert', ns: { db: 'engineering', coll: 'users' }, documentKey: { userName: 'alice123', _id: ObjectId(\"599af247bb69cd89961c986d\") }, fullDocument: { _id: ObjectId(\"599af247bb69cd89961c986d\"), userName: 'alice123', name: 'Alice' } } documentKey字段包括_id和userName字段。这表示engineering.users集合是分片的，userName和_id上有一个 shard key。fullDocument文档表示 insert 的 time 处文档的 version。 更新 Event 以下 example 说明了update event： { _id: { }, operationType: 'update', ns: { db: 'engineering', coll: 'users' }, documentKey: { _id: ObjectId(\"58a4eb4a30c75625e00d2820\") }, updateDescription: { updatedFields: { email: 'alice@10gen.com' }, removedFields: ['phoneNumber'] } } 以下 example 说明了使用fullDocument : updateLookup选项打开的更改流的update event： { _id: { }, operationType: 'update', ns: { db: 'engineering', coll: 'users' }, documentKey: { _id: ObjectId(\"58a4eb4a30c75625e00d2820\") }, updateDescription: { updatedFields: { email: 'alice@10gen.com' }, removedFields: ['phoneNumber'] }, fullDocument: { _id: ObjectId(\"58a4eb4a30c75625e00d2820\"), name: 'Alice', userName: 'alice123', email: 'alice@10gen.com', team: 'replication' } } fullDocument文档代表更新文档的最新 majority-committed version。 fullDocument文档可能与更新操作的 time 时的文档不同，具体取决于更新操作和文档查找之间发生的交错 majority-committed 操作的数量。 替换 Event 以下 example 说明了replace event： { _id: { }, operationType: 'replace', ns: { db: 'engineering', coll: 'users' }, documentKey: { _id: ObjectId(\"599af247bb69cd89961c986d\") }, fullDocument: { _id: ObjectId(\"599af247bb69cd89961c986d\"), userName: 'alice123', name: 'Alice' } } replace操作使用 update 命令，包含两个阶段： 使用documentKey和删除原始文档 使用相同的documentkey插入新文档 replace event 的fullDocument表示替换文档的 insert 之后的文档。 删除 Event 以下 example 说明了delete event： { _id: { }, operationType: 'delete', ns: { db: 'engineering', coll: 'users' }, documentKey: { _id: ObjectId(\"599af247bb69cd89961c986d\") } } 文档被省略，因为更改流游标将delete event 发送到 client 的 time 时文档不再存在。 使 Event 无效 以下 example 说明了invalidate event： { _id: { }, operationType: 'invalidate' } 对于针对集合打开的更改流，invalidate events 发生在影响监视集合的dropDatabase Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Replication.html":{"url":"docs/Replication.html","title":"Replication","keywords":"","body":"Replication(复制) On this page Redundancy and Data Availability 冗余和数据可用性 Replication in MongoDB MongoDB中的复制 Asynchronous Replication 异步复制 Automatic Failover 自动故障转移 Read Operations 读操作 Transactions 事务 Change Streams 变更流 Additional Features 附加功能 A replica set in MongoDB is a group of mongod processes that maintain the same data set. Replica sets provide redundancy and high availability, and are the basis for all production deployments. This section introduces replication in MongoDB as well as the components and architecture of replica sets. The section also provides tutorials for common tasks related to replica sets.MongoDB中的副本集是一组维护相同数据集合的 mongod进程。副本集提供了冗余和高可用性，并且这是所有生产部署的基础。本节介绍MongoDB中的复制以及副本集的组件和体系结构。本节还提供了副本集常见任务的教程。 Redundancy and Data Availability¶ 冗余和数据可用性¶ Replication provides redundancy and increases data availability. With multiple copies of data on different database servers, replication provides a level of fault tolerance against the loss of a single database server.复制提供了冗余并增加了 数据可用性。对于不同数据库服务器上的多个数据副本，复制为防止单台数据库服务器故障提供了一定程度的容错能力。In some cases, replication can provide increased read capacity as clients can send read operations to different servers. Maintaining copies of data in different data centers can increase data locality and availability for distributed applications. You can also maintain additional copies for dedicated purposes, such as disaster recovery, reporting, or backup.在某些情况下，复制可以提高读取性能，因为客户端可以将读操作发送到不同的服务器上。在不同的数据中心维护数据副本可以提高分布式应用程序的数据本地化和可用性。您还可以维护额外的副本以实现特殊用途，比如灾难恢复、报告或备份。 Replication in MongoDB¶ MongoDB的复制¶ A replica set is a group of mongod instances that maintain the same data set. A replica set contains several data bearing nodes and optionally one arbiter node. Of the data bearing nodes, one and only one member is deemed the primary node, while the other nodes are deemed secondary nodes.副本集是一组维护相同数据集合的 mongod实例。副本集包含多个数据承载节点和一个可选的仲裁节点。在数据承载节点中，有且仅有一个成员为主节点，其他节点为副本节点。The primary node receives all write operations. A replica set can have only one primary capable of confirming writes with { w: \"majority\" } write concern; although in some circumstances, another mongod instance may transiently believe itself to also be primary. [1] The primary records all changes to its data sets in its operation log, i.e. oplog. For more information on primary node operation, see Replica Set Primary.主节点 接收所有的写操作。一个副本集仅有一个主节点能够用{ w: \"majority\" } 写关注点级别来确认写操作；虽然在某些情况下，另一个mongod的实例也可以暂时认为自己是主节点。[1] 主节点会将其数据集合所有的变化记录到操作日志中，即oplog.。有关主节点操作的更多信息，请参见 副本集主节点。The secondaries replicate the primary’s oplog and apply the operations to their data sets such that the secondaries’ data sets reflect the primary’s data set. If the primary is unavailable, an eligible secondary will hold an election to elect itself the new primary. For more information on secondary members, see Replica Set Secondary Members.副本节点复制主节点的oplog，并将这些操作应用于它们的数据集，这样以便副本节点的数据集能反映出主节点的数据集。如果主节点不可用，一个候选的副本节点将会发起选举并使之成为新的主节点。有关副本成员的更多信息，请参见副本集副本成员。In some circumstances (such as you have a primary and a secondary but cost constraints prohibit adding another secondary), you may choose to add a mongod instance to a replica set as an arbiter. An arbiter participates in elections but does not hold data (i.e. does not provide data redundancy). For more information on arbiters, see Replica Set Arbiter.在某些情况下(比如您有一个主节点和一个副本节点，但由于成本约束无法添加另一个副本节点)，您可以选择将一个 mongod 实例作为 仲裁节点添加到一个副本集中。仲裁节点参与选举但不持有数据(即不提供数据冗余)。有关仲裁节点的更多信息，请参见副本集仲裁节点。An arbiter will always be an arbiter whereas a primary may step down and become a secondary and a secondary may become the primary during an election.仲裁节点 永远只能是仲裁节点，但在选举过程中主节点也许会降级成为 副本节点， 副本节点也可能会升级成为主节点。 Asynchronous Replication¶ 异步复制¶ Secondaries replicate the primary’s oplog and apply the operations to their data sets asynchronously. By having the secondaries’ data sets reflect the primary’s data set, the replica set can continue to function despite the failure of one or more members.副本节点复制主节点的oplog并异步地应用操作到它们的数据集。通过让副本节点的数据集反映主服务器的数据集，副本集可以在一个或多个成员失败的情况下继续运行。For more information on replication mechanics, see Replica Set Oplog and Replica Set Data Synchronization.有关复制机制的更多信息，请参见 副本集Oplog 和 副本集数据同步。 Slow Operations¶ 慢操作¶ Starting in version 4.2 (also available starting in 4.0.6), secondary members of a replica set now log oplog entries that take longer than the slow operation threshold to apply. These slow oplog messages are logged for the secondaries in the diagnostic log under the REPL component with the text applied op: took ms. These slow oplog entries depend only on the slow operation threshold. They do not depend on the log levels (either at the system or component level), or the profiling level, or the slow operation sample rate. The profiler does not capture slow oplog entries.从4.2版本开始（从4.0.6开始也是可行的），副本集的副本成员会记录oplog中应用时间超过慢操作阈值的慢操作条目。这些慢oplog信息被记录在副本节点的诊断日志 中，其路径位于REPL 组件的文本applied op: took ms中。这些慢日志条目仅仅依赖于慢操作阈值。它们不依赖于日志级别（无论是系统还是组件级别）、过滤级别，或者慢操作采样比例。过滤器不会捕获慢日志条目。 Replication Lag and Flow Control¶ 复制延迟和流控制¶ Replication lag refers to the amount of time that it takes to copy (i.e. replicate) a write operation on the primary to a secondary. Some small delay period may be acceptable, but significant problems emerge as replication lag grows, including building cache pressure on the primary.复制延迟 指的是将主节点的写操作拷贝(即复制)到 副本节点所花费的时间。一些小的延迟期可能是可以接受的，但是随着复制延迟的增长，会出现严重的问题，包括引起主节点的缓存压力。Starting in MongoDB 4.2, administrators can limit the rate at which the primary applies its writes with the goal of keeping the majority committed lag under a configurable maximum value flowControlTargetLagSeconds.从MongoDB 4.2开始，管理员可以限制主节点应用写操作的速度，目的是将majority committed 延迟保持在可配置参数flowControlTargetLagSeconds的最大值之下。By default, flow control is enabled.默认情况下，流控制是启用的。NOTE注意For flow control to engage, the replica set/sharded cluster must have: featureCompatibilityVersion (FCV) of 4.2 and read concern majority enabled. That is, enabled flow control has no effect if FCV is not 4.2 or if read concern majority is disabled.为了进行流控制，复制集/分片集群必须满足：参数featureCompatibilityVersion (FCV) 设置为4.2并启用majority读关注点。也就是说，如果FCV不是 4.2 ，或者读关注点majority被禁用，那么启用流控制将不起作用。With flow control enabled, as the lag grows close to the flowControlTargetLagSeconds, writes on the primary must obtain tickets before taking locks to apply writes. By limiting the number of tickets issued per second, the flow control mechanism attempts to keep the the lag under the target.启用流控制后，当延迟快接近 flowControlTargetLagSeconds 参数指定的秒数时，主节点上的写操作必须首先获得许可单才可以获取写锁。通过限制每秒发出的许可单的数量，流控制机制可以将延迟保持在目标数值之下。For more information, see Check the Replication Lag and Flow Control.为获取更多信息，请参见检查复制延迟和流控制。 Automatic Failover¶ 自动故障转移¶ When a primary does not communicate with the other members of the set for more than the configured electionTimeoutMillis period (10 seconds by default), an eligible secondary calls for an election to nominate itself as the new primary. The cluster attempts to complete the election of a new primary and resume normal operations.当主节点无法和集群中其他节点通信的时间超过参数electionTimeoutMillis配置的期限时（默认10s），一个候选的副本节点会发起选举来推荐自己成为新主节点。集群会尝试完成一次新主节点的选举并恢复正常的操作。The replica set cannot process write operations until the election completes successfully. The replica set can continue to serve read queries if such queries are configured to run on secondaries while the primary is offline.副本集在选举成功前是无法处理写操作的。如果读请求被配置运行在副本节点 上，则当主节点下线时，副本集可以继续处理这些请求。The median time before a cluster elects a new primary should not typically exceed 12 seconds, assuming default replica configuration settings. This includes time required to mark the primary as unavailable and call and complete an election. You can tune this time period by modifying the settings.electionTimeoutMillis replication configuration option. Factors such as network latency may extend the time required for replica set elections to complete, which in turn affects the amount of time your cluster may operate without a primary. These factors are dependent on your particular cluster architecture.假设采用默认的副本配置选项，集群选择新主节点的中间过渡时间通常不应超过12秒。这包括了将主节点标记为unavailable、发起以及完成一次 选举的时间。您可以通过修改settings.electionTimeoutMillis 复制配置选项来调整这个时间期限。网络延迟等因素可能会延长完成副本集选举所需的时间，从而影响您的集群在没有主节点的情况下运行的时间。这些因素取决于您实际的集群架构情况。Lowering the electionTimeoutMillis replication configuration option from the default 10000 (10 seconds) can result in faster detection of primary failure. However, the cluster may call elections more frequently due to factors such as temporary network latency even if the primary is otherwise healthy. This can result in increased rollbacks for w : 1 write operations.将electionTimeoutMillis复制配置选项从默认的10000(10秒)降低可以更快地检测主节点故障。然而，由于诸如临时性的网络延迟等因素，集群可能会更频繁地发起选举，即使主节点在其他方面是健康的。这也许会增加w : 1 级别写操作发生回滚的可能性。Your application connection logic should include tolerance for automatic failovers and the subsequent elections. Starting in MongoDB 3.6, MongoDB drivers can detect the loss of the primary and automatically retry certain write operations a single time, providing additional built-in handling of automatic failovers and elections: MongoDB 4.2-compatible drivers enable retryable writes by default MongoDB 4.0 and 3.6-compatible drivers must explicitly enable retryable writes by including retryWrites=true in the connection string. 您的应用程序连接逻辑应该包括对自动故障转移和后续选举的容错处理能力。从MongoDB 3.6开始，MongoDB驱动程序可以探测到主节点的丢失，并自动重试某些写操作 一次，提供额外的自动故障转移和选举的内置处理: MongoDB 4.2兼容的驱动程序默认启用可重试写 MongoDB 4.0和3.6兼容的驱动程序必须通过在 连接字符串中包含retryWrites=true来显式地启用可重试写。 See Replica Set Elections for complete documentation on replica set elections.请参见 副本集选举来获取副本集选举的完整信息。To learn more about MongoDB’s failover process, see:为了解更多关于MongoDB失败处理的信息，请参见： Replica Set Elections 副本集选举 Retryable Writes 可重试写 Rollbacks During Replica Set Failover 副本集故障期间的回滚 Read Operations¶ 读操作¶ Read Preference¶ 读偏好¶ By default, clients read from the primary [1]; however, clients can specify a read preference to send read operations to secondaries.默认情况下，客户端从主节点读取[1]；然而，客户端可以定义一个读偏好 将读操作发送给副本节点。Asynchronous replication to secondaries means that reads from secondaries may return data that does not reflect the state of the data on the primary.异步复制至副本节点，意味着从副本节点读取返回的数据不能反映主节点上数据的状态。Multi-document transactions that contain read operations must use read preference primary. All operations in a given transaction must route to the same member.包含读操作的多文档事务必须使用读偏好primary。在给定的事务中所有操作都必须路由至相同的成员节点。For information on reading from replica sets, see Read Preference.为了解更多关于副本集读的信息，请参见读偏好。 Data Visibility¶ 数据可见性¶ Depending on the read concern, clients can see the results of writes before the writes are durable: Regardless of a write’s write concern, other clients using \"local\" or \"available\" read concern can see the result of a write operation before the write operation is acknowledged to the issuing client. Clients using \"local\" or \"available\" read concern can read data which may be subsequently rolled back during replica set failovers. 根据读关注点，客户端可以在写持久化前看到写结果： 不管写的 write concern级别是什么，其他使用了读关注点级别为 \"local\" 或 \"available\" 的客户端，可以在发起写操作的客户端确认其写成功之前查看该客户端写的结果。 使用了读关注点级别为 \"local\" 或 \"available\" 的客户端，能读取在副本集故障转移期间可能随后被回滚 掉的数据。 For operations in a multi-document transaction, when a transaction commits, all data changes made in the transaction are saved and visible outside the transaction. That is, a transaction will not commit some of its changes while rolling back others.对于多文档事务中的操作，当事务提交时，在事务中所做的所有数据更改都会被保存并在事务外部可见。也就是说，事务在回滚其他更改时不会提交某些更改。Until a transaction commits, the data changes made in the transaction are not visible outside the transaction.在事务提交之前，事务中所做的数据更改在事务外部是不可见的。However, when a transaction writes to multiple shards, not all outside read operations need to wait for the result of the committed transaction to be visible across the shards. For example, if a transaction is committed and write 1 is visible on shard A but write 2 is not yet visible on shard B, an outside read at read concern \"local\" can read the results of write 1 without seeing write 2.然而，当一个事务写入多个分片时，并不是所有外部的读操作都需要等待提交的事务的结果在分片中可见。例如，如果提交了一个事务，并且在分片a上可以看到写1，但是在分片B上还不能看到写2，那么外部读关注点为 \"local\" 的读可以在不看到写2的情况下读取写1的结果。For more information on read isolations, consistency and recency for MongoDB, see Read Isolation, Consistency, and Recency.有关MongoDB读隔离、一致性和近因性的更多信息，请参见Read Isolation, Consistency, and Recency。 Transactions¶ 事务¶ Starting in MongoDB 4.0, multi-document transactions are available for replica sets.从MongoDB 4.0开始，副本集支持多文档事务。Multi-document transactions that contain read operations must use read preference primary. All operations in a given transaction must route to the same member.包含读操作的多文档事务必须使用读偏好 primary。给定事务中所有的操作都必须路由至相同的成员节点。Until a transaction commits, the data changes made in the transaction are not visible outside the transaction.在事务提交之前，事务中所做的数据更改在事务外部是不可见的。However, when a transaction writes to multiple shards, not all outside read operations need to wait for the result of the committed transaction to be visible across the shards. For example, if a transaction is committed and write 1 is visible on shard A but write 2 is not yet visible on shard B, an outside read at read concern \"local\" can read the results of write 1 without seeing write 2.然而，当一个事务写入多个分片时，并不是所有外部的读操作都需要等待提交的事务的结果在分片中可见。例如，如果提交了一个事务，并且在分片a上可以看到写1，但是在分片B上还不能看到写2，那么外部读关注点为 \"local\" 的读可以在不看到写2的情况下读取写1的结果。 Change Streams¶ 变更流¶ Starting in MongoDB 3.6, change streams are available for replica sets and sharded clusters. Change streams allow applications to access real-time data changes without the complexity and risk of tailing the oplog. Applications can use change streams to subscribe to all data changes on a collection or collections.从MongoDB 3.6开始，副本集和分片集群支持变更流。变更流允许应用程序访问实时数据更改，而不需要跟踪oplog的复杂性和风险。应用程序可以使用变更流来订阅一个或多个集合上的所有数据更改。 Additional Features¶ 附加功能¶ Replica sets provide a number of options to support application needs. For example, you may deploy a replica set with members in multiple data centers, or control the outcome of elections by adjusting the members[n].priority of some members. Replica sets also support dedicated members for reporting, disaster recovery, or backup functions.副本集提供了许多选项来支持应用程序的需求。例如，你可以使用多数据中心中的成员来部署一个副本集，或者通过调整一些成员的members[n].priority 来控制选举结果。副本集还支持用于报告、灾难恢复或备份功能的专用成员。See Priority 0 Replica Set Members, Hidden Replica Set Members and Delayed Replica Set Members for more information.更多有关信息请参见优先级0的副本集成员，隐藏副本集成员和延迟副本集成员 。 [1] (1, 2) In some circumstances, two nodes in a replica set may transiently believe that they are the primary, but at most, one of them will be able to complete writes with { w: \"majority\" } write concern. The node that can complete { w: \"majority\" } writes is the current primary, and the other node is a former primary that has not yet recognized its demotion, typically due to a network partition. When this occurs, clients that connect to the former primary may observe stale data despite having requested read preference primary, and new writes to the former primary will eventually roll back. [1] (1, 2) 在 某些场景下, 一个复制集中的两个节点可能会认为它们是主节点，但最多，他们中的一个将能够完成写关注点为{ w: \"majority\" }写操作。 可以完成 { w: \"majority\" } 写的节点是当前主节点，而另一个节点是原先的主节点，通常是由于网络分区导致它还没有意识到自己的降级。当这种情况发生时，连接到原先主节点的客户端尽管已经请求了读偏好primary，但可能还 会观察到过时的数据，并且对原先主节点新写的操作最终将回滚掉。 原文链接：https://docs.mongodb.com/manual/replication/ Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Replication/Replica-Set-Members.html":{"url":"docs/Replication/Replica-Set-Members.html","title":"Replica Set Members","keywords":"","body":"Replica Set Members Replica Set Members¶ 副本集成员¶ A replica set in MongoDB is a group of mongod processes that provide redundancy and high availability. The members of a replica set are:MongoDB 的副本集是一组提供冗余和高可用性的mongod 进程。一个副本集的成员有： Primary.主节点The primary receives all write operations.主节点接受所有的写操作。 Secondaries.副本节点Secondaries replicate operations from the primary to maintain an identical data set. Secondaries may have additional configurations for special usage profiles. For example, secondaries may be non-voting or priority 0.副本节点通过复制主节点的操作来维护一个相同的数据集。副本节点为特殊用途的配置文件提供了额外的配置项。例如，副本节点可配置成无投票权 或0优先级。 The minimum recommended configuration for a replica set is a three member replica set with three data-bearing members: one primary and two secondary members. In some circumstances (such as you have a primary and a secondary but cost constraints prohibit adding another secondary), you may choose to include an arbiter. An arbiter participates in elections but does not hold data (i.e. does not provide data redundancy).副本集的最小推荐配置是一个包含三个数据承载成员的三成员副本集：一个主节点 和两个副本节点。在某些情况下（例如你有一个主节点和一个副本节点，但由于成本约束无法添加另一个副本节点），你可以选择使用一个仲裁节点。仲裁节点参与选举但不持有数据（即不提供数据冗余）。A replica set can have up to 50 members but only 7 voting members.一个副本集最多可以有50个成员，但仅能有7个可投票成员。 Primary¶ 主节点¶ The primary is the only member in the replica set that receives write operations. MongoDB applies write operations on the primary and then records the operations on the primary’s oplog. Secondary members replicate this log and apply the operations to their data sets.副本集的主节点是唯一一个可以接受写操作的成员。MongoDB在主节点 上应用写操作，然后将这些操作记录到主节点的oplog中。副本节点成员复制这个日志然后应用到它们的数据集中。In the following three-member replica set, the primary accepts all write operations. Then the secondaries replicate the oplog to apply to their data sets.在下图的三成员副本集中，主节点接受所有写操作。然后副本节点复制oplog应用至它们的数据集中。All members of the replica set can accept read operations. However, by default, an application directs its read operations to the primary member. See Read Preference for details on changing the default read behavior.副本集所有的成员都可以接受读操作。但是，默认情况下，应用程序会将其读操作定向至主节点。有关更改默认读行为的详细信息，请参阅读偏好 。The replica set can have at most one primary. [2] If the current primary becomes unavailable, an election determines the new primary. See Replica Set Elections for more details.副本集最多有一个主节点。 [2] 如果当前主节点不可用，一个选举会抉择出新的主节点。更多详细信息请参见副本集选举。 Secondaries¶ 副本节点¶ A secondary maintains a copy of the primary’s data set. To replicate data, a secondary applies operations from the primary’s oplog to its own data set in an asynchronous process. [1] A replica set can have one or more secondaries.一个副本节点维护了主节点数据集的一个副本。为了复制数据，副本节点通过异步的方式将主节点oplog 应用至自己的数据集中。一个副本集可以有一个或多个副本节点。The following three-member replica set has two secondary members. The secondaries replicate the primary’s oplog and apply the operations to their data sets.下图的三成员副本集有两个副本成员。副本节点复制主节点的oplog并应用到它们的数据集上。Although clients cannot write data to secondaries, clients can read data from secondary members. See Read Preference for more information on how clients direct read operations to replica sets.虽然客户端不能将数据写入到副本节点，但客户端可以从副本节点读取数据。有关客户端如何将读操作直接读入副本集的详细信息，请参阅读偏好 。A secondary can become a primary. If the current primary becomes unavailable, the replica set holds an election to choose which of the secondaries becomes the new primary.副本节点可以成为主节点。如果当前主节点不可用，副本集会发起选举来选择哪个副本节点成为新的主服节点。See Replica Set Elections for more details.更多详细信息请参见副本集选举。。You can configure a secondary member for a specific purpose. You can configure a secondary to:您可以出于特殊目的来配置副本节点成员。您可以配置一个副本节点用于: Prevent it from becoming a primary in an election, which allows it to reside in a secondary data center or to serve as a cold standby. See Priority 0 Replica Set Members. 阻止它在选举中成为主节点，适用于将该节点部署在备用数据中心或者充当一个冷备节点。请查考0优先级副本集成员。 Prevent applications from reading from it, which allows it to run applications that require separation from normal traffic. See Hidden Replica Set Members. 防止应用程序从它读取数据，适用于在该节点上运行需要与正常流量分离的应用程序。请参考隐藏副本集成员。 Keep a running “historical” snapshot for use in recovery from certain errors, such as unintentionally deleted databases. See Delayed Replica Set Members. 保持一个运行的“历史”快照，以便在从某些错误(如无意中删除的数据库)恢复时使用。请参考延迟副本集成员。 | [1] | Starting in version 4.2 (also available starting in 4.0.6), secondary members of a replica set now log oplog entries that take longer than the slow operation threshold to apply. These slow oplog messages are logged for the secondaries in the diagnostic log under the REPL component with the text applied op: took ms. These slow oplog entries depend only on the slow operation threshold. They do not depend on the log levels (either at the system or component level), or the profiling level, or the slow operation sample rate. The profiler does not capture slow oplog entries. | | --- | --- | | [1] | 从4.2版本开始（从4.0.6也支持），副本集的副本成员会记录oplog中应用时间超过慢操作阈值的慢操作条目。这些慢oplog信息被记录在副本节点的诊断日志 中，其路径位于REPL 组件的文本applied op: took ms中。这些慢日志条目仅仅依赖于慢操作阈值。它们不依赖于日志级别（无论是系统还是组件级别）、过滤级别，或者慢操作采样比例。过滤器不会捕获慢日志条目。 | Arbiter¶ 仲裁节点¶ In some circumstances (such as you have a primary and a secondary but cost constraints prohibit adding another secondary), you may choose to add an arbiter to your replica set. An arbiter does not have a copy of data set and cannot become a primary. However, an arbiter participates in elections for primary. An arbiter has exactly 1 election vote.在某些情况下（例如您有一个主节点和一个副本节点，但由于成本约束无法添加另一个副本节点），你可以在你的副本集中添加一个仲裁节点。仲裁节点没有数据集的副本，并且不能成为主节点。然而，仲裁节点可以参与主节点选举。一个仲裁节点只有 1 票选举权。Changed in version 3.6: Starting in MongoDB 3.6, arbiters have priority 0. When you upgrade a replica set to MongoDB 3.6, if the existing configuration has an arbiter with priority 1, MongoDB 3.6 reconfigures the arbiter to have priority 0.3.6版本的变化：从MongoDB 3.6版本开始，仲裁节点优先级为0。当您升级一个副本集至3.6版本时，如果当前配置中有一个优先级为1的仲裁节点，则MongoDB 3.6会将仲裁节点的优先级重新配置为0。IMPORTANT 重要Do not run an arbiter on systems that also host the primary or the secondary members of the replica set.不要在同时承载副本集的主节点或副本成员的系统上运行仲裁节点。To add an arbiter, see Add an Arbiter to Replica Set.需要添加一个仲裁节点，请参考添加一个仲裁节点至副本集。For considerations when using an arbiter, see Replica Set Arbiter.使用仲裁节点时的注意事项，请参考副本集仲裁节点。 [2] In some circumstances, two nodes in a replica set may transiently believe that they are the primary, but at most, one of them will be able to complete writes with { w: \"majority\" } write concern. The node that can complete { w: \"majority\" } writes is the current primary, and the other node is a former primary that has not yet recognized its demotion, typically due to a network partition. When this occurs, clients that connect to the former primary may observe stale data despite having requested read preference primary, and new writes to the former primary will eventually roll back. [2] 在 某些场景下, 一个副本集中的两个节点可能会认为它们是主节点，但至多，他们中的一个将能够完成写关心级别为{ w: \"majority\" }的写操作。 可以完成 { w: \"majority\" } 写的节点是当前主节点，而另一个节点是原先的主节点，通常是由于网络分区导致它还没有意识到自己的降级。当这种情况发生时，连接到原先主节点的客户端尽管已经请求了读偏好primary，但可能还会观察到过时的数据，并且对原先主节点新写的操作最终将回滚掉。 随附副本集主节点、副本节点和仲裁节点的参看链接：https://docs.mongodb.com/manual/core/replica-set-primary/https://docs.mongodb.com/manual/core/replica-set-secondary/https://docs.mongodb.com/manual/core/replica-set-arbiter/ 译者：李正洋 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Query-and-Projection-Operators.html":{"url":"docs/Reference/Operators/Query-and-Projection-Operators.html","title":"Query and Projection Operators","keywords":"","body":" 查询与映射运算符 在本页面 查询选择器 映射运算符 注意 有关特定运算符的详细信息，包括语法和示例，请单击特定运算符以转到其参考页。 查询选择器 比较 有关不同BSON类型值的比较，请参见指定的BSON比较顺序。 名称 描述 $eq 匹配等于指定值的值。 $gt 匹配大于指定值的值。 $gte 匹配大于或等于指定值的值。 $in 匹配数组中指定的任何值。 $lt 匹配小于指定值的值。 $lte 匹配小于或等于指定值的值。 $ne 匹配所有不等于指定值的值。 $nin 不匹配数组中指定的任何值。 逻辑 名称 描述 $and 使用逻辑AND连接查询子句，返回与这两个子句条件匹配的所有文档。 $not 反转查询表达式的效果，并返回与查询表达式不匹配的文档。 $nor 用逻辑NOR连接查询子句，返回所有不能匹配这两个子句的文档。 $or 用逻辑OR连接查询子句，返回与任一子句条件匹配的所有文档。 元素 名称 描述 $exists 匹配具有指定字段的文档。 $type 如果字段是指定类型，则选择文档。 评估 名称 描述 $expr 允许在查询语言中使用聚合表达式。 $jsonSchema 根据给定的JSON Schema验证文档。 $mod 对字段的值执行模运算并选择具有指定结果的文档。 $regex 选择值与指定的正则表达式匹配的文档。 $text 执行文本搜索。 $where 匹配满足JavaScript表达式的文档。 地理空间 名称 描述 $geoIntersects 选择与GeoJSON几何形状相交的几何形状。2dsphere索引支持 $geoIntersects。 $geoWithin 选择边界GeoJSON几何内的几何。2dsphere和2D指标支持 $geoWithin。 $near 返回点附近的地理空间对象。需要地理空间索引。2dsphere和2D指标支持 $near。 $nearSphere 返回球体上某个点附近的地理空间对象。需要地理空间索引。2dsphere和2D指标支持 $nearSphere。 数组 名称 描述 $all 匹配包含查询中指定的所有元素的数组。 $elemMatch 如果array字段中的元素符合所有指定$elemMatch条件，则选择文档。 $size 如果数组字段为指定大小，则选择文档。 按位 名称 描述 $bitsAllClear 匹配数字或二进制值，其中一组位的所有值均为0。 $bitsAllSet 匹配数字或二进制值，其中一组位的所有值均为1。 $bitsAnyClear 匹配数值或二进制值，在这些数值或二进制值中，一组位的位置中任何位的值为0。 $bitsAnySet 匹配数值或二进制值，在这些数值或二进制值中，一组位的位置中任何位的值为1。 注释 名称 描述 $comment 向查询谓词添加注释。 映射运算符 名称 描述 $ 数组中匹配查询条件的第一个元素。 $elemMatch 符合指定$elemMatch条件的数组中的第一个元素。 $meta 项目在$text操作期间分配的文档分数。 $slice 限制从数组中投影的元素数量。支持limit和skip。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Query-and-Projection-Operators/Comparison-Query-Operators.html":{"url":"docs/Reference/Operators/Query-and-Projection-Operators/Comparison-Query-Operators.html","title":"Comparison Query Operators","keywords":"","body":" 比较查询运算符 注意 有关特定运算符的详细信息，包括语法和示例，请单击特定运算符以转到其参考页。 有关不同BSON类型值的比较，请参见指定的BSON比较顺序。 名称 结果 $eq 匹配等于指定值的值。 $gt 匹配大于指定值的值。 $gte 匹配大于或等于指定值的值。 $in 匹配数组中指定的任何值。 $lt 匹配小于指定值的值。 $lte 匹配小于或等于指定值的值。 $ne 匹配所有不等于指定值的值。 $nin 不匹配数组中指定的任何值。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Query-and-Projection-Operators/Comparison-Query-Operators/eq.html":{"url":"docs/Reference/Operators/Query-and-Projection-Operators/Comparison-Query-Operators/eq.html","title":"$eq","keywords":"","body":" $eq 在本页面 行为 例子 $eq 指定相等条件。$eq操作符匹配字段的值等于指定值的文档。 { : { $eq: } } $eq表达式等效于。{ field: } 行为 比较顺序 有关不同BSON类型值的比较，请参见指定的BSON比较顺序。 匹配一个文献价值 如果指定的是文档，则文档中字段的顺序很重要。 匹配一个数组值 如果指定的是数组，则MongoDB将匹配与该数组完全匹配的文档，或者 包含包含与该数组完全匹配的元素的文档。元素的顺序很重要。有关示例，请参见等于数组值。 例子 以下示例inventory使用以下文档查询集合： { _id: 1, item: { name: \"ab\", code: \"123\" }, qty: 15, tags: [ \"A\", \"B\", \"C\" ] } { _id: 2, item: { name: \"cd\", code: \"123\" }, qty: 20, tags: [ \"B\" ] } { _id: 3, item: { name: \"ij\", code: \"456\" }, qty: 25, tags: [ \"A\", \"B\" ] } { _id: 4, item: { name: \"xy\", code: \"456\" }, qty: 30, tags: [ \"B\", \"A\" ] } { _id: 5, item: { name: \"mn\", code: \"000\" }, qty: 20, tags: [ [ \"A\", \"B\" ], \"C\" ] } 等于指定值 下面的示例查询inventory集合以选择qty字段值等于的所有文档20： db.inventory.find( { qty: { $eq: 20 } } ) 该查询等效于： db.inventory.find( { qty: 20 } ) 这两个查询都匹配以下文档： { _id: 2, item: { name: \"cd\", code: \"123\" }, qty: 20, tags: [ \"B\" ] } { _id: 5, item: { name: \"mn\", code: \"000\" }, qty: 20, tags: [ [ \"A\", \"B\" ], \"C\" ] } 嵌入式文档中的字段等于值 以下示例查询inventory集合以选择文档中name字段值item 等于\"ab\"的所有文档。要在嵌入式文档中的字段上指定条件，请使用点符号。 db.inventory.find( { \"item.name\": { $eq: \"ab\" } } ) 该查询等效于： db.inventory.find( { \"item.name\": \"ab\" } ) 这两个查询都与以下文档匹配： { _id: 1, item: { name: \"ab\", code: \"123\" }, qty: 15, tags: [ \"A\", \"B\", \"C\" ] } 也可以看看 查询嵌入式文档 数组元素等于一个值 下面的示例查询inventory集合以选择tags数组包含值\"B\" [1]的元素的所有文档： db.inventory.find( { tags: { $eq: \"B\" } } ) 该查询等效于： db.inventory.find( { tags: \"B\" } ) 这两个查询都匹配以下文档： { _id: 1, item: { name: \"ab\", code: \"123\" }, qty: 15, tags: [ \"A\", \"B\", \"C\" ] } { _id: 2, item: { name: \"cd\", code: \"123\" }, qty: 20, tags: [ \"B\" ] } { _id: 3, item: { name: \"ij\", code: \"456\" }, qty: 25, tags: [ \"A\", \"B\" ] } { _id: 4, item: { name: \"xy\", code: \"456\" }, qty: 30, tags: [ \"B\", \"A\" ] } 也可以看看 $elemMatch，查询数组 [1] 该查询还将匹配文档，其中tags字段的值为字符串\"B\"。 等于一个数组值 以下示例查询inventory集合，以选择该tags数组与指定数组完全相等或该tags数组包含等于该数组[ \"A\", \"B\" ]的元素的所有文档。 db.inventory.find( { tags: { $eq: [ \"A\", \"B\" ] } } ) 该查询等效于： db.inventory.find( { tags: [ \"A\", \"B\" ] } ) 这两个查询都匹配以下文档： { _id: 3, item: { name: \"ij\", code: \"456\" }, qty: 25, tags: [ \"A\", \"B\" ] } { _id: 5, item: { name: \"mn\", code: \"000\" }, qty: 20, tags: [ [ \"A\", \"B\" ], \"C\" ] } Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Query-and-Projection-Operators/Comparison-Query-Operators/gt.html":{"url":"docs/Reference/Operators/Query-and-Projection-Operators/Comparison-Query-Operators/gt.html","title":"$gt","keywords":"","body":" $gt $gt 语法：{field: {$gt: value} } $gt选择的值field大于（即>）指定的那些文档 value。 对于大多数数据类型，比较运算符仅对BSON类型与查询值的类型匹配的字段执行比较 。MongoDB通过Type Bracketing支持有限的跨BSON比较。 考虑以下示例： db.inventory.find( { qty: { $gt: 20 } } ) 此查询将选择inventory集合中qty字段值大于20的所有文档。 考虑以下示例，该示例将$gt运算符与嵌入式文档中的字段一起使用： db.inventory.update( { \"carrier.fee\": { $gt: 2 } }, { $set: { price: 9.99 } } ) update()操作将设置price找到的第一个文档中包含嵌入文档carrier的fee字段的值，该嵌入文档的字段值大于2。 要price在包含嵌入文档的所有文档中设置该字段的值，该嵌入文档carrier的fee字段值大于2，请在update()方法中指定multi:true选项： db.inventory.update( { \"carrier.fee\": { $gt: 2 } }, { $set: { price: 9.99 } }, { multi: true } ) 也可以看看 find()，update()，$set。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Query-and-Projection-Operators/Comparison-Query-Operators/gte.html":{"url":"docs/Reference/Operators/Query-and-Projection-Operators/Comparison-Query-Operators/gte.html","title":"$gte","keywords":"","body":" $gte $gte 语法：{field: {$gte: value} } $gte选择的值field大于或等于（即>=）指定值（例如value）的文档 。 对于大多数数据类型，比较运算符仅对BSON类型与查询值的类型匹配的字段执行比较 。MongoDB通过Type Bracketing支持有限的跨BSON比较。 考虑以下示例： db.inventory.find( { qty: { $gte: 20 } } ) 此查询将选择的所有文件inventory，其中qty字段的值大于或等于20。 考虑以下示例，该示例将$gte运算符与嵌入式文档中的字段一起使用： db.inventory.update( { \"carrier.fee\": { $gte: 2 } }, { $set: { price: 9.99 } } ) update()操作将设置price包含嵌入文档carrier的fee字段的值，该嵌入文档 的字段值大于或等于 2。 也可以看看 find()，update()，$set。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Query-and-Projection-Operators/Comparison-Query-Operators/in.html":{"url":"docs/Reference/Operators/Query-and-Projection-Operators/Comparison-Query-Operators/in.html","title":"$in","keywords":"","body":" $in 在本页面 例子 $in $in操作符选择字段值等于指定数组中任何值的文档。要指定一个$in表达式，使用下面的原型: 有关不同BSON类型值的比较，请参见指定的BSON比较顺序。 { field: { $in: [, , ... ] } } 如果field持有的阵列，则$in操作符选择字段中包含至少一个与指定数组中的值匹配的元素的文档（例如，，等） 例子 使用$in运算符来匹配值 考虑以下示例： db.inventory.find( { qty: { $in: [ 5, 15 ] } } ) 该查询选择inventory 集合中qty字段值为5或的15所有文档。尽管可以使用$or运算符表示此查询 ，但是在同一字段上执行相等性检查时，请选择$in运算符而不是$or运算符。 使用$in运算符匹配数组中的值 集合inventory包含包含字段的文档， tags如下所示： { _id: 1, item: \"abc\", qty: 10, tags: [ \"school\", \"clothing\" ], sale: false } 然后，下面的update()操作将设定的sale字段值true，其中tags字段保持与至少一个元素匹配任一阵列\"appliances\"或 \"school\"。 db.inventory.update( { tags: { $in: [\"appliances\", \"school\"] } }, { $set: { sale:true } } ) 有关查询数组的其他示例，请参见： 查询数组 查询嵌入式文档数组 有关查询的其他示例，请参见： 查询文件 将$in运算符与正则表达式一起使用 $in操作符可利用形式的正则表达式匹配指定值/pattern/。您不能在$in中使用$regex运算符表达式。 考虑以下示例： db.inventory.find( { tags: { $in: [ /^be/, /^st/ ] } } ) 此查询选择inventory集合中的所有文档，其中tags字段包含以be或st开头的字符串，或至少有一个以be或st开头的元素的数组。 也可以看看 find()，update()，$or，$set，$elemMatch。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Query-and-Projection-Operators/Comparison-Query-Operators/lt.html":{"url":"docs/Reference/Operators/Query-and-Projection-Operators/Comparison-Query-Operators/lt.html","title":"$lt","keywords":"","body":" $lt $lt 语法：{field: {$lt: value} } $lt选择的值field小于（即）指定的文档 value。 对于大多数数据类型，比较运算符仅对BSON类型与查询值的类型匹配的字段执行比较 。MongoDB通过Type Bracketing支持有限的跨BSON比较。 考虑以下示例： db.inventory.find( { qty: { $lt: 20 } } ) 此查询将选择inventory集合中qty字段值小于20的所有文档。 考虑以下示例，该示例将$lt运算符与嵌入式文档中的字段一起使用： db.inventory.update( { \"carrier.fee\": { $lt: 20 } }, { $set: { price: 9.99 } } ) update()操作将price在包含嵌入文档的文档中设置字段值，该嵌入文档carrier的fee字段值小于20。 也可以看看 find()，update()，$set。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Query-and-Projection-Operators/Comparison-Query-Operators/lte.html":{"url":"docs/Reference/Operators/Query-and-Projection-Operators/Comparison-Query-Operators/lte.html","title":"$lte","keywords":"","body":" $lte $lte 语法：{field: {$lte: value} } $lte选择的值field小于或等于指定value的文档 。 对于大多数数据类型，比较运算符仅对BSON类型与查询值的类型匹配的字段执行比较 。MongoDB通过Type Bracketing支持有限的跨BSON比较。 考虑以下示例： db.inventory.find( { qty: { $lte: 20 } } ) 此查询将选择inventory集合中qty字段值小于或等于20的所有文档。 考虑以下示例，该示例将$lte运算符与嵌入式文档中的字段一起使用： db.inventory.update( { \"carrier.fee\": { $lte: 5 } }, { $set: { price: 9.99 } } ) update()操作将price在包含嵌入式文档的文档中设置字段值，该嵌入式文档carrier的fee字段值小于或等于5。 也可以看看 find()，update()，$set。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Query-and-Projection-Operators/Comparison-Query-Operators/ne.html":{"url":"docs/Reference/Operators/Query-and-Projection-Operators/Comparison-Query-Operators/ne.html","title":"$ne","keywords":"","body":" $ne $ne 语法：{field: {$ne: value} } $ne选择的值field不等于指定的文档 value。这包括不包含的文档field。 有关不同BSON类型值的比较，请参见指定的BSON比较顺序。 考虑以下示例： db.inventory.find( { qty: { $ne: 20 } } ) 此查询将选择inventory集合中qty字段值不等于20的所有文档，包括不包含该qty字段的那些文档。 考虑以下示例，该示例$ne在嵌入式文档中使用运算符和字段： db.inventory.update( { \"carrier.state\": { $ne: \"NY\" } }, { $set: { qty: 20 } } ) update()操作将qty在包含嵌入式文档的文档中设置字段值，该嵌入式文档carrier的state字段值不等于“ NY”，或者该state字段或carrier嵌入式文档不存在。 不等式操作符$ne是不非常有选择性的，因为它往往是指数的很大一部分相匹配。结果，在许多情况下，$ne带有索引的查询的性能可能不比$ne必须扫描集合中所有文档的查询更好。另请参阅查询选择性。 也可以看看 find()，update()，$set。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Query-and-Projection-Operators/Comparison-Query-Operators/nin.html":{"url":"docs/Reference/Operators/Query-and-Projection-Operators/Comparison-Query-Operators/nin.html","title":"$nin","keywords":"","body":" $nin $nin 语法：{ field: { $nin: [ , ... ]} } $nin选择以下位置的文档： 该field值不在指定的范围内array 或 在field不存在。 有关不同BSON类型值的比较，请参见指定的BSON比较顺序。 考虑以下查询： db.inventory.find( { qty: { $nin: [ 5, 15 ] } } ) 这个查询将选择库存集合中qty字段值不等于5或15的所有文档。所选文档将包括那些不包含qty字段的文档。 如果字段包含数组，那么$nin操作符将选择字段中没有元素等于指定数组中的值的文档(例如， ，等等)。 考虑以下查询： db.inventory.update( { tags: { $nin: [ \"appliances\", \"school\" ] } }, { $set: { sale: false } } ) 这个update()操作将设置库存集合中的sale字段值，其中，tags字段包含一个数组，数组中没有与数组[\"appliances\"， \"school\"]中的元素匹配的元素，或者文档不包含tags字段。 不等运算符$nin的选择性不是很强，因为它经常匹配索引的很大一部分。因此，在许多情况下，带有索引的$nin查询的性能可能不比必须扫描集合中所有文档的$nin查询好。请参见查询选择性。 也可以看看 find()，update()，$set。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Query-and-Projection-Operators/Logical-Query-Operators.html":{"url":"docs/Reference/Operators/Query-and-Projection-Operators/Logical-Query-Operators.html","title":"Logical Query Operators","keywords":"","body":" 逻辑查询运算符 注意 有关特定运算符的详细信息，包括语法和示例，请单击特定运算符以转到其参考页。 名称 描述 $and 使用逻辑AND连接查询子句，返回与这两个子句条件匹配的所有文档。 $not 反转查询表达式的效果，并返回与查询表达式不匹配的文档。 $nor 用逻辑NOR连接查询子句，返回所有不能匹配这两个子句的文档。 $or 用逻辑OR连接查询子句，返回与任一子句条件匹配的所有文档。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Query-and-Projection-Operators/Logical-Query-Operators/and.html":{"url":"docs/Reference/Operators/Query-and-Projection-Operators/Logical-Query-Operators/and.html","title":"$and","keywords":"","body":" $and 在本页面 例子 $and 语法：{ $and: [ { }, { } , ... , { } ] } $and执行的逻辑AND的阵列上操作的一个或多个表达式（例如， 等），并且选择满足该文件 的所有阵列中的表达式。$and运算符使用短路计算。如果第一个表达式（例如）的计算结果为false，则MongoDB将不计算其余的表达式。 注意AND当指定逗号分隔的表达式列表时，MongoDB提供隐式操作。 例子 AND使用指定同一字段的多个表达式进行查询 考虑以下示例： db.inventory.find( { $and: [ { price: { $ne: 1.99 } }, { price: { $exists: true } } ] } ) 此查询将选择inventory 集合中的所有文档，其中： price字段值不等于1.99 与 price字段存在。 AND 通过组合price 字段的运算符表达式，也可以使用隐式操作构造此查询。例如，此查询可以写为： db.inventory.find( { price: { $ne: 1.99, $exists: true } } ) AND使用指定相同运算符的多个表达式进行查询 考虑以下示例： db.inventory.find( { $and: [ { $or: [ { qty: { $lt : 10 } }, { qty : { $gt: 50 } } ] }, { $or: [ { sale: true }, { price : { $lt : 5 } } ] } ] } ) 该查询将选择以下位置的所有文档： qty字段值小于20或大于50，和 sale字段值是等于true 或所述price 字段值小于5。 无法使用隐式AND操作构造此查询，因为它$or多次使用运算符。 也可以看看 find()，update()， $ne，$exists，$set。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Query-and-Projection-Operators/Logical-Query-Operators/not.html":{"url":"docs/Reference/Operators/Query-and-Projection-Operators/Logical-Query-Operators/not.html","title":"$not","keywords":"","body":" $not 在本页面 行为 $not 语法：{ field: { $not: { } } } $not对指定的执行逻辑NOT操作，并选择与不匹配的文档。这包括不包含该字段的文档。 考虑以下查询： db.inventory.find( { price: { $not: { $gt: 1.99 } } } ) 此查询将选择inventory集合中的所有文档，其中： price字段的值小于或等于1.99 或 price字段不存在 {$not: {$gt: 1.99}}与$lte运算符不同。{$lte: 1.99}只返回price字段存在且其值小于或等于1.99的文档。 请记住，$not操作符只影响其他操作符，不能独立地检查字段和文档。因此，使用$not操作符进行逻辑分离，使用$ne操作符直接测试字段的内容。 行为 $not和数据类型 $not运算符的操作与其他运算符的行为一致，但对于某些数据类型（如数组）可能会产生意外结果。 $not和正则表达式 $not操作符可以对以下内容执行逻辑NOT运算： 正则表达式对象(例如：/pattern/) 例如：下面的查询选择inventory集合中item字段值不以字母p开头的所有文档。 db.inventory.find( { item: { $not: /^p.*/ } } ) $regex运算符表达式(从MongoDB 4.0.7开始) 例如，下面的查询选择inventory集合中item字段值不以字母p开头的所有文档。 db.inventory.find( { item: { $not: { $regex: \"^p.*\" } } } ) db.inventory.find( { item: { $not: { $regex: /^p.*/ } } } ) 驱动程序语言的正则表达式对象 例如，下面的PyMongo查询使用Python的re.compile()方法编译一个正则表达式: import re for noMatch in db.inventory.find( { \"item\": { \"$not\": re.compile(\"^p.*\") } } ): print noMatch 也可以看看 find(), update(), $set, $gt, $regex, PyMongo, driver. Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Query-and-Projection-Operators/Logical-Query-Operators/nor.html":{"url":"docs/Reference/Operators/Query-and-Projection-Operators/Logical-Query-Operators/nor.html","title":"$nor","keywords":"","body":" $nor 在本页面 例子 $nor $nor对包含一个或多个查询表达式的数组执行逻辑nor操作，并选择数组中所有查询表达式失败的文档。$nor有以下语法: { $nor: [ { }, { }, ... { } ] } 也可以看看find(), update(), $or, $set, and $exists. 例子 $nor查询有两种表述 考虑以下仅使用$nor操作符的查询: db.inventory.find( { $nor: [ { price: 1.99 }, { sale: true } ] } ) 此查询将返回以下所有文档: 包含值不等于1.99的price字段和不等于true或的sale字段 包含price字段，其值不等于1.99，但不包含sale字段 不包含price字段，但sale包含值不等于true 不包含price字段和不包含sale字段 $nor和另外的比较 考虑以下查询: db.inventory.find( { $nor: [ { price: 1.99 }, { qty: { $lt: 20 } }, { sale: true } ] } ) 此查询将选择库存集合中的所有文档，其中: price字段值不等于1.99和 qty字段值不小于20和 sales字段的值不等于true 包括那些不包含这些字段的文档。 返回不包含$nor表达式中字段的文档的例外情况是，$nor操作符与$exists操作符一起使用。 $nor和$exists 下面的查询使用$nor操作符和$exists操作符: db.inventory.find( { $nor: [ { price: 1.99 }, { price: { $exists: false } }, { sale: true }, { sale: { $exists: false } } ] } ) 此查询将返回以下所有文档: 包含值不等于1.99的price字段和值不等于true的sale字段 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Query-and-Projection-Operators/Logical-Query-Operators/or.html":{"url":"docs/Reference/Operators/Query-and-Projection-Operators/Logical-Query-Operators/or.html","title":"$or","keywords":"","body":" $or 在本页面 行为 $or $or操作符对包含两个或多个的数组执行逻辑或操作，并选择满足至少一个的文档。$or的语法如下: { $or: [ { }, { }, ... , { } ] } 考虑下面的例子: db.inventory.find( { $or: [ { quantity: { $lt: 20 } }, { price: 10 } ] } ) 该查询将选择inventory集合中quantity字段值小于20或price字段值等于10的所有文档。 行为 $or子句和索引 当对$or表达式中的子句求值时，MongoDB要么执行集合扫描，要么执行索引扫描(如果所有子句都被索引支持)。也就是说，MongoDB要使用索引对$or表达式求值，索引必须支持$or表达式中的所有子句。否则，MongoDB将执行一次收集扫描。 当对$or查询使用索引时，$or的每个子句都可以使用自己的索引。考虑以下查询: db.inventory.find( { $or: [ { quantity: { $lt: 20 } }, { price: 10 } ] } ) 为了支持此查询，而不是复合索引，您将创建一个关于quantity的索引和另一个关于price的索引: db.inventory.createIndex( { quantity: 1 } ) db.inventory.createIndex( { price: 1 } ) MongoDB可以使用除geoHaystack索引之外的所有索引来支持$or子句。 $not和正则表达式 如果$or包含$text查询，则$or数组中的所有子句必须由索引支持。这是因为$text查询必须使用索引，而$or只能在索引支持其所有子句的情况下使用索引。如果$text查询不能使用索引，则查询将返回一个错误。 $or和地理空间查询 $or支持地理空间子句，但near子句有以下例外(near子句包括$nearSphere和$near)。$or不能包含任何其他子句的near子句。 $or和排序操作 当使用sort()执行$or查询时，MongoDB现在可以使用支持$or子句的索引。以前的版本不使用索引。 $or与$in 当使用$or 来检查相同字段的值时，使用$in操作符而不是$or操作符。 例如，要选择数量字段值为20或50的库存集合中的所有文档，使用$in操作符: db.inventory.find ( { quantity: { $in: [20, 50] } } ) Nested $or Clauses 你可能会嵌套$or操作。 也可以看看 $and, find(), sort(), $in Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Query-and-Projection-Operators/Element-Query-Operators.html":{"url":"docs/Reference/Operators/Query-and-Projection-Operators/Element-Query-Operators.html","title":"Element Query Operators","keywords":"","body":" 元素查询运算符 注意 有关特定运算符的详细信息，包括语法和示例，请单击特定运算符以转到其参考页。 名称 描述 $exists 匹配具有指定字段的文档。 $type 如果字段是指定类型，则选择文档。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Query-and-Projection-Operators/Evaluation-Query-Operators.html":{"url":"docs/Reference/Operators/Query-and-Projection-Operators/Evaluation-Query-Operators.html","title":"Evaluation Query Operators","keywords":"","body":" 评估查询运算符 注意 有关特定运算符的详细信息，包括语法和示例，请单击特定运算符以转到其参考页。 名称 描述 $expr 允许在查询语言中使用聚合表达式。 $jsonSchema 根据给定的JSON Schema验证文档。 $mod 对字段的值执行模运算并选择具有指定结果的文档。 $regex 选择值与指定的正则表达式匹配的文档。 $text 执行文本搜索。 $where 匹配满足JavaScript表达式的文档。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Query-and-Projection-Operators/Geospatial-Query-Operators.html":{"url":"docs/Reference/Operators/Query-and-Projection-Operators/Geospatial-Query-Operators.html","title":"Geospatial Query Operators","keywords":"","body":" 地理空间查询运算符 在本页面 运算符 注意 有关特定运算符的详细信息，包括语法和示例，请单击特定运算符以转到其参考页。 运算符 查询选择器 名称 描述 $geoIntersects 选择与GeoJSON几何形状相交的几何形状。2dsphere索引支持 $geoIntersects。 $geoWithin 选择边界GeoJSON几何内的几何。2dsphere和2D指标支持 $geoWithin。 $near 返回点附近的地理空间对象。需要地理空间索引。2dsphere和2D指标支持 $near。 $nearSphere 返回球体上某个点附近的地理空间对象。需要地理空间索引。2dsphere和2D指标支持 $nearSphere。 几何说明符 名称 描述 $box 使用传统坐标对来指定一个矩形框进行 $geoWithin查询。所述2D指数支持 $box。 $center 使用平面几何时，使用旧坐标对指定圆以进行$geoWithin查询。所述2D指数支持$center。 $centerSphere 使用球形几何图形时，使用传统坐标对或GeoJSON格式指定一个圆 用于$geoWithin查询。2dsphere和 2D指标支持$centerSphere。 $geometry 为地理空间查询运算符指定GeoJSON格式的几何。 $maxDistance 指定最大距离以限制$near 和$nearSphere查询的结果。2dsphere和2D指标支持 $maxDistance。 $minDistance 指定最小距离以限制$near 和$nearSphere查询的结果。2dsphere仅用于索引。 $polygon 指定用于$geoWithin查询的旧坐标对的多边形。2d索引支持$center。 $uniqueDocs 不推荐使用。修改$geoWithin和$near查询以确保即使文档多次匹配查询，查询也只返回一次文档。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Query-and-Projection-Operators/Array-Query-Operators.html":{"url":"docs/Reference/Operators/Query-and-Projection-Operators/Array-Query-Operators.html","title":"Array Query Operators","keywords":"","body":" 数组查询运算符 注意 有关特定运算符的详细信息，包括语法和示例，请单击特定运算符以转到其参考页。 名称 描述 $all 匹配包含查询中指定的所有元素的数组。 $elemMatch 如果array字段中的元素符合所有指定$elemMatch条件，则选择文档。 $size 如果数组字段为指定大小，则选择文档。 有关查询数组字段的示例，请参见： 查询数组 查询嵌入式文档数组 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Query-and-Projection-Operators/Bitwise-Query-Operators.html":{"url":"docs/Reference/Operators/Query-and-Projection-Operators/Bitwise-Query-Operators.html","title":"Bitwise Query Operators","keywords":"","body":" 按位查询运算符 注意 有关特定运算符的详细信息，包括语法和示例，请单击特定运算符以转到其参考页。 名称 描述 $bitsAllClear 匹配数字或二进制值，其中一组位的所有值均为0。 $bitsAllSet 匹配数字或二进制值，其中一组位的所有值均为1。 $bitsAnyClear 匹配数值或二进制值，在这些数值或二进制值中，一组位的位置中任何位的值为0。 $bitsAnySet 匹配数值或二进制值，在这些数值或二进制值中，一组位的位置中任何位的值为1。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Query-and-Projection-Operators/comment.html":{"url":"docs/Reference/Operators/Query-and-Projection-Operators/comment.html","title":"$comment","keywords":"","body":" $comment 在本页面 定义 行为 例子 定义 $comment $comment查询操作符将注释与任何具有查询谓词的表达式关联起来。 由于注释会传播到profile日志，因此添加注释可以使您的个人资料数据更易于解释和跟踪。 $comment运算符的形式为： db.collection.find( { , $comment: } ) 行为 您可以将_ $comment与任何带查询谓词的表达式一起使用，例如聚合管道中db.collection.update()或聚合$match阶段中的查询谓词 。有关示例，请参见对聚合表达式附加注释。 例子 附加评论到find 以下示例$comment在 find()操作中添加了： db.records.find( { x: { $mod: [ 2, 0 ] }, $comment: \"Find even values.\" } ) 在聚合表达式上附加注释 您可以对$comment带查询谓词的任何表达式使用。 以下示例在$match阶段中使用运算符$comment来阐明操作： db.records.aggregate( [ { $match: { x: { $gt: 0 }, $comment: \"Don't allow negative inputs.\" } }, { $group : { _id: { $mod: [ \"$x\", 2 ] }, total: { $sum: \"$x\" } } } ] ) 也可以看看 $comment Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Update-Operators.html":{"url":"docs/Reference/Operators/Update-Operators.html","title":"Update Operators","keywords":"","body":" 更新运算符 在本页面 更新运算符 以下修饰符可用于更新操作；例如在db.collection.update()和中 db.collection.findAndModify()。 在以下格式的文档中指定运算符表达式： { : { : , ... }, : { : , ... }, ... } 注意 有关特定运算符的详细信息，包括语法和示例，请单击特定运算符以转到其参考页。 更新运算符 字段 名称 描述 $currentDate 将字段的值设置为当前日期，即日期或时间戳。 $inc 将字段的值增加指定的数量。 $min 仅当指定值小于现有字段值时才更新该字段。 $max 仅当指定值大于现有字段值时才更新该字段。 $mul 将字段的值乘以指定的数量。 $rename 重命名字段。 $set 设置文档中字段的值。 $setOnInsert 如果更新导致插入文档，则设置字段的值。对修改现有文档的更新操作没有影响。 $unset 从文档中删除指定的字段。 数组 运算符 名称 描述 $ 充当占位符，以更新与查询条件匹配的第一个元素。 $[] 充当占位符，以更新匹配查询条件的文档的数组中的所有元素。 $[] 充当占位符，以更新arrayFilters与查询条件匹配的文档中所有与条件匹配的元素。 $addToSet 仅当元素不存在于集合中时才将它们添加到数组中。 $pop 删除数组的第一项或最后一项。 $pull 删除与指定查询匹配的所有数组元素。 $push 将项目添加到数组。 $pullAll 从数组中删除所有匹配的值。 修饰符 名称 描述 $each 修改$push和$addToSet运算符以附加多个项以进行数组更新。 $position 修改$push运算符以指定要添加元素的数组中的位置。 $slice 修改$push运算符以限制更新数组的大小。 $sort 修改$push运算符以对存储在数组中的文档重新排序。 按位 名称 描述 $bit 执行按位AND，OR和XOR整数值的更新。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Update-Operators/Field-Update-Operators.html":{"url":"docs/Reference/Operators/Update-Operators/Field-Update-Operators.html","title":"Field Update Operators","keywords":"","body":" 字段更新运算符 注意 有关特定运算符的详细信息，包括语法和示例，请单击特定运算符以转到其参考页。 名称 描述 $currentDate 将字段的值设置为当前日期，即日期或时间戳。 $inc 将字段的值增加指定的数量。 $min 仅当指定值小于现有字段值时才更新该字段。 $max 仅当指定值大于现有字段值时才更新该字段。 $mul 将字段的值乘以指定的数量。 $rename 重命名字段。 $set 设置文档中字段的值。 $setOnInsert 如果更新导致插入文档，则设置字段的值。对修改现有文档的更新操作没有影响。 $unset 从文档中删除指定的字段。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Update-Operators/Array-Update-Operators.html":{"url":"docs/Reference/Operators/Update-Operators/Array-Update-Operators.html","title":"Array Update Operators","keywords":"","body":" 数组更新运算符 在本页面 更新运算符 更新运算符修饰符 注意 有关特定运算符的详细信息，包括语法和示例，请单击特定运算符以转到其参考页。 更新运算符 名称 描述 $ 充当占位符，以更新与查询条件匹配的第一个元素。 $[] 充当占位符，以更新匹配查询条件的文档的数组中的所有元素。 $[] 充当占位符，以更新arrayFilters与查询条件匹配的文档中所有与条件匹配的元素。 $addToSet 仅当元素不存在于集合中时才将它们添加到数组中。 $pop 删除数组的第一项或最后一项。 $pull 删除与指定查询匹配的所有数组元素。 $push 将项目添加到数组。 $pullAll 从数组中删除所有匹配的值。 更新运算符修饰符 名称 描述 $each 修改$push和$addToSet运算符以附加多个项以进行数组更新。 $position 修改$push运算符以指定要添加元素的数组中的位置。 $slice 修改$push运算符以限制更新数组的大小。 $sort 修改$push运算符以对存储在数组中的文档重新排序。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Update-Operators/Bitwise-Update-Operator.html":{"url":"docs/Reference/Operators/Update-Operators/Bitwise-Update-Operator.html","title":"Bitwise Update Operator","keywords":"","body":" 按位更新运算符 注意 有关特定运算符的详细信息，包括语法和示例，请单击特定运算符以转到其参考页。 名称 描述 $bit 执行按位AND，OR和XOR整数值的更新。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Aggregation-Pipeline-Stages.html":{"url":"docs/Reference/Operators/Aggregation-Pipeline-Stages.html","title":"Aggregation Pipeline Stages","keywords":"","body":" 聚合管道阶段 在db.collection.aggregate和db.aggregate方法中 ，管道阶段出现在列表中。文档按顺序通过各个阶段。 阶段 db.collection.aggregate()阶段 除了$out、$merge和$geoNear阶段之外，所有阶段都可以在管道中出现多次。 注意 有关特定运算符的详细信息，包括语法和示例，请单击特定运算符以转到其参考页。 db.collection.aggregate( [ { }, ... ] ) 阶段 描述 $addFields 向文档添加新字段。与$project类似，$addFields重塑了流中的每个文档;具体而言，通过向输出文档添加新字段，该文档包含输入文档和新添加字段中的现有字段。$set是的别名$addFields。 $bucket 根据指定的表达式和存储段边界将传入文档分类为称为存储段的组。 $bucketAuto 根据指定的表达式将传入的文档分类为特定数量的组(称为存储桶)。自动确定存储桶边界，以尝试将文档均匀地分配到指定数量的存储桶中。 $collStats 返回有关集合或视图的统计信息。 $count 返回聚合管道此阶段的文档数量计数。 $facet 在同一阶段的同一组输入文档上处理多个聚合管道。支持在一个阶段中创建能够表征多维或多面数据的多面聚合。 $geoNear 基于与地理空间点的接近度返回有序的文档流。将$match，$sort和$limit的功能合并到地理空间数据中。输出文档包括附加距离字段，并且可以包括位置标识符字段。 $graphLookup 对集合执行递归搜索。对于每个输出文档，添加一个新的 array 字段，该字段包含该文档的递归搜索的遍历结果。 $group 按指定的标识符表达式对文档进行分组，并将累加器表达式(如果指定)应用于每个 group。消耗所有输入文档，并为每个不同的 group 输出一个文档。输出文档仅包含标识符字段，如果指定，则包含累积字段。 $indexStats 返回有关集合的每个索引的使用的统计信息。 $limit 将未修改的前 n 个文档传递给管道，其中 n 是指定的限制。对于每个输入文档，输出一个文档(对于前 n 个文档)或零文档(在前 n 个文档之后)。 $listSessions 列出所有活动时间已足够长以传播到system.sessions集合的会话。 $lookup 对同一数据库中的另一个集合执行左外连接，以从“已连接”集合中过滤文档以进行处理。 $match 过滤文档流以仅允许匹配的文档未经修改地传递到下一个管道阶段。 $match使用标准的 MongoDB 查询。对于每个输入文档，输出一个文档(匹配)或零文档(不匹配)。 $merge 将聚合管道的结果文档写入集合。该阶段可以将结果合并（插入新文档，合并文档，替换文档，保留现有文档，使操作失败，使用自定义更新管道处理文档）将结果合并到输出集合中。要使用该$merge阶段，它必须是管道中的最后一个阶段。4.2版中的新功能。 $out 将聚合管道的结果文档写入集合。要使用$out阶段，它必须是管道中的最后一个阶段。 $planCacheStats 返回集合的计划缓存信息。 $project 重塑流中的每个文档，例如通过添加新字段或删除现有字段。对于每个输入文档，输出一个文档。另请参阅$unset删除现有字段。 $redact 通过基于文档本身中存储的信息限制每个文档的内容来重塑流中的每个文档。包含$project和$match的功能。可用于实现字段级编辑。对于每个输入文档，输出一个或零个文档。 $replaceRoot 用指定的嵌入文档替换文档。该操作将替换输入文档中的所有现有字段，包括_id字段。指定嵌入在输入文档中的文档，以将嵌入的文档提升到顶部级别。$replaceWith是$replaceRoot阶段的别名 。 $replaceWith 用指定的嵌入文档替换文档。该操作将替换输入文档中的所有现有字段，包括_id字段。指定嵌入在输入文档中的文档，以将嵌入的文档提升到顶部级别。$replaceWith是$replaceRoot阶段的别名 。 $sample 从输入中随机选择指定数量的文档。 $set 将新字段添加到文档。与$project相似，$set重塑流中的每个文档；具体而言，通过向输出文档添加新字段，该输出文档既包含输入文档中的现有字段，又包含新添加的字段。$set是$addFields阶段的别名。 $skip 跳过前 n 个文档，其中 n 是指定的跳过编号，并将未修改的其余文档传递给管道。对于每个输入文档，输出零文档(对于前 n 个文档)或一个文档(如果在前 n 个文档之后)。 $sort 按指定的排序 key 重新排序文档流。只有顺序改变;文档保持不变。对于每个输入文档，输出一个文档。 sortByCount 根据指定表达式的 value 对传入文档进行分组，然后计算每个不同 group 中的文档计数。 $unset 从文档中删除/排除字段。$unset是$project删除字段的阶段的别名。 $unwind 从输入文档解构 array 字段以输出每个元素的文档。每个输出文档都使用元素 value 替换 array。对于每个输入文档，输出 n 个文档，其中 n 是 array 元素的数量，对于空 array 可以为零。 对于要在管道阶段使用的聚合表达式运算符，请参阅聚合管道操作符。 db.aggregate()阶段 从 version 3.6 开始，MongoDB 还提供了db.aggregate方法： db.aggregate( [ { }, ... ] ) 以下阶段使用db.aggregate()方法而不是db.collection.aggregate()方法。 阶段 描述 $currentOp 返回有关 MongoDB 部署的活动 and/or 休眠操作的信息。 $listLocalSessions 列出最近在当前连接的mongos或mongod实例上使用的所有 active 会话。这些会话可能尚未传播到system.sessions集合。 阶段可用于更新 从MongoDB 4.2开始，您可以使用聚合管道在以下位置进行更新： 命令 mongo shell方法 findAndModify db.collection.findOneAndUpdate（）db.collection.findAndModify（） update db.collection.updateOne（）db.collection.updateMany（）db.collection.update（）Bulk.find.update（）Bulk.find.updateOne（）Bulk.find.upsert（） 对于更新，管道可以包括以下阶段： $addFields 及其别名 $set $project 及其别名 $unset $replaceRoot及其别名$replaceWith。 按字母顺序排列的阶段列表 阶段 描述 $addFields 向文档添加新字段。输出包含输入文档和新添加字段中所有现有字段的文档。 $bucket 根据指定的表达式和存储段边界将传入文档分类为称为存储段的组。 $bucketAuto 根据指定的表达式将传入的文档分类为特定数量的组(称为存储桶)。自动确定存储桶边界，以尝试将文档均匀地分配到指定数量的存储区中。 $collStats 返回有关集合或视图的统计信息。 $count 返回聚合管道此阶段的文档数量计数。 $currentOp 返回有关 MongoDB 部署的活动 and/or 休眠操作的信息。要运行，请使用db.aggregate()方法。 $facet 在同一组输入文档的单个阶段内处理多个聚合管道。允许创建能够在单个阶段中跨多个维度或方面表征数据的 多面聚合。 $geoNear 基于与地理空间点的接近度返回有序的文档流。将$match，$sort和$limit的功能合并到地理空间数据中。输出文档包括附加距离字段，并且可以包括位置标识符字段。 $graphLookup 对集合执行递归搜索。对于每个输出文档，添加一个新的 array 字段，该字段包含该文档的递归搜索的遍历结果。 $group 按指定的标识符表达式对文档进行分组，并将累加器表达式(如果指定)应用于每个 group。消耗所有输入文档，并为每个不同的 group 输出一个文档。输出文档仅包含标识符字段，如果指定，则包含累积字段。 $indexStats 返回有关集合的每个索引的使用的统计信息。 $limit 将未修改的前 n 个文档传递给管道，其中 n 是指定的限制。对于每个输入文档，输出一个文档(对于前 n 个文档)或零文档(在前 n 个文档之后)。 $listLocalSessions 列出最近在当前连接的mongos或mongod实例上使用的所有 active 会话。这些会话可能尚未传播到system.sessions集合。 $listSessions 列出所有活动时间已足够长以传播到system.sessions集合的会话。 $lookup 对同一数据库中的另一个集合执行左外连接，以从“已连接”集合中过滤文档以进行处理。 $match 过滤文档流以仅允许匹配的文档未经修改地传递到下一个管道阶段。 $match使用标准的 MongoDB 查询。对于每个输入文档，输出一个文档(匹配)或零文档(不匹配)。 $merge 将聚合管道的结果文档写入集合。该阶段可以将结果合并（插入新文档，合并文档，替换文档，保留现有文档，使操作失败，使用自定义更新管道处理文档）将结果合并到输出集合中。要使用该$merge阶段，它必须是管道中的最后一个阶段。4.2版中的新功能。 $out 将聚合管道的结果文档写入集合。要使用$out阶段，它必须是管道中的最后一个阶段。 $planCacheStats 返回集合的计划缓存信息。 $project 重新整形流中的每个文档，例如添加新字段或删除现有字段。对于每个输入文档，输出一个文档。 $redact 通过基于文档本身中存储的信息限制每个文档的内容来重塑流中的每个文档。包含$project和$match的功能。可用于实现字段级编辑。对于每个输入文档，输出一个或零个文档。 $replaceRoot 用指定的嵌入文档替换文档。该操作将替换输入文档中的所有现有字段，包括_id字段。指定嵌入在输入文档中的文档，以将嵌入的文档提升到顶部级别。 $replaceWith 用指定的嵌入文档替换文档。该操作将替换输入文档中的所有现有字段，包括_id字段。指定嵌入在输入文档中的文档，以将嵌入的文档提升到顶部级别。别名$replaceRoot。 $sample 从输入中随机选择指定数量的文档。 $set 将新字段添加到文档。输出包含输入文档中所有现有字段和新添加的字段的文档。别名$addFields。 $skip 跳过前 n 个文档，其中 n 是指定的跳过编号，并将未修改的其余文档传递给管道。对于每个输入文档，输出零文档(对于前 n 个文档)或一个文档(如果在前 n 个文档之后)。 $sort 按指定的排序 key 重新排序文档流。只有顺序改变;文件保持不变。对于每个输入文档，输出一个文档。 $sortByCount 根据指定表达式的值对传入文档进行分组，然后计算每个不同组中的文档数。 $unwind 从输入文档解构 array 字段以输出每个元素的文档。每个输出文档都使用元素 value 替换 array。对于每个输入文档，输出 n 个文档，其中 n 是 array 元素的数量，对于空 array 可以为零。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Aggregation-Pipeline-Operators.html":{"url":"docs/Reference/Operators/Aggregation-Pipeline-Operators.html","title":"Aggregation Pipeline Operators","keywords":"","body":" 聚合管道操作符 注意： 有关特定运算符的详细信息，包括语法和示例，请单击特定运算符以转到其参考页。 表达式运算符 在这个部分 算术表达式运算符 列表表达式运算符 布尔表达式运算符 比较表达式运算符 条件表达式运算符 日期表达式运算符 文字表达式运算符 对象表达式运算符 集合表达式运算符 字符串表达式运算符 文本表达式运算符 三角表达式运算符 类型表达式运算符 累加器($group) 累加器(处于其他阶段) 变量表达式运算符 这些表达式运算符可用于构造表达式以在聚合管道阶段中使用。 运算符表达式类似于带有参数的函数。通常，这些表达式采用参数数组并具有以下形式： { : [ , ... ] } 如果 operator 接受单个参数，可以省略指定参数列表的外部数组： { : } 为了避免在参数是文字数组的情况下解析歧义，必须将文字数组包装在$literal表达式中，或者保留指定参数列表的外部数组。 算术表达式运算符 算术表达式对 numbers 执行数学运算。一些算术表达式也可以支持 date 算术。 名称 描述 $abs 返回数字的绝对 value。 $add 添加 numbers 以 return 总和，或添加 numbers 和 date 以 return 新的 date。如果添加 numbers 和 date，则将 numbers 视为毫秒。接受任意数量的参数表达式，但最多只能有一个表达式解析为 date。 $ceil 返回大于或等于指定数字的最小 integer。 $divide 返回将第一个数除以第二个数的结果。接受两个参数表达式。 $exp 将 e 提高到指定的指数。 $floor 返回小于或等于指定数字的最大 integer。 $ln 计算数字的自然 log。 $log 计算指定基数中的数字的 log。 $log10 计算数字的 log 基数 10。 $mod 返回第一个数字的余数除以第二个数字。接受两个参数表达式。 $multiply 将 numbers 乘以_return 产品。接受任意数量的参数表达式。 $pow 将数字提高到指定的指数。 $round 将数字四舍五入为整数或指定的小数位。 $sqrt 计算平方根。 $subtract 返回从第一个中减去第二个 value 的结果。如果这两个值是 numbers，返回差异。如果这两个值是日期，则返回差异(以毫秒为单位)。如果这两个值是 date 和一个以毫秒为单位的数字，_return 结果 date。接受两个参数表达式。如果这两个值是 date 和数字，请首先指定 date 参数，因为从数字中减去 date 没有意义。 $trunc 截断其整数的数字。 列表表达式运算符 名称 描述 $arrayElemAt 返回指定的数组索引处的元素。 $arrayToObject 将键值对的数组转换为文档。 $concatArrays 连接数组以返回连接的数组。 $filter 选择数组的子集以返回仅包含与过滤条件匹配的元素的数组。 $in 返回一个布尔值，指示指定的值是否在数组中。 $indexOfArray 在数组中搜索指定值的出现，并返回第一个出现的数组索引。如果未找到子字符串，则返回-1。 $isArray 确定操作数是否为数组。返回一个布尔值。 $map 对数组的每个元素应用子表达式，并按顺序返回结果值的数组。接受命名参数。 $objectToArray 将文档转换为代表键值对的文档数组。 $range 根据用户定义的输入输出包含整数序列的数组。 $reduce 将表达式应用于数组中的每个元素，并将它们组合为单个值。 $reverseArray 返回具有相反顺序元素的数组。 $size 返回数组中元素的数量。接受单个表达式作为参数。 $slice 返回数组的子集。 $zip 合并两个数组。 布尔表达式运算符 布尔表达式将其参数表达式计算为布尔值，并返回布尔值作为结果。 除了false布尔值，布尔表达式为false如下：null，0，和undefined 的值。布尔表达式将所有其他值评估为true，包括非零数字值和数组。 名称 描述 $and 仅当其所有表达式求值为true时才返回true。接受任意数量的参数表达式。 $not 返回与其参数表达式相反的 boolean value。接受单个参数表达式。 $or 当任何表达式求值为true时返回true。接受任意数量的参数表达式。 比较表达式运算符 比较表达式返回一个布尔值，但$cmp返回一个数字。 比较表达式采用两个参数表达式并比较 value 和 type，使用指定的 BSON 比较顺序表示不同类型的值。 名称 描述 $cmp 如果两个值相等则返回0，如果第一个 value 大于第二个值则返回1，如果第一个 value 小于第二个值，则返回-1。 $eq 如果值相等，则返回true。 $gt 如果第一个 value 大于第二个，则返回true。 $gte 如果第一个 value 大于或等于第二个，则返回true。 $lt 如果第一个 value 小于第二个，则返回true。 $lte 如果第一个 value 小于或等于第二个值，则返回true。 $ne 如果值不相等，则返回true。 条件表达式运算符 名称 描述 $cond 一个三元运算符，它计算一个表达式，并根据结果返回另外两个表达式之一的值。接受有序列表中的三个表达式或三个命名参数。 $ifNull 如果第一个表达式导致结果为null ，则返回第一个表达式的非空结果或第二个表达式的结果。空结果包含未定义值或缺少字段的实例。接受两个表达式作为参数。第二个表达式的结果可以为 null。 $switch 计算一系列案例表达式。当它找到一个计算结果为true的表达式时，$switch执行一个指定的表达式并退出控制流。 日期表达式运算符 以下运算符返回日期对象或日期对象的组成部分： 名称 描述 $dateFromParts 给出日期的组成部分，构造一个 BSON Date对象。 $dateFromString 将 date/time 字符串转换为 date 对象。 $dateToParts 返回包含 date 组成部分的文档。 $dateToString 将 date 作为格式化的 string 返回。 $dayOfMonth 将 date 的月中某天返回为 1 到 31 之间的数字。 $dayOfWeek 将 date 的星期几返回为 1(星期日)和 7(星期六)之间的数字。 $dayOfYear 将 date 的年中日期作为 1 到 366(闰年)之间的数字返回。 $hour 将 date 的小时数作为 0 到 23 之间的数字返回。 $isoDayOfWeek 返回 ISO 8601 格式的工作日编号，范围从1(星期一)到7(星期日)。 $isoWeek 返回 ISO 8601 格式的周数，范围从1到53。 星期数从1开始，周(星期一到星期日)包含年份的第一个星期四。 $isoWeekYear 以 ISO 8601 格式返回年份编号。年份从第 1 周的星期一(ISO 8601)开始，结束于上周的星期日(ISO 8601)。 $millisecond 返回 date 的毫秒数，作为 0 到 999 之间的数字。 $minute 将 date 的分钟作为 0 到 59 之间的数字返回。 $month 将 date 的月份返回为 1(1 月)和 12(12 月)之间的数字。 $second 返回 date 的秒数，作为 0 到 60 之间的数字(闰秒)。 $toDate 将值转换为日期。版本4.0中的新功能。 $week 返回 date 的周数，作为 0(在一年的第一个星期日之前的部分周)和 53(闰年)之间的数字。 $year 将 date 的年份作为数字返回(例：2014)。 以下算术运算符可以使用 date 操作数： 名称 描述 $add 添加 numbers 和 date 以返回新的 date。如果添加 numbers 和 date，则将 numbers 视为毫秒。接受任意数量的参数表达式，但最多只能有一个表达式解析为 date。 $subtract 返回从第一个中减去第二个值的结果。如果这两个值是日期，则返回差异(以毫秒为单位)。如果这两个值是 date 和一个以毫秒为单位的数字，返回结果 date。接受两个参数表达式。如果这两个值是 date 和数字，请首先指定 date 参数，因为从数字中减去 date 没有意义。 文字表达式运算符 名称 描述 $literal 无需解析即可返回 value。用于聚合管道可以将其解释为表达式的值。例如，对以$开头的字符串使用]$literal表达式，以避免解析为字段路径。 对象表达式运算符 名称 描述 $mergeObjects 将多个文档合并为一个文档。 version 3.6 中的新内容。 $objectToArray 将文档转换为表示 key-value 对的文档的 array。 version 3.6 中的新内容。 集合表达式运算符 Set 表达式对数组执行 set 操作，将数组视为 sets。 Set 表达式忽略每个输入数组中的重复条目和元素的顺序。 如果 set 操作返回一个 set，则该操作会过滤掉结果中的重复项，以输出仅包含唯一条目的 array。输出 array 中元素的顺序未指定。 如果集合包含嵌套的 array 元素，则 set 表达式不会下降到嵌套的 array 中，而是在顶层level 处计算 array。 名称 描述 $allElementsTrue 如果没有集合的元素计算为false，则返回true，否则返回false。接受单个参数表达式。 $anyElementTrue 如果集合中的任何元素求值为true，则返回true;否则，返回false。接受单个参数表达式。 $setDifference 返回一个集合，其中的元素出现在第一个集合中但不出现在第二个集合中; 即：相对于第一组执行第二组的相对补充。接受两个参数表达式。 $setEquals 如果输入 sets 具有相同的不同元素，则返回true。接受两个或多个参数表达式。 $setIntersection 返回一个包含所有输入 sets 中出现的元素的集合。接受任意数量的参数表达式。 $setIsSubset 如果第一组的所有元素出现在第二组中，则返回true，包括第一组的等于第二组的时间; 即：不是严格的子集。接受两个参数表达式。 $setUnion 返回一个包含任何输入 sets 中出现的元素的集合。 字符串表达式运算符 字符串表达式（除外 $concat）仅对ASCII字符字符串具有明确定义的行为。 $concat 行为是明确定义的，与所使用的字符无关。 名称 描述 $concat 连接任意数量的 strings。 $dateFromString 将 date/time string 转换为 date object。 $dateToString 将 date 作为格式化的 string 返回。 $indexOfBytes 搜索 string 以查找子字符串的出现并返回第一次出现的 UTF-8 字节索引。如果未找到子字符串，则返回-1。 $indexOfCP 搜索 string 以查找子字符串的出现并返回第一次出现的 UTF-8 code 点索引。如果找不到子字符串，则返回-1 $ltrim 从字符串开头删除空格或指定的字符。版本4.0中的新功能。 $regexFind 将正则表达式（regex）应用于字符串，并返回第一个匹配的子字符串的信息。4.2版中的新功能。 $regexFindAll 将正则表达式（regex）应用于字符串，并返回所有匹配的子字符串的信息。4.2版中的新功能。 $regexMatch 将正则表达式（regex）应用于字符串，并返回一个布尔值，该布尔值指示是否找到匹配项。4.2版中的新功能。 $rtrim 从字符串末尾删除空格或指定的字符。版本4.0中的新功能。 $split 根据分隔符将 string 拆分为子字符串。返回子字符串的 array。如果在 string 中找不到分隔符，则返回包含原始 string 的 array。 $strLenBytes 返回 string 中 UTF-8 编码字节的数量。 $strLenCP 返回 string 中 UTF-8 code 点的数量。 $strcasecmp 执行 case-insensitive string 比较并返回：如果两个 strings 相等则返回0，如果第一个 string 大于第二个，则返回1，如果第一个 string 小于第二个，则返回-1。 $substr 已过时。使用$substrBytes或$substrCP。 $substrBytes 返回 string 的子字符串。从 string 中指定的 UTF-8 字节索引(zero-based)处的字符开始，并继续指定的字节数。 $substrCP 返回 string 的子字符串。从 string 中指定的 UTF-8 code point(CP)索引(zero-based)处的字符开始，并继续指定的 code 点数。 $toLower 将 string 转换为小写。接受单个参数表达式。 $toString 将值转换为字符串。版本4.0中的新功能。 $trim 从字符串的开头和结尾删除空格或指定的字符。版本4.0中的新功能。 $toUpper 将 string 转换为大写。接受单个参数表达式。 文本表达式运算符 名称 描述 $meta 访问文本搜索元数据。 三角表达式运算符 三角表达式对数字执行三角运算。表示角度的值始终以弧度为单位输入或输出。使用 $degreesToRadians和$radiansToDegrees在度和弧度测量之间转换。 名称 描述 $sin 返回以弧度为单位的值的正弦值。 $cos 返回以弧度为单位的值的余弦值。 $tan 返回以弧度为单位的值的切线。 $asin 返回弧度值的反正弦（弧正弦）。 $acos 返回弧度值的反余弦（弧余弦）。 $atan 返回弧度值的反正切（弧切）。 $atan2 返回弧度表示的y / x的反正切（弧切线），其中y和x是分别传递给表达式的第一个和第二个值。 $asinh 返回弧度值的反双曲正弦（双曲反正弦）。 $acosh 返回弧度值的反双曲余弦（双曲反余弦）。 $atanh 返回弧度值的反双曲正切（双曲反正切）。 $degreesToRadians 将值从度转换为弧度。 $radiansToDegrees 将值从弧度转换为度。 类型表达式运算符 名称 描述 $convert 将值转换为指定的类型。版本4.0中的新功能。 $toBool 将值转换为布尔值。版本4.0中的新功能。 $toDate 将值转换为日期。版本4.0中的新功能。 $toDecimal 将值转换为Decimal128。版本4.0中的新功能。 $toDouble 将值转换为双精度。版本4.0中的新功能。 $toInt 将值转换为整数。版本4.0中的新功能。 $toLong 将值转换为long。版本4.0中的新功能。 $toObjectId 将值转换为ObjectId。版本4.0中的新功能。 $toString 将值转换为字符串。版本4.0中的新功能。 $type 返回该字段的BSON数据类型。 累加器($group) 累加器是可以在$group阶段使用的运算符，它们在文档通过管道时保持其状态(例如： 总计，最大值，最小值和相关数据)。 当在$group阶段用作累加器时，这些运算符将单个表达式作为输入，为每个输入文档计算一次表达式，并为共享相同 group key 的 group 文档保持其阶段。 名称 描述 $addToSet 返回每个 group 的唯一表达式值的 array。 数组元素的顺序是未定义的。 $avg 返回数值的平均值。忽略非数字值。 $first 从每个 group 的第一个文档返回一个值。仅当文档按定义的顺序定义顺序。 $last 从每个 group 的最后一个文档返回一个值。仅当文档按定义的顺序定义顺序。 $max 返回每个 group 的最高表达式值。 $mergeObjects 返回通过组合每个 group 的输入文档创建的文档。 $min 返回每个 group 的最低表达式值。 $push 返回每个 group 的表达式值的 array。 $stdDevPop 返回输入值的总体标准偏差。 $stdDevSamp 返回输入值的 sample 标准偏差。 $sum 返回数值的总和。忽略非数字值。 累加器(处于其他阶段) 一些可用作$group阶段累加器的运算符也可用于$project阶段，但不能用作累加器。在$project阶段使用时，这些 operator 不会维护它们的 state，并且可以将单个参数或多个 arguments 作为输入。 更改了 version 3.2. 以下累加器 operators 也可用于$project、$addFields和$set阶段。 名称 描述 $avg 返回每个文档的指定表达式或表达式列表的平均值。忽略非数字值。 $max 返回每个文档的指定表达式或表达式列表的最大值。 $min 返回每个文档的指定表达式或表达式列表的最小值。 $stdDevPop 返回输入值的总体标准偏差。 $stdDevSamp 返回输入值的样本标准偏差。 $sum 返回数值的总和。忽略非数字值。 变量表达式运算符 名称 描述 $let 定义在子表达式范围内使用的变量，并返回子表达式的结果。接受命名参数。 接受任意数量的参数表达式。 表达式运算符的字母顺序列表 名称 描述 $abs 返回数字的绝对值。 $acos 返回弧度值的反余弦（弧余弦）。 $acosh 返回弧度值的反双曲余弦（双曲反余弦）。 $add 添加数字以返回总和，或者添加数字和日期以返回新日期。如果添加数字和日期，则将数字视为毫秒。接受任意数量的参数表达式，但最多只能一个表达式解析为日期。 $addToSet 返回每个 group 的唯一表达式值的 array。 数组元素的顺序是未定义的。 仅适用于$group阶段 $allElementsTrue 如果没有集合的元素计算为false，则返回true，否则返回false。接受单个参数表达式。 $and 仅当其所有表达式求值为true时才返回true。接受任意数量的参数表达式。 $anyElementTrue 如果集合中的任何元素求值为true，则返回true;否则，返回false。接受单个参数表达式。 $arrayElemAt 返回指定的 array 索引处的元素。 $arrayToObject 将键值对的 array 转换为文档。 $asin 返回弧度值的反正弦（弧正弦）。 $asinh 返回弧度值的反双曲正弦（双曲反正弦）。 $atan 返回弧度值的反正切（弧切）。 $atan2 返回弧度表示的y / x的反正切（弧切线），其中y和x是分别传递给表达式的第一个和第二个值。 $atanh 返回弧度值的反双曲正切（双曲反正切）。 $avg 返回数值的平均值。忽略非数字值。 在 version 3.2 中更改：在$group和$project阶段均可用。 $ceil 返回大于或等于指定数字的最小整数。 $cmp 如果两个值相等则返回0，如果第一个 value 大于第二个值则返回1，如果第一个 value 小于第二个值，则返回-1。 $concat 连接任意数量的字符串。 $concatArrays 连接数组以返回连接的数组。 $cond 一个三元运算符，它计算一个表达式，并根据结果返回另外两个表达式之一的值。接受有序列表中的三个表达式或三个命名参数。 $convert 将值转换为指定的类型。 $cos 返回以弧度为单位的值的余弦值。 $dateFromParts 给出 date 的组成部分，构造一个 BSON Date对象。 $dateToParts 返回包含 date 组成部分的文档。 $dateFromString 返回 date/time 作为 date 对象。 $dateToString 将 date 作为格式化的 string 返回。 $dayOfMonth 将 date 的月中某天返回为 1 到 31 之间的数字。 $dayOfWeek 将 date 的星期几返回为 1(星期日)和 7(星期六)之间的数字。 $dayOfYear 将 date 的年中日期作为 1 到 366(闰年)之间的数字返回。 $degreesToRadians 将值从度转换为弧度。 $divide 返回将第一个数除以第二个数的结果。接受两个参数表达式。 $eq 如果值相等，则返回true。 $exp 将 e 提高到指定的指数。 $filter 选择 array 的子集以返回 array 仅包含 match 过滤条件的元素。 $first 从每个 group 的第一个文档返回一个 value。仅当文档位于已定义的 order 中时才定义 Order。 仅适用于$group阶段。 $floor 返回小于或等于指定数字的最大 integer。 $gt 如果第一个 value 大于第二个，则返回true。 $gte 如果第一个 value 大于或等于第二个，则返回true。 $hour 将 date 的小时数作为 0 到 23 之间的数字返回。 $ifNull 如果第一个表达式导致 null 结果，则返回第一个表达式的 non-null 结果或第二个表达式的结果。空结果包含未定义值或缺少字段的实例。接受两个表达式作为参数。第二个表达式的结果可以为 null。 $in 返回一个 boolean，指示指定的 value 是否在 array 中。 $indexOfArray 搜索 array 以查找指定 value 的出现并返回第一次出现的 array 索引。如果未找到子字符串，则返回-1。 $indexOfBytes 搜索 string 以查找子字符串的出现并返回第一次出现的 UTF-8 字节索引。如果未找到子字符串，则返回-1。 $indexOfCP 搜索 string 以查找子字符串的出现并返回第一次出现的 UTF-8 code 点索引。如果未找到子字符串，则返回-1。 $isArray 确定操作数是否为 array。返回 boolean。 $isoDayOfWeek 返回 ISO 8601 格式的工作日编号，范围从1(星期一)到7(星期日)。 $isoWeek 返回 ISO 8601 格式的周数，范围从1到53。 Week numbers 从1开始，周(星期一到星期日)包含年份的第一个星期四。 $isoWeekYear 以 ISO 8601 格式返回年份编号。年份从第 1 周的星期一(ISO 8601)开始，结束于上周的星期日(ISO 8601)。 $last 从每个 group 的最后一个文档返回一个 value。仅当文档位于已定义的 order 中时才定义 Order。 仅适用于$group阶段。 $let 定义在子表达式范围内使用的变量，并返回子表达式的结果。接受命名参数。 接受任意数量的参数表达式。 $literal 无需解析即可返回 value。用于聚合管道可以将其解释为表达式的值。例如，对以$开头的字符串使用$literal表达式，以避免解析为字段路径。 $ln 计算数字的自然对数。 $log 计算指定基数中的数字的对数。 $log10 计算数字的以10为底的对数。 $lt 如果第一个 value 小于第二个，则返回true。 $lte 如果第一个 value 小于或等于第二个值，则返回true。 $ltrim 从字符串开头删除空格或指定的字符。 $map 将子表达式应用于 array 的每个元素，并按顺序返回结果值的 array。接受命名参数。 $max 返回每个 group 的最高表达式 value。 在 version 3.2 中更改：在$group和$project阶段均可用。 $mergeObjects 将多个文档合并为一个文档。 $meta 访问文本搜索元数据。 $min 返回每个 group 的最低表达式 value。 在 version 3.2 中更改：在$group和$project阶段均可用。 $millisecond 返回 date 的毫秒数，作为 0 到 999 之间的数字。 $minute 将 date 的分钟作为 0 到 59 之间的数字返回。 $mod 返回第一个数字的余数除以第二个数字。接受两个参数表达式。 $month 将 date 的月份返回为 1(1 月)和 12(12 月)之间的数字。 $multiply 乘以数字可返回乘积。接受任意数量的参数表达式。 $ne 如果值不相等，则返回true。 $not 返回与其参数表达式相反的布尔值。接受单个参数表达式。 $objectToArray 将文档转换为表示键值对的文档的 array。 $or 当任何表达式求值为true时返回true。接受任意数量的参数表达式。 $pow 将数字提高到指定的指数。 $push 返回每个 group 的表达式值的 array。 仅适用于$group阶段。 $range 根据用户定义输入输出包含整数序列的 array。 $reduce 将表达式应用于 array 中的每个元素，并将它们组合为单个 value。 $regexFind 将正则表达式（regex）应用于字符串，并返回第一个匹配的子字符串的信息。 $regexFindAll 将正则表达式（regex）应用于字符串，并返回所有匹配的子字符串的信息。 $regexMatch 将正则表达式（regex）应用于字符串，并返回一个布尔值，该布尔值指示是否找到匹配项。 $reverseArray 返回具有相反顺序元素的 array。 $round 将数字四舍五入为整数或指定的小数位。 $rtrim 从字符串末尾删除空格或指定的字符。 $second 返回 date 的秒数，作为 0 到 60 之间的数字(闰秒)。 $setDifference 返回一个集合，其中的元素出现在第一个集合中但不出现在第二个集合中; 即：相对于第一组执行第二组的相对补充)。接受两个参数表达式。 $setEquals 如果输入集合具有相同的不同元素，则返回true。接受两个或多个参数表达式。 $setIntersection 返回一个包含所有输入集合中出现的元素的集合。接受任意数量的参数表达式。 $setIsSubset 如果第一组的所有元素出现在第二组中，则返回true，包括第一组的等于第二组的时间; 即：不是严格的子集。接受两个参数表达式。 $setUnion 返回一个包含任何输入集合中出现的元素的集合。 $size 返回 array 中的元素数。接受单个表达式作为参数。 $sin 返回以弧度为单位的值的正弦值。 $slice 返回 array 的子集。 $split 根据分隔符将 string 拆分为子字符串。返回子字符串的 array。如果在 string 中找不到分隔符，则返回包含原始 string 的 array。 $sqrt 计算平方根。 $stdDevPop 返回输入值的总体标准偏差。 在 version 3.2 中更改：在$group和$project阶段均可用。 $stdDevSamp 返回输入值的样本标准偏差。 在 version 3.2 中更改：在$group和$project阶段均可用。 $strcasecmp 执行不区分大小写的字符串比较并返回：如果两个字符串相等则返回0，如果第一个字符串大于第二个，则返回1，如果第一个字符串小于第二个，则返回-1。 $strLenBytes 返回 string 中 UTF-8 编码字节的数量。 $strLenCP 返回 string 中 UTF-8 code 点的数量。 $substr 已过时。使用$substrBytes或$substrCP。 $substrBytes 返回 string 的子字符串。从 string 中指定的 UTF-8 字节索引(从零开始)处的字符开始，并继续指定的字节数。 $substrCP 返回 string 的子字符串。从 string 中指定的 UTF-8 code point(CP)索引(从零开始)处的字符开始，并继续指定的 code 点数 $subtract 返回从第一个中减去第二个 value 的结果。如果这两个值是数字，返回差值。如果这两个值是日期，则返回差值(以毫秒为单位)。如果这两个值是 date 和一个以毫秒为单位的数字，则返回结果 date。接受两个参数表达式。如果这两个值是 date 和数字，请首先指定 date 参数，因为从数字中减去 date 没有意义。 $sum 返回数值的总和。忽略非数字值。 在 version 3.2 中更改：在$group和$project阶段均可用。 $switch 计算一系列案例表达。当它找到一个计算结果为true的表达式时，$switch执行一个指定的表达式并退出控制流。 $tan 返回以弧度为单位的值的切线。 $toBool 将值转换为布尔值。 $toDate 将值转换为日期。 $toDecimal 将值转换为Decimal128。 $toDouble 将值转换为双精度。 $toInt 将值转换为整数。 $toLong 将值转换为long。 $toObjectId 将值转换为ObjectId。 $toString 将值转换为字符串。 $toLower 将 string 转换为小写。接受单个参数表达式。 $toUpper 将 string 转换为大写。接受单个参数表达式。 $trim 从字符串的开头和结尾删除空格或指定的字符。 $trunc 截断其整数的数字。 $type 返回该字段的 BSON 数据类型。 $week 返回 date 的周数，作为 0(在一年的第一个星期日之前的部分周)和 53(闰年)之间的数字。 $year 将 date 的年份作为数字返回(例：2014)。 $zip 将两个数组合并在一起。 对于管道阶段，请参见聚合管道阶段。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Aggregation-Pipeline-Operators/abs-aggregation.html":{"url":"docs/Reference/Operators/Aggregation-Pipeline-Operators/abs-aggregation.html","title":"$abs (aggregation)","keywords":"","body":" $abs (aggregation) 在本页面 定义 行为 例子 定义 $abs version 3.2 中的新内容。 返回数字的绝对 value。 $abs具有以下语法： { $abs: } 表达式可以是任何有效的表达，因为它解析为数字。有关表达式的更多信息，请参阅表达式。 行为 如果参数解析为的值或引用缺少的字段，则$abs返回null。如果参数解析为NaN，则$abs返回NaN。 例子 结果 { $abs: -1 } 1 { $abs: 1 } 1 { $abs: null } null 例子 集合ratings包含以下文档： { _id: 1, start: 5, end: 8 } { _id: 2, start: 4, end: 4 } { _id: 3, start: 9, end: 7 } { _id: 4, start: 6, end: 7 } 以下 example 计算start和end评级之间的差异大小： db.ratings.aggregate([ { $project: { delta: { $abs: { $subtract: [ \"$start\", \"$end\" ] } } } } ]) 该操作返回以下结果： { \"_id\" : 1, \"delta\" : 3 } { \"_id\" : 2, \"delta\" : 0 } { \"_id\" : 3, \"delta\" : 2 } { \"_id\" : 4, \"delta\" : 1 } Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Aggregation-Pipeline-Operators/acos-aggregation.html":{"url":"docs/Reference/Operators/Aggregation-Pipeline-Operators/acos-aggregation.html","title":"$acos (aggregation)","keywords":"","body":" $acos (aggregation) 在本页面 行为 例子 $acos 4.2版中的新功能。 返回值的反余弦（弧余弦）。 $acos具有以下语法： { $acos: } $acos接受任何有效的表达式，该表达式可解析为-1 和之间的数字1，例如。-1 $acos返回以弧度为单位的值。使用 $radiansToDegrees运算符将输出值从弧度转换为度。 默认情况下以形式$acos返回值double。 $acos也可以返回值作为 128-bit小数 ，只要该解析为一个128-bit的十进制值。 有关表达式的更多信息，请参见 表达式。 行为 如果参数解析为null的值或指向缺少的字段，则$acos返回null。如果参数解析为NaN，则$acos返回NaN。如果参数解析为包含[-1, 1] 范围之外的值 ，则$acos会引发错误。。 例子 结果 { $acos: NaN } NaN { $acos: null } null { $acos : Infinity}or{ $acos : -Infinity } 引发类似于以下格式化输出的错误消息：\"errmsg\" : \"Failed to optimize pipeline :: caused by :: cannot apply $acos to -inf, value must in [-1,1]\" 例子 度数的反余弦值 该trigonometry集合包含一个文档，该文档存储直角三角形的三个边： { \"_id\" : ObjectId(\"5c50782193f833234ba90d85\"), \"side_a\" : NumberDecimal(\"3\"), \"side_b\" : NumberDecimal(\"4\"), \"hypotenuse\" : NumberDecimal(\"5\") } 以下聚合操作使用该 $acos表达式来计算side_a与$addFields管道之间相邻的角度并将其添加到输入文档中 。 db.trigonometry.aggregate([ { $addFields : { \"angle_a\" : { $radiansToDegrees : { $acos : { $divide : [ \"$side_b\", \"$hypotenuse\" ] } } } } } ]) $radiansToDegrees表达式将返回的弧度值转换为$acos以度为单位的等效值。 该命令返回以下输出： { \"_id\" : ObjectId(\"5c50782193f833234ba90d85\"), \"side_a\" : NumberDecimal(\"3\"), \"side_b\" : NumberDecimal(\"4\"), \"hypotenuse\" : NumberDecimal(\"5\"), \"angle_a\" : NumberDecimal(\"36.86989764584402129685561255909341\") } 由于side_b和hypotenuse被存储为 128-bit小数，因此输出 $acos为128-bit小数。 弧度的反余弦值 trigonometry集合包含一个文档，该文档存储直角三角形的三个边： { \"_id\" : ObjectId(\"5c50782193f833234ba90d85\"), \"side_a\" : NumberDecimal(\"3\"), \"side_b\" : NumberDecimal(\"4\"), \"hypotenuse\" : NumberDecimal(\"5\") } 以下聚合操作使用该 $acos表达式来计算side_a与$addFields管道之间相邻的角度并将其添加到输入文档中 。 db.trigonometry.aggregate([ { $addFields : { \"angle_a\" : { $acos : { $divide : [ \"$side_b\", \"$hypotenuse\" ] } } } } ]) 该命令返回以下输出： { \"_id\" : ObjectId(\"5c50782193f833234ba90d85\"), \"side_a\" : NumberDecimal(\"3\"), \"side_b\" : NumberDecimal(\"4\"), \"hypotenuse\" : NumberDecimal(\"5\"), \"angle_a\" : NumberDecimal(\"0.6435011087932843868028092287173226\") } 由于side_b和hypotenuse被存储为 128-bit小数，因此输出 $acos为128-bit小数。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Aggregation-Pipeline-Operators/acosh-aggregation.html":{"url":"docs/Reference/Operators/Aggregation-Pipeline-Operators/acosh-aggregation.html","title":"$acosh (aggregation)","keywords":"","body":" $acosh (aggregation) 在本页面 行为 例子 $acosh 4.2版中的新功能。 返回值的反双曲余弦（双曲反余弦）。 $acosh 具有以下语法： { $acosh: } $acosh接受任何有效的表达式，该表达式可解析为1 和之间的数字+Infinity，例如：1 $acosh返回以弧度为单位的值。使用 $radiansToDegrees运算符将输出值从弧度转换为度。 默认情况下以形式$acosh返回值double。 $acosh也可以返回值作为 128-bit小数，只要该解析为一个128-bit的十进制值。 有关表达式的更多信息，请参见 表达式。 行为 null，NaN和+/- Infinity 如果参数解析为的值null或指向缺少的字段，则$acosh返回null。如果参数解析为NaN，则$acosh返回NaN。如果参数解析为负无穷大， $acosh则会引发错误。如果参数解析为Infinity，则$acosh返回Infinity。如果参数解析为包含[-1, Infinity]范围之外的值 ，则$acosh会引发错误。 例子 结果 { $acosh: NaN } NaN { $acosh: null } null { $acosh : Infinity} Infinity { $acosh : 0 } 引发类似于以下格式化输出的错误消息：\"errmsg\" : \"Failed to optimize pipeline :: caused by :: cannot apply $acosh to -inf, value must in (1,inf)\" 例子 度数的反双曲余弦值 trigonometry集合包含一个文档，该文档沿x二维图形的轴存储值： { \"_id\" : ObjectId(\"5c50782193f833234ba90d85\"), \"x-coordinate\" : NumberDecimal(\"3\") } 以下聚合操作使用该 $acosh表达式计算的反双曲余弦值，x-coordinate并使用$addFields管道阶段将其添加到输入文档中。 db.trigonometry.aggregate([ { $addFields : { \"y-coordinate\" : { $radiansToDegrees : { $acosh : \"$x-coordinate\" } } } } ]) $radiansToDegrees表达式将返回的弧度值转换为$acosh以度为单位的等效值。 该命令返回以下输出： { \"_id\" : ObjectId(\"5c50782193f833234ba90d85\"), \"x-coordinate\" : NumberDecimal(\"3\"), \"y-coordinate\" : NumberDecimal(\"100.9979734210524228844295260083432\") } 由于x-coordinate存储为 128-bit十进制数，因此输出 $acosh为128-bit十进制数。 弧度的反双曲余弦值 trigonometry集合包含一个文档，该文档沿x二维图形的轴存储值： { \"_id\" : ObjectId(\"5c50782193f833234ba90d85\"), \"x-coordinate\" : NumberDecimal(\"3\") } 以下聚合操作使用该 $acosh表达式计算的反双曲余弦值，x-coordinate并使用$addFields管道阶段将其添加到输入文档中。 db.trigonometry.aggregate([ { $addFields : { \"y-coordinate\" : { $acosh : \"$x-coordinate\" } } } ]) 该命令返回以下输出： { \"_id\" : ObjectId(\"5c50782193f833234ba90d85\"), \"x-coordinate\" : NumberDecimal(\"3\"), \"y-coordinate\" : NumberDecimal(\"1.762747174039086050465218649959585\") } 由于x-coordinate存储为 128-bit十进制数，因此输出 $acosh为128-bit十进制数。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Aggregation-Pipeline-Operators/add-aggregation.html":{"url":"docs/Reference/Operators/Aggregation-Pipeline-Operators/add-aggregation.html","title":"$add (aggregation)","keywords":"","body":" $add (aggregation) 在本页面 定义 例子 定义 $add 添加数字或添加数字和日期。如果其中一个参数是 date，则$add将其他参数视为要添加到 date 的毫秒数。 $add表达式具有以下语法： { $add: [ , , ... ] } 参数可以是任何有效的表达，只要它们可以解析为所有数字或数字和日期。有关表达式的更多信息，请参阅表达式。 例子 以下示例使用带有以下文档的sales集合： { \"_id\" : 1, \"item\" : \"abc\", \"price\" : 10, \"fee\" : 2, date: ISODate(\"2014-03-01T08:00:00Z\") } { \"_id\" : 2, \"item\" : \"jkl\", \"price\" : 20, \"fee\" : 1, date: ISODate(\"2014-03-01T09:00:00Z\") } { \"_id\" : 3, \"item\" : \"xyz\", \"price\" : 5, \"fee\" : 0, date: ISODate(\"2014-03-15T09:00:00Z\") } 添加数字 以下聚合使用$project管道中的$add表达式来计算总成本： db.sales.aggregate( [ { $project: { item: 1, total: { $add: [ \"$price\", \"$fee\" ] } } } ] ) 该操作返回以下结果： { \"_id\" : 1, \"item\" : \"abc\", \"total\" : 12 } { \"_id\" : 2, \"item\" : \"jkl\", \"total\" : 21 } { \"_id\" : 3, \"item\" : \"xyz\", \"total\" : 5 } 在 Date 上执行加法 以下聚合使用$add表达式billing_date通过将3*24*60*60000毫秒(即：3 天)添加到date字段来计算： db.sales.aggregate( [ { $project: { item: 1, billing_date: { $add: [ \"$date\", 3*24*60*60000 ] } } } ] ) 该操作返回以下结果： { \"_id\" : 1, \"item\" : \"abc\", \"billing_date\" : ISODate(\"2014-03-04T08:00:00Z\") } { \"_id\" : 2, \"item\" : \"jkl\", \"billing_date\" : ISODate(\"2014-03-04T09:00:00Z\") } { \"_id\" : 3, \"item\" : \"xyz\", \"billing_date\" : ISODate(\"2014-03-18T09:00:00Z\") } Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Aggregation-Pipeline-Operators/addToSet-aggregation.html":{"url":"docs/Reference/Operators/Aggregation-Pipeline-Operators/addToSet-aggregation.html","title":"$addToSet (aggregation)","keywords":"","body":" $addToSet (aggregation) 在本页面 定义 行为 例子 定义 $addToSet 返回所有唯一值的数组，这些值是通过将表达式应用于一组按键共享相同组的文档中的每个文档而得到的。未指定输出数组中元素的顺序。 $addToSet仅在$group阶段可用。 $addToSet具有以下语法： { $addToSet: } 有关表达式的更多信息，请参阅表达式。 行为 数组表达式 如果表达式的 value 是 array，则$addToSet将整个 array 作为单个元素追加。 文档表达 如果表达式的值是一个文档，则如果数组中的另一个文档与要添加的文档完全匹配，则MongoDB将确定该文档是重复的。也就是说，现有文档具有完全相同的字段和值，并且顺序完全相同 内存限制 从版本4.2.3（和4.0.14、3.6.17）开始， $addToSet内存限制也为100 MiB（100 1024 1024），即使db.collection.aggregate()使用allowDiskUse：true运行 。 有关更多信息，请参见聚集管道限制。 例子 考虑带有以下文档的sales集合： { \"_id\" : 1, \"item\" : \"abc\", \"price\" : 10, \"quantity\" : 2, \"date\" : ISODate(\"2014-01-01T08:00:00Z\") } { \"_id\" : 2, \"item\" : \"jkl\", \"price\" : 20, \"quantity\" : 1, \"date\" : ISODate(\"2014-02-03T09:00:00Z\") } { \"_id\" : 3, \"item\" : \"xyz\", \"price\" : 5, \"quantity\" : 5, \"date\" : ISODate(\"2014-02-03T09:05:00Z\") } { \"_id\" : 4, \"item\" : \"abc\", \"price\" : 10, \"quantity\" : 10, \"date\" : ISODate(\"2014-02-15T08:00:00Z\") } { \"_id\" : 5, \"item\" : \"xyz\", \"price\" : 5, \"quantity\" : 10, \"date\" : ISODate(\"2014-02-15T09:12:00Z\") } 按date字段的日期和年份对文档进行分组，以下操作使用$addToSet累加器计算为每个 group 销售的唯一商品的列表： db.sales.aggregate( [ { $group:{ _id: { day: { $dayOfYear: \"$date\"}, year: { $year: \"$date\" } }, itemsSold: { $addToSet: \"$item\" } } } ] ) 该操作返回以下结果： { \"_id\" : { \"day\" : 46, \"year\" : 2014 }, \"itemsSold\" : [ \"xyz\", \"abc\" ] } { \"_id\" : { \"day\" : 34, \"year\" : 2014 }, \"itemsSold\" : [ \"xyz\", \"jkl\" ] } { \"_id\" : { \"day\" : 1, \"year\" : 2014 }, \"itemsSold\" : [ \"abc\" ] } Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Aggregation-Pipeline-Operators/allElementsTrue-aggregation.html":{"url":"docs/Reference/Operators/Aggregation-Pipeline-Operators/allElementsTrue-aggregation.html","title":"$allElementsTrue (aggregation)","keywords":"","body":" $allElementsTrue (aggregation) 在本页面 定义 行为 例子 定义 $allElementsTrue 将数组评估为集合，如果 array 中没有元素为false，则返回true。否则，返回false。空 array 返回true。 $allElementsTrue具有以下语法： { $allElementsTrue: [ ] } 本身必须解析为 array，与表示参数列表的外部 array 分开。有关表达式的更多信息，请参阅表达式。 行为 如果集合包含嵌套的 array 元素，则$allElementsTrue不会降级到嵌套的 array 中，而是在 top-level 处计算 array。 除了false 布尔值之外，$allElementsTrue还将false计算为以下值：null，0和undefined值。 $allElementsTrue将所有其他值计算为true，包括非零数值和数组。 例子 结果 { $allElementsTrue: [ [ true, 1, \"someString\" ] ] } true { $allElementsTrue: [ [ [ false ] ] ] } true { $allElementsTrue: [ [ ] ] } true { $allElementsTrue: [ [ null, false, 0 ] ] } true 例子 考虑带有以下文档的survey集合： { \"_id\" : 1, \"responses\" : [ true ] } { \"_id\" : 2, \"responses\" : [ true, false ] } { \"_id\" : 3, \"responses\" : [ ] } { \"_id\" : 4, \"responses\" : [ 1, true, \"seven\" ] } { \"_id\" : 5, \"responses\" : [ 0 ] } { \"_id\" : 6, \"responses\" : [ [ ] ] } { \"_id\" : 7, \"responses\" : [ [ 0 ] ] } { \"_id\" : 8, \"responses\" : [ [ false ] ] } { \"_id\" : 9, \"responses\" : [ null ] } { \"_id\" : 10, \"responses\" : [ undefined ] } 以下操作使用$allElementsTrue operator 来确定responses array 是否仅包含求值为true的值： db.survey.aggregate( [ { $project: { responses: 1, isAllTrue: { $allElementsTrue: [ \"$responses\" ] }, _id: 0 } } ] ) 该操作返回以下结果： { \"responses\" : [ true ], \"isAllTrue\" : true } { \"responses\" : [ true, false ], \"isAllTrue\" : false } { \"responses\" : [ ], \"isAllTrue\" : true } { \"responses\" : [ 1, true, \"seven\" ], \"isAllTrue\" : true } { \"responses\" : [ 0 ], \"isAllTrue\" : false } { \"responses\" : [ [ ] ], \"isAllTrue\" : true } { \"responses\" : [ [ 0 ] ], \"isAllTrue\" : true } { \"responses\" : [ [ false ] ], \"isAllTrue\" : true } { \"responses\" : [ null ], \"isAllTrue\" : false } { \"responses\" : [ null ], \"isAllTrue\" : false } Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Aggregation-Pipeline-Operators/and-aggregation.html":{"url":"docs/Reference/Operators/Aggregation-Pipeline-Operators/and-aggregation.html","title":"$and (aggregation)","keywords":"","body":" $and (aggregation) 在本页面 定义 行为 例子 定义 $and 计算一个或多个表达式，如果所有表达式都为true，或者如果没有参数表达式调用，则返回true。否则，$and返回false。 $and 具有以下语法： { $and: [ , , ... ] } 有关表达式的更多信息，请参见 表达式。 行为 $and使用短路逻辑：遇到第一个false表达式后，运算将停止评估。 除了false布尔值，$and计算为false如下：null，0，和undefined 的值。在$and评估所有其它值true，包括非零数值和阵列。 例子 结果 { $and: [ 1, \"green\" ] } true { $and: [ ] } true { $and: [ [ null ], [ false ], [ 0 ] ] } true { $and: [ null, true ] } true { $and: [ 0, true ] } true 例子 inventory使用以下文档创建示例集合： db.inventory.insertMany([ { \"_id\" : 1, \"item\" : \"abc1\", description: \"product 1\", qty: 300 }, { \"_id\" : 2, \"item\" : \"abc2\", description: \"product 2\", qty: 200 }, { \"_id\" : 3, \"item\" : \"xyz1\", description: \"product 3\", qty: 250 }, { \"_id\" : 4, \"item\" : \"VWZ1\", description: \"product 4\", qty: 300 }, { \"_id\" : 5, \"item\" : \"VWZ2\", description: \"product 5\", qty: 180 } ]) 以下操作使用$and运算符确定是否qty大于100 并小于250： db.inventory.aggregate( [ { $project: { item: 1, qty: 1, result: { $and: [ { $gt: [ \"$qty\", 100 ] }, { $lt: [ \"$qty\", 250 ] } ] } } } ] ) 该操作返回以下结果： { \"_id\" : 1, \"item\" : \"abc1\", \"qty\" : 300, \"result\" : false } { \"_id\" : 2, \"item\" : \"abc2\", \"qty\" : 200, \"result\" : true } { \"_id\" : 3, \"item\" : \"xyz1\", \"qty\" : 250, \"result\" : false } { \"_id\" : 4, \"item\" : \"VWZ1\", \"qty\" : 300, \"result\" : false } { \"_id\" : 5, \"item\" : \"VWZ2\", \"qty\" : 180, \"result\" : true } Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Aggregation-Pipeline-Operators/anyElementTrue-aggregation.html":{"url":"docs/Reference/Operators/Aggregation-Pipeline-Operators/anyElementTrue-aggregation.html","title":"$anyElementTrue (aggregation)","keywords":"","body":" $anyElementTrue (aggregation) 在本页面 定义 行为 例子 定义 $anyElementTrue 将数组作为集合求值，true如果有则返回true，false否则返回。返回一个空数组false。 $anyElementTrue具有以下语法： { $anyElementTrue: [ ] } 本身必须解析为一个阵列，分离从表示参数列表中的外部阵列。有关表达式的更多信息，请参见表达式。 行为 如果集合包含嵌套数组元素，$anyElementTrue则不会降级到嵌套数组中，而是在顶级对数组进行求值。 除了false布尔值，$anyElementTrue计算为false如下：null，0，和undefined 的值。在$anyElementTrue评估所有其它值true，包括非零数值和阵列。 例子 结果 { $anyElementTrue: [ [ true, false ] ] } true { $anyElementTrue: [ [ [ false ] ] ] } true { $anyElementTrue: [ [ null, false, 0 ] ] } false { $anyElementTrue: [ [ ] ] } false 例子 创建一个示例集合，其名称survey包含以下文档： db.survey.insertMany([ { \"_id\" : 1, \"responses\" : [ true ] }, { \"_id\" : 2, \"responses\" : [ true, false ] }, { \"_id\" : 3, \"responses\" : [ ] }, { \"_id\" : 4, \"responses\" : [ 1, true, \"seven\" ] }, { \"_id\" : 5, \"responses\" : [ 0 ] }, { \"_id\" : 6, \"responses\" : [ [ ] ] }, { \"_id\" : 7, \"responses\" : [ [ 0 ] ] }, { \"_id\" : 8, \"responses\" : [ [ false ] ] }, { \"_id\" : 9, \"responses\" : [ null ] }, { \"_id\" : 10, \"responses\" : [ undefined ] } ]) 以下操作使用$anyElementTrue运算符来确定responses数组是否包含任何计算结果为true： db.survey.aggregate( [ { $project: { responses: 1, isAnyTrue: { $anyElementTrue: [ \"$responses\" ] }, _id: 0 } } ] ) 该操作返回以下结果： { \"responses\" : [ true ], \"isAnyTrue\" : true } { \"responses\" : [ true, false ], \"isAnyTrue\" : true } { \"responses\" : [ ], \"isAnyTrue\" : false } { \"responses\" : [ 1, true, \"seven\" ], \"isAnyTrue\" : true } { \"responses\" : [ 0 ], \"isAnyTrue\" : false } { \"responses\" : [ [ ] ], \"isAnyTrue\" : true } { \"responses\" : [ [ 0 ] ], \"isAnyTrue\" : true } { \"responses\" : [ [ false ] ], \"isAnyTrue\" : true } { \"responses\" : [ null ], \"isAnyTrue\" : false } { \"responses\" : [ undefined ], \"isAnyTrue\" : false } Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Aggregation-Pipeline-Operators/arrayElemAt-aggregation.html":{"url":"docs/Reference/Operators/Aggregation-Pipeline-Operators/arrayElemAt-aggregation.html","title":"$arrayElemAt (aggregation)","keywords":"","body":" $arrayElemAt (aggregation) 在本页面 定义 行为 例子 定义 $arrayElemAt 3.2版中的新功能。 返回指定数组索引处的元素。 $arrayElemAt 具有以下语法： { $anyElement: [ ] } 表达式可以是任何有效的表达式，只要它可以解析为数组。 表达式可以是任何有效表达式，只要它可以解析为整数。 如果为正，则从数组开始算起$arrayElemAt返回该idx位置的元素 。 如果为负，则从数组末尾算起$arrayElemAt返回该idx位置处的元素 。 如果idx超过了数组界限，$arrayElemAt则不返回任何结果。 有关表达式的更多信息，请参见 表达式。 行为 有关表达式的更多信息，请参见 表达式。 例子 结果 { $arrayElemAt: [ [ 1, 2, 3 ], 0 ] } 1 { $arrayElemAt: [ [ 1, 2, 3 ], -2 ] } 2 { $arrayElemAt: [ [ 1, 2, 3 ], 15 ] } 例子 名为的集合users包含以下文档： { \"_id\" : 1, \"name\" : \"dave123\", favorites: [ \"chocolate\", \"cake\", \"butter\", \"apples\" ] } { \"_id\" : 2, \"name\" : \"li\", favorites: [ \"apples\", \"pudding\", \"pie\" ] } { \"_id\" : 3, \"name\" : \"ahn\", favorites: [ \"pears\", \"pecans\", \"chocolate\", \"cherries\" ] } { \"_id\" : 4, \"name\" : \"ty\", favorites: [ \"ice cream\" ] } 下面的示例返回favorites数组中的第一个和最后一个元素 ： db.users.aggregate([ { $project: { name: 1, first: { $arrayElemAt: [ \"$favorites\", 0 ] }, last: { $arrayElemAt: [ \"$favorites\", -1 ] } } } ]) 该操作返回以下结果： { \"_id\" : 1, \"name\" : \"dave123\", \"first\" : \"chocolate\", \"last\" : \"apples\" } { \"_id\" : 2, \"name\" : \"li\", \"first\" : \"apples\", \"last\" : \"pie\" } { \"_id\" : 3, \"name\" : \"ahn\", \"first\" : \"pears\", \"last\" : \"cherries\" } { \"_id\" : 4, \"name\" : \"ty\", \"first\" : \"ice cream\", \"last\" : \"ice cream\" } Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Aggregation-Pipeline-Operators/arrayToObject-aggregation.html":{"url":"docs/Reference/Operators/Aggregation-Pipeline-Operators/arrayToObject-aggregation.html","title":"$arrayToObject (aggregation)","keywords":"","body":" $arrayToObject (aggregation) 在本页面 定义 行为 例子 定义 $arrayToObject 3.4.4版中的新功能。 将数组转换为单个文档；数组必须为： 一个由两个元素组成的数组，其中第一个元素是字段名称，第二个元素是字段值： [ [ \"item\", \"abc123\"], [ \"qty\", 25 ] ] -OR- 文件数组，包含两个字段，k并且v 其中： 该k字段包含字段名称。 该v字段包含该字段的值。 [ { \"k\": \"item\", \"v\": \"abc123\"}, { \"k\": \"qty\", \"v\": 25 } ] $arrayToObject具有以下语法： { $arrayToObject: } 可以是任何有效的表达解析为两个元件阵列或包含“k”和“V”域的文档阵列的阵列。 有关表达式的更多信息，请参见 表达式。 行为 如果字段名称在数组中重复， 从4.0.5开始，$arrayToObject使用该字段的最后一个值。对于4.0.0-4.0.4，使用的值取决于驱动程序。 从3.6.10开始，$arrayToObject使用该字段的最后一个值。对于3.6.0-3.6.9，使用的值取决于驱动程序。 从3.4.19开始，$arrayToObject使用该字段的最后一个值。对于3.4.0-3.4.19，使用的值取决于驱动程序。 例子 结果 { $arrayToObject: { $literal: [ { \"k\": \"item\", \"v\": \"abc123\"}, { \"k\": \"qty\", \"v\": 25 } ] } } { \"item\" : \"abc123\", \"qty\" : 25 } { $arrayToObject: { $literal: [ [ \"item\", \"abc123\"], [ \"qty\", 25 ] ] } } { \"item\" : \"abc123\", \"qty\" : 25 } { $arrayToObject: { $literal: [ { \"k\": \"item\", \"v\": \"123abc\"}, { \"k\": \"item\", \"v\": \"abc123\" } ] } } { \"item\" : \"abc123\" }从版本4.0.5+（3.6.10+和3.4.19+）开始，如果字段名称在数组中重复，则$arrayToObject 使用该字段的最后一个值。 例子 $arrayToObject 例子 考虑inventory包含以下文档的集合： { \"_id\" : 1, \"item\" : \"ABC1\", dimensions: [ { \"k\": \"l\", \"v\": 25} , { \"k\": \"w\", \"v\": 10 }, { \"k\": \"uom\", \"v\": \"cm\" } ] } { \"_id\" : 2, \"item\" : \"ABC2\", dimensions: [ [ \"l\", 50 ], [ \"w\", 25 ], [ \"uom\", \"cm\" ] ] } { \"_id\" : 3, \"item\" : \"ABC3\", dimensions: [ [ \"l\", 25 ], [ \"l\", \"cm\" ], [ \"l\", 50 ] ] } 以下聚合管道操作使用 $arrayToObject将该dimensions字段作为文档返回： db.inventory.aggregate( [ { $project: { item: 1, dimensions: { $arrayToObject: \"$dimensions\" } } } ] ) 该操作返回以下结果： { \"_id\" : 1, \"item\" : \"ABC1\", \"dimensions\" : { \"l\" : 25, \"w\" : 10, \"uom\" : \"cm\" } } { \"_id\" : 2, \"item\" : \"ABC2\", \"dimensions\" : { \"l\" : 50, \"w\" : 25, \"uom\" : \"cm\" } } { \"_id\" : 3, \"item\" : \"ABC3\", \"dimensions\" : { \"l\" : 50 } } 从版本4.0.5+（3.6.10+和3.4.19+）开始，如果字段名称在数组中重复，则$arrayToObject使用该字段的最后一个值。 $objectToArray+ $arrayToObject示例 考虑inventory包含以下文档的集合： { \"_id\" : 1, \"item\" : \"ABC1\", instock: { warehouse1: 2500, warehouse2: 500 } } { \"_id\" : 2, \"item\" : \"ABC2\", instock: { warehouse2: 500, warehouse3: 200} } 以下聚合管道操作将计算每个物料的总存货并将其添加到instock凭证中： db.inventory.aggregate( [ { $addFields: { instock: { $objectToArray: \"$instock\" } } }, { $addFields: { instock: { $concatArrays: [ \"$instock\", [ { \"k\": \"total\", \"v\": { $sum: \"$instock.v\" } } ] ] } } } , { $addFields: { instock: { $arrayToObject: \"$instock\" } } } ] ) 该操作返回以下内容： { \"_id\" : 1, \"item\" : \"ABC1\", \"instock\" : { \"warehouse1\" : 2500, \"warehouse2\" : 500, \"total\" : 3000 } } { \"_id\" : 2, \"item\" : \"ABC2\", \"instock\" : { \"warehouse2\" : 500, \"warehouse3\" : 200, \"total\" : 700 } } 也可以看看 $objectToArray Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Aggregation-Pipeline-Operators/asin-aggregation.html":{"url":"docs/Reference/Operators/Aggregation-Pipeline-Operators/asin-aggregation.html","title":"$asin (aggregation)","keywords":"","body":" $asin (aggregation) 在本页面 定义 行为 例子 定义 $asin 4.2版中的新功能。 返回值的反正弦（弧正弦）。 $asin具有以下语法： { $asin: } $asin接受任何有效的表达式，该表达式可解析为-1 和之间的数字1，例如。-1 $asin返回以弧度为单位的值。使用 $radiansToDegrees运算符将输出值从弧度转换为度。 默认情况下以形式$asin返回值double。 $asin也可以返回值作为 128-bit小数 ，只要该解析为一个128-bit的十进制值。 有关表达式的更多信息，请参见 表达式。 行为 如果参数解析为的值null或指向缺少的字段，则$asin返回null。如果参数解析为NaN，则$asin返回NaN。如果参数解析为包含[-1, 1]范围之外的值 ，则$asin会引发错误。 例子 结果 { $asin: NaN } NaN { $asin: null } null { $asin : Infinity}OR{ $asin : -Infinity } 引发类似于以下格式化输出的错误消息：\"errmsg\" : \"Failed to optimize pipeline :: caused by :: cannot apply $asin to -inf, value must in [-1,1]\" 例子 度数的反正弦值 该trigonometry集合包含一个文档，该文档存储直角三角形的三个边： { \"_id\" : ObjectId(\"5c50782193f833234ba90d85\"), \"side_a\" : NumberDecimal(\"3\"), \"side_b\" : NumberDecimal(\"4\"), \"hypotenuse\" : NumberDecimal(\"5\") } 以下聚合操作使用该 $asin表达式计算与之成反角，side_a并使用$addFields管道阶段将其添加到输入文档中 。 db.trigonometry.aggregate([ { $addFields : { \"angle_a\" : { $radiansToDegrees : { $asin : { $divide : [ \"$side_a\", \"$hypotenuse\" ] } } } } } ]) 该$radiansToDegrees表达式将返回的弧度值转换为$asin以度为单位的等效值。 该命令返回以下输出： { \"_id\" : ObjectId(\"5c50782193f833234ba90d85\"), \"side_a\" : NumberDecimal(\"3\"), \"side_b\" : NumberDecimal(\"4\"), \"hypotenuse\" : NumberDecimal(\"5\"), \"angle_a\" : NumberDecimal(\"36.86989764584402129685561255909341\") } 由于side_a和hypotenuse被存储为 128-bit小数，因此输出 $asin为128-bit小数。 弧度的反正弦 该trigonometry集合包含一个文档，该文档存储直角三角形的三个边： { \"_id\" : ObjectId(\"5c50782193f833234ba90d85\"), \"side_a\" : NumberDecimal(\"3\"), \"side_b\" : NumberDecimal(\"4\"), \"hypotenuse\" : NumberDecimal(\"5\") } 以下聚合操作使用该 $asin表达式来计算side_a与$addFields管道之间相邻的角度并将其添加到输入文档中 。 db.trigonometry.aggregate([ { $addFields : { \"angle_a\" : { $asin : { $divide : [ \"$side_a\", \"$hypotenuse\" ] } } } } ]) 该命令返回以下输出： { \"_id\" : ObjectId(\"5c50782193f833234ba90d85\"), \"side_a\" : NumberDecimal(\"3\"), \"side_b\" : NumberDecimal(\"4\"), \"hypotenuse\" : NumberDecimal(\"5\"), \"angle_a\" : NumberDecimal(\"0.6435011087932843868028092287173226\") } 由于side_a和hypotenuse被存储为 128-bit小数，因此输出 $asin为128-bit小数。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Aggregation-Pipeline-Operators/asinh-aggregation.html":{"url":"docs/Reference/Operators/Aggregation-Pipeline-Operators/asinh-aggregation.html","title":"$asinh (aggregation)","keywords":"","body":" $asinh (aggregation) 在本页面 定义 行为 例子 定义 $asinh 4.2版中的新功能。 返回值的反双曲正弦（双曲反正弦）。 $asinh 具有以下语法： { $asinh: } $asinh接受可解析为数字的任何有效表达式。 $asinh返回以弧度为单位的值。使用 $radiansToDegrees运算符将输出值从弧度转换为度。 默认情况下以形式$asinh返回值double。 $asinh也可以返回值作为 128-bit小数，只要该解析为一个128-bit的十进制值。 有关表达式的更多信息，请参见 表达式。 行为 null，NaN和+/- Infinity 如果参数解析为的值null或指向缺少的字段，则$asinh返回null。如果参数解析为NaN，则$asinh返回NaN。如果参数解析为负无穷大或正无穷大，则$asinh分别返回负无穷大或正无穷大。 例子 结果 { $asinh: NaN } NaN { $asinh: null } null { $asinh : Infinity} Infinity { $asinh : -Infinity } -Infinity 例子 度数的反双曲正弦值 该trigonometry集合包含一个文档，该文档沿x二维图形的轴存储值： { \"_id\" : ObjectId(\"5c50782193f833234ba90d85\"), \"x-coordinate\" : NumberDecimal(\"1\") } 以下聚合操作使用该 $asinh表达式计算的反双曲正弦值，x-coordinate并使用$addFields管道阶段将其添加到输入文档中。 db.trigonometry.aggregate([ { $addFields : { \"y-coordinate\" : { $radiansToDegrees : { $asinh : \"$x-coordinate\" } } } } ]) 该$radiansToDegrees表达式将返回的弧度值转换为$asinh以度为单位的等效值。 该命令返回以下输出： { \"_id\" : ObjectId(\"5c50782193f833234ba90d85\"), \"x-coordinate\" : NumberDecimal(\"1\"), \"y-coordinate\" : NumberDecimal(\"50.49898671052621144221476300417157\") } 由于x-coordinate存储为 128-bit十进制数，因此输出 $asinh为128-bit十进制数。 弧度的反双曲正弦值 该trigonometry集合包含一个文档，该文档沿x二维图形的轴存储值： { \"_id\" : ObjectId(\"5c50782193f833234ba90d85\"), \"x-coordinate\" : NumberDecimal(\"1\") } 以下聚合操作使用该 $asinh表达式计算的反双曲正弦值，x-coordinate并使用$addFields管道阶段将其添加到输入文档中。 db.trigonometry.aggregate([ { $addFields : { \"y-coordinate\" : { $asinh : \"$x-coordinate\" } } } ]) 该命令返回以下输出： { \"_id\" : ObjectId(\"5c50782193f833234ba90d85\"), \"x-coordinate\" : NumberDecimal(\"1\"), \"y-coordinate\" : NumberDecimal(\"1.818446459232066823483698963560709\") } 由于x-coordinate存储为 128-bit十进制数，因此输出 $asinh为128-bit十进制数。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Aggregation-Pipeline-Operators/atan-aggregation.html":{"url":"docs/Reference/Operators/Aggregation-Pipeline-Operators/atan-aggregation.html","title":"$atan (aggregation)","keywords":"","body":" $atan (aggregation) 在本页面 定义 行为 例子 定义 $atan 4.2版中的新功能。 返回值的反正切（弧正切）。 $atan 具有以下语法： { $atan: } $atan接受可解析为数字的任何有效表达式。 $atan返回以弧度为单位的值。使用 $radiansToDegrees运算符将输出值从弧度转换为度。 默认情况下以形式$atan返回值double。 $atan也可以返回值作为 128-bit小数 ，只要该解析为一个128-bit的十进制值。 有关表达式的更多信息，请参见 表达式。 行为 null和NaN 如果参数解析为的值null或指向缺少的字段，则$atan返回null。如果参数解析为NaN，则$tan返回NaN。 例子 结果 { $atan: NaN } NaN { $atan: null } null 例子 度数的反正切值 该trigonometry集合包含一个文档，该文档存储直角三角形的三个边： { \"_id\" : ObjectId(\"5c50782193f833234ba90d85\"), \"side_a\" : NumberDecimal(\"3\"), \"side_b\" : NumberDecimal(\"4\"), \"hypotenuse\" : NumberDecimal(\"5\") } 以下聚合操作使用该 $atan表达式来计算side_a与$addFields管道之间相邻的角度并将其添加到输入文档中 。 db.trigonometry.aggregate([ { $addFields : { \"angle_a\" : { $radiansToDegrees : { $atan : { $divide : [ \"$side_b\", \"$side_a\" ] } } } } } ]) 该$radiansToDegrees表达式将返回的弧度值转换为$atan以度为单位的等效值。 该命令返回以下输出： { \"_id\" : ObjectId(\"5c50782193f833234ba90d85\"), \"side_a\" : NumberDecimal(\"3\"), \"side_b\" : NumberDecimal(\"4\"), \"hypotenuse\" : NumberDecimal(\"5\"), \"angle_a\" : NumberDecimal(\"53.13010235415597870314438744090658\") } 由于side_b和side_a被存储为 128-bit小数，因此输出 $atan为128-bit小数。 弧度的反正切值 该trigonometry集合包含一个文档，该文档存储直角三角形的三个边： { \"_id\" : ObjectId(\"5c50782193f833234ba90d85\"), \"side_a\" : NumberDecimal(\"3\"), \"side_b\" : NumberDecimal(\"4\"), \"hypotenuse\" : NumberDecimal(\"5\") } 以下聚合操作使用该 $atan表达式来计算side_a与$addFields管道之间相邻的角度并将其添加到输入文档中 。 db.trigonometry.aggregate([ { $addFields : { \"angle_a\" : { $atan : { $divide : [ \"$side_b\", \"$side_a\" ] } } } } ]) 该命令返回以下输出： { \"_id\" : ObjectId(\"5c50782193f833234ba90d85\"), \"side_a\" : NumberDecimal(\"3\"), \"side_b\" : NumberDecimal(\"4\"), \"hypotenuse\" : NumberDecimal(\"5\"), \"angle_a\" : NumberDecimal(\"0.9272952180016122324285124629224287\") } 由于side_b和side_a被存储为 128-bit小数，因此输出 $atan为128-bit小数。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Aggregation-Pipeline-Operators/atan2-aggregation.html":{"url":"docs/Reference/Operators/Aggregation-Pipeline-Operators/atan2-aggregation.html","title":"$atan2 (aggregation)","keywords":"","body":" $atan2 (aggregation) 在本页面 定义 行为 例子 定义 $atan2 4.2版中的新功能。 返回y / x的反正切（弧形切线），其中y和x是分别传递给表达式的第一个和第二个值。 $atan2具有以下语法： { $atan2: [ , ] } $atan2接受可解析为数字的任何有效表达式。 $atan2返回以弧度为单位的值。使用 $radiansToDegrees运算符将输出值从弧度转换为度。 默认情况下以形式$atan2返回值double。 $atan2也可以返回值作为 128-bit小数，只要该解析为一个128-bit的十进制值。 有关表达式的更多信息，请参见 表达式。 行为 null和NaN 如果的第一个参数$atan2是null，则 $atan2返回null。如果的第一个参数 $atan2是NaN，则$atan2返回NaN。如果第一个参数解析为数字，第二个参数解析为NaN或null， $atan2则分别返回NaN或null。 例子 结果 { $atan2: [ NaN, ] }or{ $atan2: [ , NaN ] } NaN { $atan2: [ null, ] }or{ $atan2: [ , null ] } null 例子 度数的反正切值 该trigonometry集合包含一个文档，该文档存储直角三角形的三个边： { \"_id\" : ObjectId(\"5c50782193f833234ba90d85\"), \"side_a\" : NumberDecimal(\"3\"), \"side_b\" : NumberDecimal(\"4\"), \"hypotenuse\" : NumberDecimal(\"5\") } 以下聚合操作使用该 $atan2表达式来计算side_a与$addFields管道之间相邻的角度并将其添加到输入文档中 。 db.trigonometry.aggregate([ { $addFields : { \"angle_a\" : { $radiansToDegrees : { $atan2 : [ \"$side_b\", \"$side_a\" ] } } } } ]) $radiansToDegrees表达式将返回的弧度值转换为$atan2以度为单位的等效值。 该命令返回以下输出： { \"_id\" : ObjectId(\"5c50782193f833234ba90d85\"), \"side_a\" : NumberDecimal(\"3\"), \"side_b\" : NumberDecimal(\"4\"), \"hypotenuse\" : NumberDecimal(\"5\"), \"angle_a\" : NumberDecimal(\"53.13010235415597870314438744090658\") } 由于side_b和side_a被存储为 128-bit小数，因此输出 $atan2为128-bit小数。 弧度的反正切值 该trigonometry集合包含一个文档，该文档存储直角三角形的三个边： { \"_id\" : ObjectId(\"5c50782193f833234ba90d85\"), \"side_a\" : NumberDecimal(\"3\"), \"side_b\" : NumberDecimal(\"4\"), \"hypotenuse\" : NumberDecimal(\"5\") } 以下聚合操作使用该 $atan2表达式来计算side_a与$addFields管道之间相邻的角度并将其添加到输入文档中 。 db.trigonometry.aggregate([ { $addFields : { \"angle_a\" : { $atan2 : [ \"$side_b\", \"$side_a\" ] } } } ]) 该命令返回以下输出： { \"_id\" : ObjectId(\"5c50782193f833234ba90d85\"), \"side_a\" : NumberDecimal(\"3\"), \"side_b\" : NumberDecimal(\"4\"), \"hypotenuse\" : NumberDecimal(\"5\"), \"angle_a\" : NumberDecimal(\"0.9272952180016122324285124629224287\") } 由于side_b和side_a被存储为 128-bit小数，因此输出 $atan2为128-bit小数。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Aggregation-Pipeline-Operators/atanh-aggregation.html":{"url":"docs/Reference/Operators/Aggregation-Pipeline-Operators/atanh-aggregation.html","title":"$atanh (aggregation)","keywords":"","body":" $atanh (aggregation) 在本页面 定义 行为 例子 定义 $asinh 4.2版中的新功能。 返回值的反双曲正切（双曲反正切）。 $atanh具有以下语法： { $atanh: } $atanh接受任何有效的表达式，该表达式可解析为-1 和之间的数字1，例如。-1 $atanh返回以弧度为单位的值。使用 $radiansToDegrees运算符将输出值从弧度转换为度。 默认情况下以形式$atanh返回值double。 $atanh也可以返回值作为 128-bit小数 ，只要该解析为一个128-bit的十进制值。 有关表达式的更多信息，请参见 表达式。 行为 null，NaN和+/- Infinity 如果参数解析为的值null或指向缺少的字段，则$atanh返回null。如果参数解析为NaN，则$atanh返回NaN。如果参数解析为负无穷大或正无穷大， $atanh则会引发错误。如果参数解析为 +1或-1，则分别$atanh返回Infinity和 -Infinity。 例子 结果 { $atanh: NaN } NaN { $atanh: null } null { $atanh: 1 } Infinity { $atanh: -1} -Infinity { $atanh : Infinity}or{ $atanh : -Infinity } 引发类似于以下格式化输出的错误消息：\"errmsg\" : \"Failed to optimize pipeline :: caused by :: cannot apply $atanh to -inf, value must in (-inf,inf)\" 例子 度数的反双曲正切值 该trigonometry集合包含一个文档，该文档沿x二维图形的轴存储值： { \"_id\" : ObjectId(\"5c50782193f833234ba90d85\"), \"x-coordinate\" : NumberDecimal(\"0.5\") } 以下聚合操作使用该 $atanh表达式计算的反双曲正切值，x-coordinate并使用$addFields管道阶段将其添加到输入文档中。 db.trigonometry.aggregate([ { $addFields : { \"y-coordinate\" : { $radiansToDegrees : { $atanh : \"$x-coordinate\" } } } } ]) $radiansToDegrees表达式将返回的弧度值转换为$atanh以度为单位的等效值。 该命令返回以下输出： { \"_id\" : ObjectId(\"5c50782193f833234ba90d85\"), \"x-coordinate\" : NumberDecimal(\"0.5\"), \"y-coordinate\" : NumberDecimal(\"31.47292373094538001977241539068589\") } 由于x-coordinate存储为 128-bit十进制数，因此输出 $atanh为128-bit十进制数。 弧度的反双曲正切值 trigonometry集合包含一个文档，该文档沿x二维图形的轴存储值： { \"_id\" : ObjectId(\"5c50782193f833234ba90d85\"), \"x-coordinate\" : NumberDecimal(\"0.5\") } 以下聚合操作使用该 $atanh表达式计算的反双曲正切值，x-coordinate并使用$addFields管道阶段将其添加到输入文档中。 db.trigonometry.aggregate([ { $addFields : { \"y-coordinate\" : { $atanh : \"$x-coordinate\" } } } ]) 该命令返回以下输出： { \"_id\" : ObjectId(\"5c50782193f833234ba90d85\"), \"x-coordinate\" : NumberDecimal(\"0.5\"), \"y-coordinate\" : NumberDecimal(\"0.5493061443340548456976226184612628\") } 由于x-coordinate存储为 128-bit十进制数，因此输出 $asin为128-bit十进制数。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Aggregation-Pipeline-Operators/avg-aggregation.html":{"url":"docs/Reference/Operators/Aggregation-Pipeline-Operators/avg-aggregation.html","title":"$avg (aggregation)","keywords":"","body":" $avg (aggregation) 在本页面 定义 行为 例子 定义 $avg 返回数值的平均值。$avg忽略非数字值。 $avg在以下阶段可用： $group $project $addFields（从MongoDB 3.4开始可用） $set（从MongoDB 4.2开始可用） $replaceRoot（从MongoDB 3.4开始可用） $replaceWith（从MongoDB 4.2开始可用） $match包含$expr表达的阶段 在MongoDB 3.2和更早版本中，$avg仅在此$group阶段可用 。 在$group阶段中使用时，$avg具有以下语法，并返回通过将指定的表达式应用于按键共享同一组的一组文档中的每个文档而得到的所有数值的总平均值： { $avg: } 在其他受支持的阶段中使用时，$avg返回每个文档的指定表达式或表达式列表的平均值，并具有以下两种语法之一： $avg 有一个指定的表达式作为其操作数： { $avg: } $avg 有一个指定表达式的列表作为其操作数： { $avg: [ , ... ] } 有关表达式的更多信息，请参见 表达式。 行为 非数值或缺失值 $avg忽略非数字值，包括缺失值。如果平均值的所有操作数均为非数值，则由于未定义零值的平均值，因此$avg返回 null。 数组操作数 在此$group阶段，如果表达式解析为数组，$avg则将操作数视为非数值。 在其他受支持的阶段： 使用单个表达式作为其操作数，如果表达式解析为数组，则$avg遍历数组以对数组的数字元素进行操作以返回单个值。 使用表达式列表作为其操作数，如果任何表达式都解析为数组，$avg则不会遍历数组，而是将数组视为非数字值。 例子 在$group阶段上使用 考虑sales包含以下文档的集合： { \"_id\" : 1, \"item\" : \"abc\", \"price\" : 10, \"quantity\" : 2, \"date\" : ISODate(\"2014-01-01T08:00:00Z\") } { \"_id\" : 2, \"item\" : \"jkl\", \"price\" : 20, \"quantity\" : 1, \"date\" : ISODate(\"2014-02-03T09:00:00Z\") } { \"_id\" : 3, \"item\" : \"xyz\", \"price\" : 5, \"quantity\" : 5, \"date\" : ISODate(\"2014-02-03T09:05:00Z\") } { \"_id\" : 4, \"item\" : \"abc\", \"price\" : 10, \"quantity\" : 10, \"date\" : ISODate(\"2014-02-15T08:00:00Z\") } { \"_id\" : 5, \"item\" : \"xyz\", \"price\" : 5, \"quantity\" : 10, \"date\" : ISODate(\"2014-02-15T09:12:00Z\") } 按item字段对文档进行分组，以下操作使用$avg累加器计算每个分组的平均数量和平均数量。 db.sales.aggregate( [ { $group: { _id: \"$item\", avgAmount: { $avg: { $multiply: [ \"$price\", \"$quantity\" ] } }, avgQuantity: { $avg: \"$quantity\" } } } ] ) 该操作返回以下结果： { \"_id\" : \"xyz\", \"avgAmount\" : 37.5, \"avgQuantity\" : 7.5 } { \"_id\" : \"jkl\", \"avgAmount\" : 20, \"avgQuantity\" : 1 } { \"_id\" : \"abc\", \"avgAmount\" : 60, \"avgQuantity\" : 6 } 在$project阶段上使用 集合students包含以下文档： { \"_id\": 1, \"quizzes\": [ 10, 6, 7 ], \"labs\": [ 5, 8 ], \"final\": 80, \"midterm\": 75 } { \"_id\": 2, \"quizzes\": [ 9, 10 ], \"labs\": [ 8, 8 ], \"final\": 95, \"midterm\": 80 } { \"_id\": 3, \"quizzes\": [ 4, 5, 5 ], \"labs\": [ 6, 5 ], \"final\": 78, \"midterm\": 70 } 以下示例$avg在 $project阶段中使用来计算平均测验分数，平均实验室分数以及期末和期中考试的平均值： db.students.aggregate([ { $project: { quizAvg: { $avg: \"$quizzes\"}, labAvg: { $avg: \"$labs\" }, examAvg: { $avg: [ \"$final\", \"$midterm\" ] } } } ]) 该操作产生以下文档： { \"_id\" : 1, \"quizAvg\" : 7.666666666666667, \"labAvg\" : 6.5, \"examAvg\" : 77.5 } { \"_id\" : 2, \"quizAvg\" : 9.5, \"labAvg\" : 8, \"examAvg\" : 87.5 } { \"_id\" : 3, \"quizAvg\" : 4.666666666666667, \"labAvg\" : 5.5, \"examAvg\" : 74 } 在其他受支持的阶段： 使用单个表达式作为其操作数，如果表达式解析为数组，则$avg遍历数组以对数组的数字元素进行操作以返回单个值。 使用表达式列表作为其操作数，如果任何表达式都解析为数组，$avg则不会遍历数组，而是将数组视为非数字值。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Aggregation-Pipeline-Operators/ceil-aggregation.html":{"url":"docs/Reference/Operators/Aggregation-Pipeline-Operators/ceil-aggregation.html","title":"$ceil (aggregation)","keywords":"","body":" $ceil (aggregation) 在本页面 定义 行为 例子 定义 $ceil 3.2版中的新功能。 返回大于或等于指定数字的最小整数。 $ceil具有以下语法： { $ceil: } 表达式可以是任何有效的表达，因为它解析为数字。有关表达式的更多信息，请参阅表达式。 行为 如果参数解析为的值或引用缺少的字段，则$ceil返回null。如果参数解析为NaN，则$ceil返回NaN。 例子 结果 { $ceil: 1 } 1 { $ceil: 7.80 } 8 { $ceil: -2.8 } -2 例子 名为samples的集合包含以下文档： { _id: 1, value: 9.25 } { _id: 2, value: 8.73 } { _id: 3, value: 4.32 } { _id: 4, value: -5.34 } 以下事例返回原始值和上限值： db.samples.aggregate([ { $project: { value: 1, ceilingValue: { $ceil: \"$value\" } } } ]) 该操作返回以下结果： { \"_id\" : 1, \"value\" : 9.25, \"ceilingValue\" : 10 } { \"_id\" : 2, \"value\" : 8.73, \"ceilingValue\" : 9 } { \"_id\" : 3, \"value\" : 4.32, \"ceilingValue\" : 5 } { \"_id\" : 4, \"value\" : -5.34, \"ceilingValue\" : -5 } Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Aggregation-Pipeline-Operators/cmp-aggregation.html":{"url":"docs/Reference/Operators/Aggregation-Pipeline-Operators/cmp-aggregation.html","title":"$cmp (aggregation)","keywords":"","body":" $cmp (aggregation) 在本页面 定义 例子 定义 $cmp 比较两个值并返回： -1 如果第一个值小于第二个值。 1 如果第一个值大于第二个值。 0 如果两个值相等。 在$cmp使用两个值和类型进行比较， 指定比较BSON为了 用于不同类型的值。 $cmp具有以下语法： { $cmp: [ , ] } 有关表达式的更多信息，请参见表达式。 例子 考虑包含inventory以下文档的集合： { \"_id\" : 1, \"item\" : \"abc1\", description: \"product 1\", qty: 300 } { \"_id\" : 2, \"item\" : \"abc2\", description: \"product 2\", qty: 200 } { \"_id\" : 3, \"item\" : \"xyz1\", description: \"product 3\", qty: 250 } { \"_id\" : 4, \"item\" : \"VWZ1\", description: \"product 4\", qty: 300 } { \"_id\" : 5, \"item\" : \"VWZ2\", description: \"product 5\", qty: 180 } 以下操作使用$cmp运算符将qty值与进行比较250： db.inventory.aggregate( [ { $project: { item: 1, qty: 1, cmpTo250: { $cmp: [ \"$qty\", 250 ] }, _id: 0 } } ] ) 该操作返回以下结果： { \"item\" : \"abc1\", \"qty\" : 300, \"cmpTo250\" : 1 } { \"item\" : \"abc2\", \"qty\" : 200, \"cmpTo250\" : -1 } { \"item\" : \"xyz1\", \"qty\" : 250, \"cmpTo250\" : 0 } { \"item\" : \"VWZ1\", \"qty\" : 300, \"cmpTo250\" : 1 } { \"item\" : \"VWZ2\", \"qty\" : 180, \"cmpTo250\" : -1 } Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Aggregation-Pipeline-Operators/concat-aggregation.html":{"url":"docs/Reference/Operators/Aggregation-Pipeline-Operators/concat-aggregation.html","title":"$concat (aggregation)","keywords":"","body":" $concat (aggregation) 在本页面 定义 例子 定义 $concat 连接字符串并返回连接的字符串。 $concat具有以下语法： { $concat: [ , , ... ] } 参数可以解析为字符串，可以是任何有效的表达式。有关表达式的更多信息，请参见 表达式。 如果参数解析为的值null或指向缺少的字段，则$concat返回null。 例子 考虑inventory包含以下文档的集合： { \"_id\" : 1, \"item\" : \"ABC1\", quarter: \"13Q1\", \"description\" : \"product 1\" } { \"_id\" : 2, \"item\" : \"ABC2\", quarter: \"13Q4\", \"description\" : \"product 2\" } { \"_id\" : 3, \"item\" : \"XYZ1\", quarter: \"14Q2\", \"description\" : null } 以下操作使用$concat运算符将item字段和description带有“-”定界符的字段连接起来。 db.inventory.aggregate( [ { $project: { itemDescription: { $concat: [ \"$item\", \" - \", \"$description\" ] } } } ] ) 该操作返回以下结果： { \"_id\" : 1, \"itemDescription\" : \"ABC1 - product 1\" } { \"_id\" : 2, \"itemDescription\" : \"ABC2 - product 2\" } { \"_id\" : 3, \"itemDescription\" : null } Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Aggregation-Pipeline-Operators/concatArrays-aggregation.html":{"url":"docs/Reference/Operators/Aggregation-Pipeline-Operators/concatArrays-aggregation.html","title":"$concatArrays (aggregation)","keywords":"","body":" $concatArrays (aggregation) 在本页面 定义 行为 例子 定义 $concatArrays 3.2版中的新功能。 连接数组以返回连接的数组。 $concatArrays具有以下语法： { $concatArrays: [ , , ... ] } 该表达式可以是任何有效的表达式，只要它们解析为一个数组。有关表达式的更多信息，请参见表达式。 如果有任何参数解析为null或指向缺少的字段，则$concatArrays返回null。 行为 例子 结果 { $concatArrays: [ [ \"hello\", \" \"], [ \"world\" ] ] } [ \"hello\", \" \", \"world\" ] { $concatArrays: [ [ \"hello\", \" \"], [ [ \"world\" ], \"again\"] ] } [ \"hello\", \" \", [ \"world\" ], \"again\" ] 例子 名为的集合warehouses包含以下文档： { \"_id\" : 1, instock: [ \"chocolate\" ], ordered: [ \"butter\", \"apples\" ] } { \"_id\" : 2, instock: [ \"apples\", \"pudding\", \"pie\" ] } { \"_id\" : 3, instock: [ \"pears\", \"pecans\"], ordered: [ \"cherries\" ] } { \"_id\" : 4, instock: [ \"ice cream\" ], ordered: [ ] } 以下示例将instock和ordered 数组串联在一起： db.warehouses.aggregate([ { $project: { items: { $concatArrays: [ \"$instock\", \"$ordered\" ] } } } ]) { \"_id\" : 1, \"items\" : [ \"chocolate\", \"butter\", \"apples\" ] } { \"_id\" : 2, \"items\" : null } { \"_id\" : 3, \"items\" : [ \"pears\", \"pecans\", \"cherries\" ] } { \"_id\" : 4, \"items\" : [ \"ice cream\" ] } 也可以看看 $push Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Aggregation-Pipeline-Operators/cond-aggregation.html":{"url":"docs/Reference/Operators/Aggregation-Pipeline-Operators/cond-aggregation.html","title":"$cond (aggregation)","keywords":"","body":" $cond (aggregation) 在本页面 定义 例子 定义 $cond 计算一个布尔表达式以返回两个指定的返回表达式之一。 该$cond表达式具有以下两种语法之一： { $cond: { if: , then: , else: } } or { $cond: [ , , ] } $cond要求任何（if-then-else）一种语法的所有三个参数。 如果将计算结果为true，则 $cond计算并返回表达式的值 。否则，$cond求值并返回表达式的值。 参数可以是任何有效的表达式。有关表达式的更多信息，请参见 表达式。 也可以看看 $switch 例子 以下示例将inventory集合与以下文档一起使用： { \"_id\" : 1, \"item\" : \"abc1\", qty: 300 } { \"_id\" : 2, \"item\" : \"abc2\", qty: 200 } { \"_id\" : 3, \"item\" : \"xyz1\", qty: 250 } 下面的聚合操作使用$cond表达式，如果qty值大于或等于250，将折扣值设置为30，如果qty值小于250，则设置为20: db.inventory.aggregate( [ { $project: { item: 1, discount: { $cond: { if: { $gte: [ \"$qty\", 250 ] }, then: 30, else: 20 } } } } ] ) 该操作返回以下结果： { \"_id\" : 1, \"item\" : \"abc1\", \"discount\" : 30 } { \"_id\" : 2, \"item\" : \"abc2\", \"discount\" : 20 } { \"_id\" : 3, \"item\" : \"xyz1\", \"discount\" : 30 } 以下操作使用$cond表达式的数组语法， 并返回相同的结果： db.inventory.aggregate( [ { $project: { item: 1, discount: { $cond: [ { $gte: [ \"$qty\", 250 ] }, 30, 20 ] } } } ] ) Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Aggregation-Pipeline-Operators/convert-aggregation.html":{"url":"docs/Reference/Operators/Aggregation-Pipeline-Operators/convert-aggregation.html","title":"$convert (aggregation)","keywords":"","body":" $convert (aggregation) 在本页面 定义 行为 例子 定义 $convert 版本4.0中的新功能。 将值转换为指定的类型。 $convert具有以下语法： { $convert: { input: , to: , onError: , // Optional. onNull: // Optional. } } 在$convert需要具有以下字段的文档： 字段 描述 input 参数可以是任何有效的表达式。有关表达式的更多信息，请参见表达式。 to 该参数可以是任何可解析为以下数字或字符串标识符之一的有效表达式，见下表 onError 可选的。在转换过程中遇到错误（包括不支持的类型转换）时返回的值。参数可以是任何有效的表达式。如果未指定，则操作在遇到错误时将引发错误并停止。 onNull 可选的。如果input为null或缺失，则返回的值。参数可以是任何有效的表达式。如果未指定，$convert则如果inputnull为null或缺少，则返回null 。 字符串标识符 数值标识符 笔记 “double” 1 有关转换为double的更多信息，请参见 转换为Double。 “string” 2 有关转换为字符串的更多信息，请参见 转换为字符串。 “objectId” 7 有关转换为objectId的更多信息，请参见 转换为ObjectId。 “bool” 8 有关转换为布尔值的更多信息，请参见 转换为布尔值。 “date” 9 有关转换为日期的更多信息，请参见 转换为日期。 “int” 16 有关转换为整数的更多信息，请参见 转换为整数。 “long” 18 有关转换为long的更多信息，请参见 转换为long。 “decimal” 19 有关转换为十进制的更多信息，请参见 转换为十进制。 除$convert之外，当默认的“ onError”和“ onNull”行为可以接受时，MongoDB还提供以下聚合运算符作为速记： $toBool $toDate $toDecimal $toDouble $toInt $toLong $toObjectId $toString 行为 转换为布尔值 下表列出了可以转换为布尔值的输入类型： 输入类型 行为 Boolean 无操作，返回布尔值。 Double 如果不为零，则返回true。如果为零，则返回false。 Decimal 如果不为零，则返回true。如果为零，则返回false。 Integer 如果不为零，则返回true。如果为零，则返回false。 Long 如果不为零，则返回true。如果为零，则返回false。 ObjectId 返回true。 String 返回true。 Date 返回true。 下表列出了一些转换为布尔值的示例： 例子 结果 { input: true, to: \"bool\"} true { input: false, to: \"bool\" } false { input: 1.99999, to: \"bool\" } true { input: NumberDecimal(\"5\"), to: \"bool\"} true { input: NumberDecimal(\"0\"), to: \"bool\"} false { input: 100, to: \"bool\" } true { input: ISODate(\"2018-03-26T04:38:28.044Z\"), to: \"bool\" } true { input: \"hello\", to: \"bool\" } true { input: \"false\", to: \"bool\" } true { input: \"\", to: \"bool\" } true { input: null, to: \"bool\" } Null 也可以看看 $toBool 转换为整数 下表列出了可以转换为整数的输入类型： 输入类型 行为 Boolean 返回0的 false。返回1的true。 Double 返回截断值。截断后的double值必须在整数的最大值和最小值之内。您不能转换其截断值小于最小整数值或大于最大整数值的double值。 Decimal 返回截断值。截断的十进制值必须在整数的最大值和最小值之内。您不能转换截断值小于最小整数值或大于最大整数值的十进制值。 Integer 无操作，返回整数值。 Long 以整数形式返回long值。long值必须落在整数的最小值和最大值之间。您不能转换小于最小整数值或大于最大整数值的长值。 String 以整数形式返回字符串的数值。字符串值必须是base 10的整数（例如 \"-5\"，\"123456\"）并落在整数的最小值和最大值之内。不能转换浮点数、十进制数或非base10数字的字符串值（例如\"-5.0\"，\"0x6400\"）或低于整数的最小和最大值的值。 下表列出了一些转换为整数的示例： 例子 结果 { input: true, to: \"int\"} 1 { input: false, to: \"int\" } 0 { input: 1.99999, to: \"int\" } 1 { input: NumberDecimal(\"5.5000\"), to: \"int\"} 5 { input: NumberDecimal(\"9223372036000.000\"), to: \"int\"} Error { input: NumberDecimal(\"9223372036000.000\"), to: \"int\", onError: \"Could not convert to type integer.\" } “Could not convert to type integer.” { input: NumberLong(\"5000\"), to: \"int\"} 5000 { input: NumberLong(\"922337203600\"), to: \"int\"} Error { input: \"-2\", to: \"int\" } -2 { input: \"2.5\", to: \"int\" } Error { input: null, to: \"int\" } null 也可以看看 $toInt操作符。 转换为十进制 下表列出了可以转换为十进制的输入类型： 输入类型 行为 Boolean false返回NumberDecimal(\"0\")true返回NumberDecimal(\"1\") Double 返回双精度值作为十进制数。 Decimal 无操作，返回小数。 Integer 以小数形式返回int值。 Long 返回long值（十进制）。 String 以十进制形式返回字符串的数值。字符串值必须是base 10数字值（例如 \"-5.5\"，\"123456\"）。您不能转换非base10数字的字符串值 （例如\"0x6400\"） Date 返回自与日期值相对应的纪元以来的毫秒数。 下表列出了一些转换为十进制的示例： 例子 结果 { input: true, to: \"decimal\"} NumberDecimal(“1”) { input: false, to: \"decimal\" } NumberDecimal(“0”) { input: 2.5, to: \"decimal\" } NumberDecimal(“2.50000000000000”) { input: NumberInt(5), to: \"decimal\"} NumberDecimal(“5”) { input: NumberLong(10000), to: \"decimal\"} NumberDecimal(“10000”) { input: \"-5.5\", to: \"decimal\" } NumberDecimal(“-5.5”) { input: ISODate(\"2018-03-27T05:04:47.890Z\"), to: \"decimal\" } NumberDecimal(“1522127087890”) 也可以看看 $toDecimal 转换为Double 下表列出了可以转换为双精度型的输入类型： 输入类型 行为 Boolean false返回的NumberLong（0）true返回的NumberLong（1） Double 无操作，返回双精度型。 Decimal 以双精度值返回十进制值。小数值必须在双精度的最小值和最大值之内。不能转换一个小于最小双精度值或大于最大双精度值的十进制值。 Integer 以双精度值返回int值。 Long 将long值作为双精度值返回。 String 以双精度值形式返回字符串的数值。字符串值必须是一个以10为基的数值(例如:\"-5.5\"， \"123456\")，并落在双精度的最小值和最大值之内。不能转换非base10数字的字符串值。“0x6400”)或低于双精度的最小值和最大值的值。 Date 返回自纪元以来对应于日期值的毫秒数。 下表列出了一些转换为Double的示例： 例子 结果 { input: true, to: \"double\"} 1 { input: false, to: \"double\" } 0 { input: 2.5, to: \"double\" } 2.5 { input: NumberInt(5), to: \"double\"} 5 { input: NumberLong(10000), to: \"double\"} 10000 { input: \"-5.5\", to: \"double\" } -5.5 { input: \"5e10\", to: \"double\" } 50000000000 { input: \"5e550\", to: \"double\", onError: \"Could not convert to type double.\" } “Could not convert to type double.” { input: ISODate(\"2018-03-27T05:04:47.890Z\"), to: \"double\" } 1522127087890 也可以看看 $toDouble 转换为Long 下表列出了可以转换为long的输入类型： 输入类型 行为 Boolean false返回0true返回1 Double 返回截断值。截断后的double值必须长时间处于最小值和最大值之间。不能转换其截断值小于最小长整型值或大于最大长整型值的双精度值。 Decimal 返回截断值。截断的十进制值必须在Long的最大值和最小值之间。不能转换截断值小于最小长值或大于最大长值的十进制值。 Integer 以long形式返回int值。 Long 无操作。返回Long值。 String 返回字符串的数值。字符串值必须是base10长度的(例如。“-5”，“123456”)，并落在Long最大值和最小值之内。不能转换浮点数、十进制数或非base10数字的字符串值。(例如 “-5.0”、“0x6400”)或处于Long最小和最大值之外的值。 Date 将日期转换为纪元以来的毫秒数。 下表列出了一些到长示例的转换： 例子 结果 { input: true, to: \"long\" } NumberLong(“1”) { input: false, to: \"long\" } NumberLong(“0”) { input: 1.99999, to: \"long\" } NumberLong(“1”) { input: NumberDecimal(\"5.5000\"), to: \"long\" } NumberLong(“5”) { input: NumberDecimal(\"9223372036854775808.0\"), to: \"long\" } Error { input: NumberDecimal(\"9223372036854775808.000\"), to: \"long\", onError: \"Could not convert to type long.\" } “Could not convert to type long.” { input: NumberInt(8), to: \"long\" } NumberLong(8) { input: ISODate(\"2018-03-26T04:38:28.044Z\"), to: \"long\" } NumberLong(“1522039108044”) { input: \"-2\", to: \"long\" } NumberLong(“-2”) { input: \"2.5\", to: \"long\" } Error { input: null, to: \"long\" } null 也可以看看 $toLong 转换为日期 下表列出了可以转换为日期的输入类型： 输入类型 行为 Double 返回一个日期，该日期对应于被截断的双精度值所表示的毫秒数。正值对应自1970年1月1日以来的毫秒数。负数对应于1970年1月1日之前的毫秒数。 Decimal 返回一个日期，该日期对应于被截断的十进制值所表示的毫秒数。正值对应自1970年1月1日以来的毫秒数。负数对应于1970年1月1日之前的毫秒数。 Long 返回一个日期，该日期对应于Long值所表示的毫秒数。正值对应自1970年1月1日以来的毫秒数。负数对应于1970年1月1日之前的毫秒数。 String 返回与日期字符串对应的日期。字符串必须是一个有效的日期字符串，例如:1. “2018-03-03”2. “2018-03-03T12:00:00Z”3. “2018-03-03T12:00:00+0500” ObjectId 返回与ObjectId的时间戳相对应的日期。 下表列出了一些转换日期的示例： 例子 结果 { input: 120000000000.5, to: \"date\"} ISODate(“1973-10-20T21:20:00Z”) { input: NumberDecimal(\"1253372036000.50\"), to: \"date\"} ISODate(“2009-09-19T14:53:56Z”) { input: NumberLong(\"1100000000000\"), to: \"date\"} ISODate(“2004-11-09T11:33:20Z”) { input: NumberLong(\"-1100000000000\"), to: \"date\"} ISODate(“1935-02-22T12:26:40Z”) { input: ObjectId(\"5ab9c3da31c2ab715d421285\"), to: \"date\" } ISODate(“2018-03-27T04:08:58Z”) { input: \"2018-03-03\", to: \"date\" } ISODate(“2018-03-03T00:00:00Z”) { input: \"2018-03-20 11:00:06 +0500\", to: \"date\" } ISODate(“2018-03-20T06:00:06Z”) { input: \"Friday\", to: \"date\" } Error { input: \"Friday\", to: \"date\", onError: \"Could not convert to type date.\" } “Could not convert to type date.” 也可以看看 $toDate操作符， $dateFromString 转换成的ObjectId 下表列出了可以转换为ObjectId的输入类型： 输入类型 行为 String 返回长度为24的十六进制字符串的ObjectId。不能转换长度为24的十六进制字符串以外的字符串值。 下表列出了一些转换日期的示例： 例子 结果 { input: \"5ab9cbfa31c2ab715d42129e\", to: \"objectId\"} ObjectId(“5ab9cbfa31c2ab715d42129e”) { input: \"5ab9cbfa31c2ab715d42129\", to: \"objectId\"} Error { input: \"5ab9cbfa31c2ab715d42129\", to: \"objectId\", onError: \"Could not convert to type ObjectId.\" } “Could not convert to type ObjectId.” 也可以看看 $toObjectId操作符。 转换为字符串 下表列出了可以转换为字符串的输入类型： 输入类型 行为 Boolean 以字符串形式返回布尔值。 Double 以字符串形式返回双精度值。 Decimal 以字符串形式返回十进制值。 Integer 以字符串的形式返回整数值。 Long 以字符串形式返回长值。 ObjectId 以十六进制字符串的形式返回ObjectId值。 String 无操作。返回字符串值。 Date 以字符串形式返回日期。 下表列出了一些转换为字符串的示例： 例子 结果 { input: true, to: \"string\" } “true” { input: false, to: \"string\" } “false” { input: 2.5, to: \"string\"} “2.5” { input: NumberInt(2), to: \"string\"} “2” { input: NumberLong(1000), to: \"string\"} “1000” { input: ObjectId(\"5ab9c3da31c2ab715d421285\"), to: \"string\" } “5ab9c3da31c2ab715d421285” { input: ISODate(\"2018-03-27T16:58:51.538Z\"), to: \"string\" } { input: ISODate(\"2018-03-27T16:58:51.538Z\"), to: \"string\" }“2018-03-27T16:58:51.538Z” 也可以看看 $toString操作符。 $dateToString 例子 orders使用以下文档创建一个集合： db.orders.insert( [ { _id: 1, item: \"apple\", qty: 5, price: 10 }, { _id: 2, item: \"pie\", qty: 10, price: NumberDecimal(\"20.0\") }, { _id: 3, item: \"ice cream\", qty: 2, price: \"4.99\" }, { _id: 4, item: \"almonds\" }, { _id: 5, item: \"bananas\", qty: 5000000000, price: NumberDecimal(\"1.25\") } ] ) 集合上的以下汇总操作orders会将转换price为小数： // 定义使用转换后的价格和数量值添加convertedPrice和convertedQty字段的阶段 // 如果没有price或qty值，则返回十进制值或整数值 // 如果不能转换价格或数量值，将返回一个字符串 priceQtyConversionStage = { $addFields: { convertedPrice: { $convert: { input: \"$price\", to: \"decimal\", onError: \"Error\", onNull: NumberDecimal(\"0\") } }, convertedQty: { $convert: { input: \"$qty\", to: \"int\", onError:{$concat:[\"Could not convert \", {$toString:\"$qty\"}, \" to type integer.\"]}, onNull: NumberInt(\"0\") } }, } }; totalPriceCalculationStage = { $project: { totalPrice: { $switch: { branches: [ { case: { $eq: [ { $type: \"$convertedPrice\" }, \"string\" ] }, then: \"NaN\" }, { case: { $eq: [ { $type: \"$convertedQty\" }, \"string\" ] }, then: \"NaN\" }, ], default: { $multiply: [ \"$convertedPrice\", \"$convertedQty\" ] } } } } }; db.orders.aggregate( [ priceQtyConversionStage, totalPriceCalculationStage ]) 该操作返回以下文档： { \"_id\" : 1, \"totalPrice\" : NumberDecimal(\"50.0000000000000\") } { \"_id\" : 2, \"totalPrice\" : NumberDecimal(\"200.0\") } { \"_id\" : 3, \"totalPrice\" : NumberDecimal(\"9.98\") } { \"_id\" : 4, \"totalPrice\" : NumberDecimal(\"0\") } { \"_id\" : 5, \"totalPrice\" : \"NaN\" } Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Aggregation-Pipeline-Operators/cos-aggregation.html":{"url":"docs/Reference/Operators/Aggregation-Pipeline-Operators/cos-aggregation.html","title":"$cos (aggregation)","keywords":"","body":" $cos (aggregation) 在本页面 定义 行为 例子 定义 $cos 4.2版中的新功能。 返回以弧度为单位的值的余弦值。 $cos 具有以下语法： { $cos: } $cos接受可解析为数字的任何有效表达式。如果表达式返回以度为单位的值，请使用$degreesToRadians运算符将结果转换为弧度。 默认情况下以形式$cos返回值是double。 $cos$cos还可以以128-bit小数的形式返回值，只要解析为一个128-bit的十进制值。 有关表达式的更多信息，请参见 表达式。 行为 null，NaN和+/- Infinity 如果参数解析的值为null或指向缺少的字段，则$cos返回null。如果参数解析为NaN，则$cos返回NaN。如果参数解析为负无穷大或正无穷大， $cos则会引发错误。 例子 结果 { $cos: NaN } NaN { $cos: null } null { $cos : Infinity}or{ $cos : -Infinity } 引发类似于以下格式化输出的错误消息：\"errmsg\" : \"Failed to optimize pipeline :: caused by :: cannot apply $cos to -inf, value must in (-inf,inf)\" 例子 度数的余弦值 该trigonometry集合包含一个文档，该文档存储斜边和直角三角形中的一个角度： { \"_id\" : ObjectId(\"5c50782193f833234ba90d85\"), \"angle_a\" : NumberDecimal(\"53.13010235415597870314438744090659\"), \"hypotenuse\" : NumberDecimal(\"5\") } 以下聚合操作使用该 $cos表达式来计算相邻的边，angle_a并使用$addFields管道阶段将其添加到输入文档中 。 db.trigonometry.aggregate([ { $addFields : { \"side_a\" : { $multiply : [ { $cos : {$degreesToRadians : \"$angle_a\"} }, \"$hypotenuse\" ] } } } ]) $degreesToRadians表达式将的度数值转换为angle_a以弧度为单位的等效值。 该操作返回以下结果： { \"_id\" : ObjectId(\"5c50782193f833234ba90d85\"), \"angle_a\" : NumberDecimal(\"53.13010235415597870314438744090659\"), \"side_a\" : NumberDecimal(\"2.999999999999999999999999999999999\"), \"hypotenuse\" : NumberDecimal(\"5\"), } 由于angle_a和hypotenuse被存储为 128-bit小数，因此输出 $cos为128-bit小数。 弧度中的正弦值 该trigonometry集合包含一个文档，该文档存储斜边和直角三角形中的一个角度： { \"_id\" : ObjectId(\"5c50782193f833234ba90d85\"), \"angle_a\" : NumberDecimal(\"0.9272952180016122324285124629224288\"), \"hypotenuse\" : NumberDecimal(\"5\") } 以下聚合操作使用该 $cos表达式来计算相邻的边，angle_a并使用$addFields管道阶段将其添加到输入文档中 。 db.trigonometry.aggregate([ { $addFields : { \"side_b\" : { $multiply : [ { $cos : \"$angle_a\" }, \"$hypotenuse\" ] } } } ]) 该命令返回以下输出： { \"_id\" : ObjectId(\"5c50782193f833234ba90d85\"), \"angle_a\" : NumberDecimal(\"0.9272952180016122324285124629224288\"), \"side_b\" : NumberDecimal(\"3.000000000000000000000000000000000\"), \"hypotenuse\" : NumberDecimal(\"5\"), } 由于angle_a和hypotenuse被存储为 128-bit小数，因此输出 $cos为128-bit小数。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Aggregation-Pipeline-Operators/dateFromParts-aggregation.html":{"url":"docs/Reference/Operators/Aggregation-Pipeline-Operators/dateFromParts-aggregation.html","title":"$dateFromParts (aggregation)","keywords":"","body":" $dateFromParts (aggregation) 在本页面 定义 行为 例子 定义 $dateFromParts 3.6版的新功能。 给定日期的组成属性，构造并返回Date对象。 $dateFromParts表达式具有以下语法： { $dateFromParts : { 'year': , 'month': , 'day': , 'hour': , 'minute': , 'second': , 'millisecond': , 'timezone': } } 您还可以 使用以下语法以ISO周日期格式指定组成日期字段 ： { $dateFromParts : { 'isoWeekYear': , 'isoWeek': , 'isoDayOfWeek': , 'hour': , 'minute': , 'second': , 'millisecond': , 'timezone': } } 在$dateFromParts需要具有以下字段的文档： 重要 构造$dateFromParts输入文档时，不能将日历日期字段和ISO周日期字段组合使用。 字段 必选/可选 描述 year 如果不使用isoWeekYear，则为必需的 公历年。可以是任何计算结果为数字的表达式。值范围：0-9999 isoWeekYear 如果不使用year，是必需的 ISO周日期年份。可以是任何计算结果为数字的表达式。值范围： 0-9999 month 可选。只能与year一起使用。 month。可以是任何计算结果为数字的表达式。默认为1。值范围：1-12从MongoDB 4.0开始，如果指定的数字超出此范围，则会$dateFromParts在日期计算中纳入差异。有关示例，请参见值范围。 isoWeek 可选。只能与isoWeekYear一起使用。 一年中的一周。可以是任何计算结果为数字的表达式。默认为1。值范围：1-53从MongoDB 4.0开始，如果指定的数字超出此范围，则会$dateFromParts在日期计算中纳入差异。有关示例，请参见值范围。 day 可选的。只能与year一起使用。 一个月中的某天。可以是任何计算结果为数字的表达式。默认为1。值范围： 1-31从MongoDB 4.0开始，如果指定的数字超出此范围，则会$dateFromParts在日期计算中纳入差异。有关示例，请参见值范围。 isoDayOfWeek 可选。只能与isoWeekYear一起使用。 星期几（星期一1-星期日7）。可以是任何计算结果为数字的表达式。默认为1。值范围：1-7从MongoDB 4.0开始，如果指定的数字超出此范围，则会$dateFromParts在日期计算中纳入差异。有关示例，请参见值范围。 hour 可选 可以是任何计算结果为数字的表达式。默认为0。值范围： 0-23从MongoDB 4.0开始，如果指定的数字超出此范围，则会$dateFromParts在日期计算中纳入差异。有关示例，请参见值范围。 minute 可选 可以是任何计算结果为数字的表达式。默认为0。值范围： 0- 59从MongoDB 4.0开始，如果指定的数字超出此范围，$dateFromParts则将日期计算中的差值纳入考虑范围。有关示例，请参见值范围。 second 可选 可以是任何计算结果为数字的表达式。默认为0。值范围：0-59从MongoDB 4.0开始，如果指定的数字超出此范围，则会$dateFromParts在日期计算中纳入差异。有关示例，请参见值范围。 millisecond 可选 。可以是任何计算结果为数字的表达式。默认为0。值范围： 0-999从MongoDB 4.0开始，如果指定的数字超出此范围，则会$dateFromParts在日期计算中纳入差异。有关示例，请参见值范围。 timezone 可选 可以是任何表达式，其值是字符串，其值可以是：一个奥尔森时区标识符，例如\"Europe/London\"或\"America/New_York\"UTC偏移量，格式为：1. +/-[hh]:[mm]，例如\"+04:45\"2. +/-[hh][mm]，例如\"-0530\"3. +/-[hh]例如\"+03\"有关表达式的更多信息，请参见 表达式。 行为 值范围 在MongoDB中4.0开始，如果比其它字段中指定的值 year，isoYear和timezone是在有效范围之外， $dateFromParts携带或减去从其它日期的差来计算的日期。 值大于范围 考虑以下$dateFromParts表达式，其中month字段值为14，比12个月（或1年）的最大值大2个月： { $dateFromParts: { 'year' : 2017, 'month' : 14, 'day': 1, 'hour' : 12 } } 该表达式通过将year乘以1并将设置month为2来返回来计算日期： ISODate(\"2018-02-01T12:00:00Z\") 值小于的范围 考虑以下$dateFromParts表达式，其中month字段值为0，比最小值1个月小1个月： { $dateFromParts: { 'year' : 2017, 'month' : 0, 'day': 1, 'hour' : 12 } } 该表达式通过将减少year1并将设置month为12来返回，以计算日期： ISODate(\"2016-12-01T12:00:00Z\") 时区 在 字段中使用Olson时区标识符时，如果适用于指定的时区，MongoDB将应用DST偏移量。 例如，考虑sales包含以下文档的集合： { \"_id\" : 1, \"item\" : \"abc\", \"price\" : 20, \"quantity\" : 5, \"date\" : ISODate(\"2017-05-20T10:24:51.303Z\") } 以下汇总说明了MongoDB如何处理Olson时区标识符的DST偏移量。该示例使用 $hourand $minute运算符返回date字段的相应部分： db.sales.aggregate([ { $project: { \"nycHour\": { $hour: { date: \"$date\", timezone: \"-05:00\" } }, \"nycMinute\": { $minute: { date: \"$date\", timezone: \"-05:00\" } }, \"gmtHour\": { $hour: { date: \"$date\", timezone: \"GMT\" } }, \"gmtMinute\": { $minute: { date: \"$date\", timezone: \"GMT\" } }, \"nycOlsonHour\": { $hour: { date: \"$date\", timezone: \"America/New_York\" } }, \"nycOlsonMinute\": { $minute: { date: \"$date\", timezone: \"America/New_York\" } } } }]) 该操作返回以下结果： { \"_id\": 1, \"nycHour\" : 5, \"nycMinute\" : 24, \"gmtHour\" : 10, \"gmtMinute\" : 24, \"nycOlsonHour\" : 6, \"nycOlsonMinute\" : 24 } 例子 以下聚合用于$dateFromParts从提供的输入字段构造三个日期对象： db.sales.aggregate([ { $project: { date: { $dateFromParts: { 'year' : 2017, 'month' : 2, 'day': 8, 'hour' : 12 } }, date_iso: { $dateFromParts: { 'isoWeekYear' : 2017, 'isoWeek' : 6, 'isoDayOfWeek' : 3, 'hour' : 12 } }, date_timezone: { $dateFromParts: { 'year' : 2016, 'month' : 12, 'day' : 31, 'hour' : 23, 'minute' : 46, 'second' : 12, 'timezone' : 'America/New_York' } } } }]) 该操作返回以下结果： { \"_id\" : 1, \"date\" : ISODate(\"2017-02-08T12:00:00Z\"), \"date_iso\" : ISODate(\"2017-02-08T12:00:00Z\"), \"date_timezone\" : ISODate(\"2017-01-01T04:46:12Z\") } Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Aggregation-Pipeline-Operators/dateToParts-aggregation.html":{"url":"docs/Reference/Operators/Aggregation-Pipeline-Operators/dateToParts-aggregation.html","title":"$dateToParts (aggregation)","keywords":"","body":" $dateToParts (aggregation) 在本页面 定义 行为 例子 定义 $dateToParts 3.6版的新功能。 返回包含给定BSON日期值的组成部分作为单个属性的文档。返回的属性year，month，day，hour，minute，second 和millisecond。 您可以将iso8601属性设置为true，以返回代表ISO周日期的部分 。这将返回一个文档，其中的属性是 isoWeekYear，isoWeek，isoDayOfWeek，hour， minute，second和millisecond。 $dateToParts表达式具有以下语法： { $dateToParts: { 'date' : , 'timezone' : , 'iso8601' : } } 在$dateToParts需要具有以下字段的文档： 字段 必选/可选 描述 year 必选 在版本3.6中更改。返回部分的输入日期。可以是解析为日期、时间戳或ObjectID的任何表达式。有关表达式的更多信息，请参见表达式。 timezone 可选 用于格式化日期的时区。默认情况下， $dateToParts使用UTC。可以是任何表达式，该表达式的值可以是:1. 一个奥尔森时区标识符，例如\"Europe/London\"或\"America/New_York\"，2. UTC偏移量，格式为：a. +/-[hh]:[mm]，例如\"+04:45\"b. +/-[hh][mm]，例如\"-0530\"c. +/-[hh]例如\"+03\"有关表达式的更多信息，请参见 表达式。 iso8601 可选 如果设置为true，则修改输出文档以使用ISO周日期字段。默认为false。 行为 在 字段中使用Olson时区标识符时，如果适用于指定的时区，MongoDB将应用DST偏移量。 例如，考虑sales包含以下文档的集合： { \"_id\" : 1, \"item\" : \"abc\", \"price\" : 20, \"quantity\" : 5, \"date\" : ISODate(\"2017-05-20T10:24:51.303Z\") } 以下汇总说明了MongoDB如何处理Olson时区标识符的DST偏移量。该示例使用 $hour和 $minute运算符返回date字段的相应部分： db.sales.aggregate([ { $project: { \"nycHour\": { $hour: { date: \"$date\", timezone: \"-05:00\" } }, \"nycMinute\": { $minute: { date: \"$date\", timezone: \"-05:00\" } }, \"gmtHour\": { $hour: { date: \"$date\", timezone: \"GMT\" } }, \"gmtMinute\": { $minute: { date: \"$date\", timezone: \"GMT\" } }, \"nycOlsonHour\": { $hour: { date: \"$date\", timezone: \"America/New_York\" } }, \"nycOlsonMinute\": { $minute: { date: \"$date\", timezone: \"America/New_York\" } } } }]) 该操作返回以下结果： { \"_id\": 1, \"nycHour\" : 5, \"nycMinute\" : 24, \"gmtHour\" : 10, \"gmtMinute\" : 24, \"nycOlsonHour\" : 6, \"nycOlsonMinute\" : 24 } 例子 考虑sales包含以下文档的集合： { \"_id\" : 2, \"item\" : \"abc\", \"price\" : 10, \"quantity\" : 2, \"date\" : ISODate(\"2017-01-01T01:29:09.123Z\") } 以下聚合用于$dateToParts返回包含date字段组成部分的文档。 db.sales.aggregate([ { $project: { date: { $dateToParts: { date: \"$date\" } }, date_iso: { $dateToParts: { date: \"$date\", iso8601: true } }, date_timezone: { $dateToParts: { date: \"$date\", timezone: \"America/New_York\" } } } }]) 该操作返回以下结果： { \"_id\" : 2, \"date\" : { \"year\" : 2017, \"month\" : 1, \"day\" : 1, \"hour\" : 1, \"minute\" : 29, \"second\" : 9, \"millisecond\" : 123 }, \"date_iso\" : { \"isoWeekYear\" : 2016, \"isoWeek\" : 52, \"isoDayOfWeek\" : 7, \"hour\" : 1, \"minute\" : 29, \"second\" : 9, \"millisecond\" : 123 }, \"date_timezone\" : { \"year\" : 2016, \"month\" : 12, \"day\" : 31, \"hour\" : 20, \"minute\" : 29, \"second\" : 9, \"millisecond\" : 123 } } Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Aggregation-Pipeline-Operators/dateFromString-aggregation.html":{"url":"docs/Reference/Operators/Aggregation-Pipeline-Operators/dateFromString-aggregation.html","title":"$dateFromString (aggregation)","keywords":"","body":" $dateFromString (aggregation) 在本页面 定义 行为 格式说明 例子 定义 $dateFromString 3.6版的新功能。 将日期/时间字符串转换为日期对象。 该$dateFromString表达式具有以下语法： { $dateFromString: { dateString: , format: , timezone: , onError: , onNull: } } 在$dateFromString需要具有以下字段的文档： 字段 描述 dateString 要转换为日期对象的日期/时间字符串。有关日期/时间格式的更多信息，请参见日期。注意:如果timezone为操作符指定选项，请不要在dateString中包含时区信息。 format 可选的。dateString的日期格式规范 。format可以是计算结果为字符串文字的任何表达式，其中包含0个或多个格式说明符。有关可用的说明符列表，请参见格式说明符。如果未指定，则$dateFromString使用 \"%Y-%m-%dT%H:%M:%S.%LZ\"默认格式。版本4.0中的新功能。 timezone 可选的。用于格式化日期的时区。注意:如果dateString参数的格式类似于“ 2017-02-08T12：10：40.787Z”，其中末尾的“ Z”表示祖鲁时间（UTC时区），则无法指定timezone参数。 允许使用以下选项和对其求值的表达式：1. 一个奥尔森时区标识符，例如\"Europe/London\"或\"America/New_York\"，2. UTC偏移量，格式为：a. +/-[hh]:[mm]，例如\"+04:45\"b. +/-[hh][mm]，例如\"-0530\"c. +/-[hh]，例如\"+03\"3. 字符串“ Z”，“ UTC”或“ GMT”有关表达式的更多信息，请参见表达式。 onError 可选的。如果$dateFromString在解析给定dateString时遇到错误，则输出所提供onError 表达式的结果值。此结果值可以是任何类型。如果未指定onError，$dateFromString 则无法解析dateString时将引发错误。 onNull 可选的。如果提供给$dateFromString的dateString为空或缺失，则输出提供的onNull表达式的结果值。这个结果值可以是任何类型。如果不指定onNull，并且dateString为null 或丢失，然后$dateFromString输出null。 也可以看看 $toDate和 $convert 行为 例子 结果 { $dateFromString: { dateString: \"2017-02-08T12:10:40.787\" } } ISODate(\"2017-02-08T12:10:40.787Z\") { $dateFromString: { dateString: \"2017-02-08T12:10:40.787\", timezone: \"America/New_York\" } } ISODate(\"2017-02-08T17:10:40.787Z\") { $dateFromString: { dateString: \"2017-02-08\" } } ISODate(\"2017-02-08T00:00:00Z\") { $dateFromString: { dateString: \"06-15-2018\", format: \"%m-%d-%Y\" } } ISODate(\"2018-06-15T00:00:00Z\") { $dateFromString: { dateString: \"15-06-2018\", format: \"%d-%m-%Y\" } } ISODate(\"2018-06-15T00:00:00Z\") 格式说明 以下格式说明符可用于 ： 说明符 描述 可能的值 %d 每月的日期（2位数字，零填充） 01--31 %G ISO 8601格式的年份 0000--9999 %H 小时（2位数字，零填充，24小时制） 00--23 %L 毫秒（3位数字，零填充） 000--999 %m 月（2位数字，零填充） 01--12 %M 分钟（2位数字，零填充） 00--59 %S 秒（2位数字，零填充） 00--60 %u ISO 8601格式的星期几编号（1-Monday，7-Sunday） 1--7 %V 一年中的星期，采用ISO 8601格式 1--53 %Y 年（4位数字，零填充） 0000--9999 %z 与UTC的时区偏移量。 +/-[hh][mm] %Z 分钟数从UTC偏移为数字。例如，如果时区偏移量（+/-[hhmm]）为+0445，则分钟偏移量为+285。 +/-mmm %% 文字字符百分比 % 例子 转换日期 考虑一个logmessages包含以下带有日期的文档的集合。 { _id: 1, date: \"2017-02-08T12:10:40.787\", timezone: \"America/New_York\", message: \"Step 1: Started\" }, { _id: 2, date: \"2017-02-08\", timezone: \"-05:00\", message: \"Step 1: Ended\" }, { _id: 3, message: \" Step 1: Ended \" }, { _id: 4, date: \"2017-02-09\", timezone: \"Europe/London\", message: \"Step 2: Started\"} { _id: 5, date: \"2017-02-09T03:35:02.055\", timezone: \"+0530\", message: \"Step 2: In Progress\"} 以下聚合使用$dateFromString将date值转换为日期对象： db.logmessages.aggregate( [ { $project: { date: { $dateFromString: { dateString: '$date', timezone: 'America/New_York' } } } } ] ) 上述汇总返回以下文档，并将每个date字段转换为东部时区： { \"_id\" : 1, \"date\" : ISODate(\"2017-02-08T17:10:40.787Z\") } { \"_id\" : 2, \"date\" : ISODate(\"2017-02-08T05:00:00Z\") } { \"_id\" : 3, \"date\" : null } { \"_id\" : 4, \"date\" : ISODate(\"2017-02-09T05:00:00Z\") } { \"_id\" : 5, \"date\" : ISODate(\"2017-02-09T08:35:02.055Z\") } timezone参数也可以通过一个文档字段，而不是硬编码参数提供的。例如： db.logmessages.aggregate( [ { $project: { date: { $dateFromString: { dateString: '$date', timezone: '$timezone' } } } } ] ) 上面的汇总返回以下文档，并将每个date字段转换为其各自的UTC表示形式。 { \"_id\" : 1, \"date\" : ISODate(\"2017-02-08T17:10:40.787Z\") } { \"_id\" : 2, \"date\" : ISODate(\"2017-02-08T05:00:00Z\") } { \"_id\" : 3, \"date\" : null } { \"_id\" : 4, \"date\" : ISODate(\"2017-02-09T00:00:00Z\") } { \"_id\" : 5, \"date\" : ISODate(\"2017-02-08T22:05:02.055Z\") } onError 如果您的集合包含带有$dateFromString无法解析的日期字符串的文档， 除非您向可选参数提供聚合表达式， 否则将引发错误 onError。 例如，给定一个dates具有以下文档的集合： { \"_id\" : 1, \"date\" : \"2017-02-08T12:10:40.787\", timezone: \"America/New_York\" }, { \"_id\" : 2, \"date\" : \"20177-02-09T03:35:02.055\", timezone: \"America/New_York\" } 您可以使用onError参数以其原始字符串形式返回无效日期： db.dates.aggregate( [ { $project: { date: { $dateFromString: { dateString: '$date', timezone: '$timezone', onError: '$date' } } } } ] ) 这将返回以下文档： { \"_id\" : 1, \"date\" : ISODate(\"2017-02-08T17:10:40.787Z\") } { \"_id\" : 2, \"date\" : \"20177-02-09T03:35:02.055\" } onNull 如果您的集合包含带有null日期字符串的文档，则 $dateFromString返回null，除非您为可选的onNull参数的聚合表达式。 例如，给定一个dates具有以下文档的集合： { \"_id\" : 1, \"date\" : \"2017-02-08T12:10:40.787\", timezone: \"America/New_York\" }, { \"_id\" : 2, \"date\" : null, timezone: \"America/New_York\" } 您可以使用onNull参数让$dateFromString返回代表Unix纪元的日期，而不是null： db.dates.aggregate( [ { $project: { date: { $dateFromString: { dateString: '$date', timezone: '$timezone', onNull: new Date(0) } } } } ] ) 这将返回以下文档： { \"_id\" : 1, \"date\" : ISODate(\"2017-02-08T17:10:40.787Z\") } { \"_id\" : 2, \"date\" : ISODate(\"1970-01-01T00:00:00Z\") } Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Aggregation-Pipeline-Operators/literal-aggregation.html":{"url":"docs/Reference/Operators/Aggregation-Pipeline-Operators/literal-aggregation.html","title":"$literal (aggregation)","keywords":"","body":" $literal (aggregation) 在本页面 定义 行为 例子 定义 $literal 返回 value 而不解析。用于聚合管道可以将其解释为表达式的值。 $literal表达式具有以下语法： { $literal: } 行为 如果是表达，$literal不会计算表达式，而是返回未解析的表达式。 例 结果 { $literal: { $add: [ 2, 3 ] } } { “$add“ : [ 2, 3 ] } { $literal: { $literal: 1 } } { “$literal“ : 1 } 例子 将$视为文字 在表达中，美元符号$评估为字段路径; 即：提供对该字段的访问。对于 example，$eq expression $eq: [ “$price“, “$1“ ]在名为price的字段中的 value 与文档中名为1的字段中的 value 之间执行相等性检查。 以下 example 使用$literal表达式将包含美元符号“$1“的 string 视为常量 value。 集合records具有以下文档： { “_id“ : 1, “item“ : “abc123“, price: “$2.50“ } { “_id“ : 2, “item“ : “xyz123“, price: “1“ } { “_id“ : 3, “item“ : “ijk123“, price: “$1“ } db.records.aggregate( [ { $project: { costsOneDollar: { $eq: [ “$price“, { $literal: “$1“ } ] } } } ] ) 此操作投影名为costsOneDollar的字段，该字段包含 boolean value，指示price字段的 value 是否等于 string “$1“： { “_id“ : 1, “costsOneDollar“ : false } { “_id“ : 2, “costsOneDollar“ : false } { “_id“ : 3, “costsOneDollar“ : true } 使用 Value 1 投影新字段 $project阶段使用表达式: 1在输出中包含。以下 example 使用$literal来_return 将新字段设置为1的 value。 集合bids具有以下文档： { “_id“ : 1, “item“ : “abc123“, condition: “new“ } { “_id“ : 2, “item“ : “xyz123“, condition: “new“ } 以下聚合计算表达式item: 1以表示 return 输出中的现有字段item，但使用{$literal：1 }表达式 return 新字段startAt设置为 value 1： db.bids.aggregate( [ { $project: { item: 1, startAt: { $literal: 1 } } } ] ) 该操作产生以下文件： { “_id“ : 1, “item“ : “abc123“, “startAt“ : 1 } { “_id“ : 2, “item“ : “xyz123“, “startAt“ : 1 } Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Operators/Query-Modifiers.html":{"url":"docs/Reference/Operators/Query-Modifiers.html","title":"Query Modifiers","keywords":"","body":" 查询修饰符 除了MongoDB查询运算符外，还有许多meta运算符可让您修改查询的输出或行为。 注意 mongo从v3.2开始在Shell中不推荐使用 从v3.2开始，mongoshell 中不建议使用查询meta运算符。在mongoshell程序中，改用游标方法 。 驱动程序接口可以提供包装这些选项的游标方法。如果可能，请使用这些方法。否则，您可以使用以下两种语法之一添加这些选项： db.collection.find( { } )._addSpecial( ) db.collection.find( { $query: { }, } ) 运算符 修饰符 注意 mongo从v3.2开始在Shell中不推荐使用 从v3.2开始，mongoshell 中不建议使用查询meta运算符。在mongoshell程序中，改用游标方法 。 名称 描述 $comment 向查询添加注释，以标识数据库探查器输出中的查询。 $explain 强制MongoDB报告查询执行计划。请参阅explain()。 $hint 仅强制MongoDB使用特定索引。请看hint() $max 指定要在查询中使用的索引的排他上限。请参阅max()。 $maxTimeMS 指定对游标进行处理操作的累积时间限制（以毫秒为单位）。请参阅maxTimeMS()。 $min 指定一个包容性的下限为索引在查询中使用。请参阅min()。 $orderby 返回带有根据排序规范排序的文档的游标。请参阅sort()。 $query 包装查询文档。 $returnKey 强制游标仅返回索引中包含的字段。 $showDiskLoc 修改返回的文档以包括对每个文档在磁盘上位置的引用。 排序顺序 名称 描述 $natural 一种特殊的排序顺序，使用磁盘上的文档顺序对文档进行排序。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Database-Commands.html":{"url":"docs/Reference/Database-Commands.html","title":"Database Commands","keywords":"","body":" 数据库命令 在本页面 用户命令 数据库操作 审核命令 下文概述的所有命令文档均描述了命令及其可用参数，并提供了每个命令的文档模板或原型。一些命令文档还包括相关的 mongoShell帮助器。 要针对当前数据库运行命令，请使用db.runCommand()： db.runCommand( { } ) 要对admin数据库运行管理命令，请使用db.adminCommand()： db.adminCommand( { } ) 注意 有关特定命令的详细信息，包括语法和示例，请单击特定命令以转到其参考页面。 用户命令 聚合命令 名称 描述 aggregate 使用聚合框架执行聚合任务，例如分组。 count 计算集合或视图中的文档数。 distinct 显示在集合或视图中为指定键找到的不同值。 mapReduce 对大型数据集执行map-reduce聚合。 地理空间命令 名称 描述 geoSearch 执行使用MongoDB的haystack索引功能的地理空间查询。 查询和写操作命令 名称 描述 delete 删除一个或多个文档。 find 返回集合或视图中的文档。 findAndModify 返回并修改单个文档。 getLastError 返回上一个操作的成功状态。 getMore 返回当前由游标指向的批处理文档。 insert 插入一个或多个文档。 resetError 不推荐使用。重置上一个错误状态。 update 更新一个或多个文档。 查询计划缓存命令 名称 描述 planCacheClear 删除集合的缓存查询计划。 planCacheClearFilters 清除集合的索引过滤器。 planCacheListFilters 列出集合的索引过滤器。 planCacheListPlans 显示指定查询模型的缓存查询计划。 planCacheListQueryShapes 显示存在其缓存的查询计划的查询模型。 planCacheSetFilter 为集合设置索引过滤器。 数据库操作 认证命令 名称 描述 authenticate 使用用户名和密码启动经过身份验证的会话。 getnonce 这是一个内部命令，用于生成用于身份验证的一次性密码。 logout 终止当前已认证的会话。 用户管理命令 名称 描述 createUser 创建一个新用户。 dropAllUsersFromDatabase 删除与数据库关联的所有用户。 dropUser 删除一个用户。 grantRolesToUser 向用户授予角色及其特权。 revokeRolesFromUser 从用户删除角色。 updateUser 更新用户的数据。 usersInfo 返回有关指定用户的信息。 角色管理命令 名称 描述 createRole 创建一个角色并指定其特权。 dropRole 删除用户定义的角色。 dropAllRolesFromDatabase 从数据库中删除所有用户定义的角色。 grantPrivilegesToRole 将特权分配给用户定义的角色。 grantRolesToRole 指定角色，用户定义的角色将从这些角色继承特权。 invalidateUserCache 刷新用户信息的内存缓存，包括凭据和角色。 revokePrivilegesFromRole 从用户定义的角色中删除指定的特权。 revokeRolesFromRole 从用户定义的角色中删除指定的继承角色。 rolesInfo 返回指定角色的信息。 updateRole 更新用户定义的角色。 复制命令 名称 描述 applyOps 应用于内部命令OPLOG条目到当前数据集。 isMaster 显示有关此成员在副本集中的角色的信息，包括它是否为主角色。 replSetAbortPrimaryCatchUp 强制选择的主数据库中止同步（追赶），然后完成到主数据库的过渡。 replSetFreeze 防止当前成员在一段时间内寻求选举为主。 replSetGetConfig 返回副本集的配置对象。 replSetGetStatus 返回报告副本集状态的文档。 replSetInitiate 初始化新的副本集。 replSetMaintenance 启用或禁用维护模式，该模式将辅助节点置于一种RECOVERING状态。 replSetReconfig 将新配置应用于现有副本集。 replSetResizeOplog 动态调整副本集成员的操作日志的大小。仅适用于WiredTiger存储引擎。 replSetStepDown 当前primary下台,成为一个secondary，迫使选举。 replSetSyncFrom 显式覆盖用于选择要复制的成员的默认逻辑。 也可以看看 有关复制的更多信息。 分片命令 名称 描述 addShard 添加一个分片到分片集群。 addShardToZone 将分片与zone关联。支持在分片群集中配置zone。 balancerStart 启动平衡器线程。 balancerStatus 返回有关平衡器状态的信息。 balancerStop 停止平衡器线程。 checkShardingIndex 验证分片键索引的内部命令。 clearJumboFlag 清除jumbo数据块的标志。 cleanupOrphaned 删除分片键值超出分片拥有的数据块范围之外的孤立数据。 enableSharding 在特定数据库上启用分片。 flushRouterConfig 强制mongod/ mongos实例更新其缓存的路由元数据。 getShardMap 报告分片群集状态的内部命令。 getShardVersion 返回配置服务器版本的内部命令。 isdbgrid 验证进程是否是mongos。 listShards 返回已配置的分片列表。 medianKey 不推荐使用的内部命令。请参阅splitVector。 moveChunk 在分片之间迁移块的内部命令。 movePrimary 从分片集群中删除分片时，重新分配主分片。 mergeChunks 提供在单个分片上组合块的功能。 removeShard 启动从分片群集中删除分片的进程。 removeShardFromZone 删除分片和zone之间的关联。支持在分片群集中配置zone。 setShardVersion 内部命令，用于设置配置服务器版本。 shardCollection 启用集合的分片功能，从而可以对集合进行分片。 shardingState 报告mongod 是否为分片群集的成员。 split 创建一个新的块。 splitChunk 拆分块的内部命令。而是使用方法sh.splitFind()和sh.splitAt()。 splitVector 确定分割点的内部命令。 unsetSharding 影响MongoDB部署中实例之间的连接的内部命令。 updateZoneKeyRange 添加或删除范围内的分片数据与zone之间的关联。支持在分片群集中配置zone。 也可以看看 有关MongoDB的分片功能的更多信息。 会话命令 指令 描述 abortTransaction 中止事务版本4.0中的新功能。 commitTransaction 提交事务版本4.0中的新功能。 endSessions 在会话超时期限之前终止会话。3.6版的新功能。 killAllSessions 杀死所有会话。3.6版的新功能。 killAllSessionsByPattern 杀死所有与指定模式匹配的会话3.6版的新功能。 killSessions 杀死指定的会话。3.6版的新功能。 refreshSessions 刷新空闲会话。3.6版的新功能。 startSession 开始新的会话。3.6版的新功能。 管理命令 名称 描述 clean 内部名称空间管理命令。 cloneCollection 将集合从远程主机复制到当前主机。 cloneCollectionAsCapped 将未设置上限的集合复制为新的设置上限的集合。 collMod 向集合添加选项或修改视图定义。 compact 对集合进行分片整理并重建索引。 connPoolSync 用于刷新连接池的内部命令。 convertToCapped 将无上限的集合转换为有上限的集合。 create 创建一个集合或视图。 createIndexes 为一个集合构建一个或多个索引。 currentOp 返回一个文档，该文档包含有关数据库实例正在进行的操作的信息。 drop 从数据库中删除指定的集合。 dropDatabase 删除当前数据库。 dropConnections 将外向连接删除到指定的主机列表。 dropIndexes 从集合中删除索引。 filemd5 返回使用GridFS存储的文件的md5哈希值。 fsync 将挂起的写入刷新到存储层，并锁定数据库以允许备份。 fsyncUnlock 解锁一个fsync锁。 getParameter 检索配置选项。 killCursors 杀死集合的指定游标。 killOp 终止操作ID指定的操作。 listCollections 返回当前数据库中的集合列表。 listDatabases 返回列出所有数据库的文档，并返回基本数据库统计信息。 listIndexes 列出集合的所有索引。 logRotate 循环MongoDB日志，以防止单个文件占用过多空间。 reIndex 重建集合上的所有索引。 renameCollection 更改现有集合的名称。 setFeatureCompatibilityVersion 启用或禁用保留向后不兼容的数据的功能。 setParameter 修改配置选项。 shutdown 关闭mongod或mongos进程。 诊断命令 名称 描述 availableQueryOptions 内部命令，报告当前MongoDB实例的功能。 buildInfo 显示有关MongoDB构建的统计信息。 collStats 报告指定集合的存储利用率静态信息。 connPoolStats 报告从此MongoDB实例到部署中其他MongoDB实例的传出连接的统计信息。 connectionStatus 报告当前连接的身份验证状态。 cursorInfo 在MongoDB 3.2中已删除。替换为metrics.cursor。 dataSize 返回数据范围的数据大小。供内部使用。 dbHash 返回数据库及其集合的哈希值。 dbStats 报告指定数据库的存储利用率统计信息。 diagLogging 在MongoDB 3.6中已删除。要捕获，重放和分析发送到您的MongoDB部署的命令，请使用mongoreplay。 driverOIDTest 将ObjectId转换为字符串以支持测试的内部命令。 explain 返回有关各种操作执行的信息。 features 报告当前MongoDB实例中可用的功能。 getCmdLineOpts 返回带有MongoDB实例及其解析选项的运行时参数的文档。 getLog 返回最近的日志消息。 hostInfo 返回反映基础主机系统的数据。 isSelf 内部命令支持测试。 listCommands 列出当前mongod实例提供的所有数据库命令。 lockInfo 内部命令，返回有关当前正在保留或挂起的锁的信息。仅适用于 mongod实例。 netstat 报告部署内连接性的内部命令。仅适用于mongos实例。 ping 测试部署内连接性的内部命令。 profile 数据库事件探查器的接口。 serverStatus 返回有关实例范围的资源利用率和状态的集合指标。 shardConnPoolStats 报告mongos连接池上的统计信息，以供客户端针对分片进行操作。 top 返回mongod实例中每个数据库的原始使用情况统计信息。 validate 内部命令，用于扫描集合的数据并为正确性编制索引。 whatsmyuri 返回有关当前客户端信息的内部命令。 免费监控命令 名称 描述 setFreeMonitoring 在运行时启用/禁用免费监视。 审核命令 名称 描述 logApplicationMessage 将自定义消息发布到审核日志。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Database-Commands/Aggregation-Commands.html":{"url":"docs/Reference/Database-Commands/Aggregation-Commands.html","title":"Aggregation Commands","keywords":"","body":" 聚合命令 注意 有关特定命令的详细信息，包括语法和示例，请单击特定命令以转到其参考页面。 名称 描述 aggregate 使用聚合框架执行聚合任务，例如分组。 count 计算集合或视图中的文档数。 distinct 显示在集合或视图中为指定键找到的不同值。 mapReduce 对大型数据集执行map-reduce聚合。 有关不同方法的详细比较，请参阅“ 聚合命令比较”。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Database-Commands/Geospatial-Commands.html":{"url":"docs/Reference/Database-Commands/Geospatial-Commands.html","title":"Geospatial Commands","keywords":"","body":" 地理空间命令 注意 有关特定命令的详细信息，包括语法和示例，请单击特定命令以转到其参考页面。 名称 描述 geoSearch 执行使用MongoDB的haystack索引功能的地理空间查询。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Database-Commands/Query-and-Write-Operation-Commands.html":{"url":"docs/Reference/Database-Commands/Query-and-Write-Operation-Commands.html","title":"Query and Write Operation Commands","keywords":"","body":" 查询和写操作命令 注意 有关特定命令的详细信息，包括语法和示例，请单击特定命令以转到其参考页面。 名称 描述 delete 删除一个或多个文档。 find 返回集合或视图中的文档。 findAndModify 返回并修改单个文档。 getLastError 返回上一个操作的成功状态。 getMore 返回当前由游标指向的批处理文档。 insert 插入一个或多个文档。 resetError 不推荐使用。重置上一个错误状态。 update 更新一个或多个文档。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Database-Commands/Query-Plan-Cache-Commands.html":{"url":"docs/Reference/Database-Commands/Query-Plan-Cache-Commands.html","title":"Query Plan Cache Commands","keywords":"","body":" 查询计划缓存命令 注意 有关特定命令的详细信息，包括语法和示例，请单击特定命令以转到其参考页面。 名称 描述 planCacheClear 删除集合的缓存查询计划。 planCacheClearFilters 清除集合的索引过滤器。 planCacheListFilters 列出集合的索引过滤器。 planCacheListPlans 显示指定查询模型的缓存查询计划。 planCacheListQueryShapes 显示存在其缓存的查询计划的查询模型。 planCacheSetFilter 为集合设置索引过滤器。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Database-Commands/Authentication-Commands.html":{"url":"docs/Reference/Database-Commands/Authentication-Commands.html","title":"Authentication Commands","keywords":"","body":" 认证命令 注意 有关特定命令的详细信息，包括语法和示例，请单击特定命令以转到其参考页面。 名称 描述 authenticate 使用用户名和密码启动经过身份验证的会话。 getnonce 这是一个内部命令，用于生成用于身份验证的一次性密码。 logout 终止当前已认证的会话。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Database-Commands/User-Management-Commands.html":{"url":"docs/Reference/Database-Commands/User-Management-Commands.html","title":"User Management Commands","keywords":"","body":" 用户管理命令 注意 有关特定命令的详细信息，包括语法和示例，请单击特定命令以转到其参考页面。 名称 描述 createUser 创建一个新用户。 dropAllUsersFromDatabase 删除与数据库关联的所有用户。 dropUser 删除一个用户。 grantRolesToUser 向用户授予角色及其特权。 revokeRolesFromUser 从用户删除角色。 updateUser 更新用户的数据。 usersInfo 返回有关指定用户的信息。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Database-Commands/Role-Management-Commands.html":{"url":"docs/Reference/Database-Commands/Role-Management-Commands.html","title":"Role Management Commands","keywords":"","body":" 角色管理命令 注意 有关特定命令的详细信息，包括语法和示例，请单击特定命令以转到其参考页面。 名称 描述 createRole 创建一个角色并指定其特权。 dropRole 删除用户定义的角色。 dropAllRolesFromDatabase 从数据库中删除所有用户定义的角色。 grantPrivilegesToRole 将特权分配给用户定义的角色。 grantRolesToRole 指定角色，用户定义的角色将从这些角色继承特权。 invalidateUserCache 刷新用户信息的内存缓存，包括凭据和角色。 revokePrivilegesFromRole 从用户定义的角色中删除指定的特权。 revokeRolesFromRole 从用户定义的角色中删除指定的继承角色。 rolesInfo 返回指定角色的信息。 updateRole 更新用户定义的角色。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Database-Commands/Replication-Commands.html":{"url":"docs/Reference/Database-Commands/Replication-Commands.html","title":"Replication Commands","keywords":"","body":" 数据库命令 注意 有关特定命令的详细信息，包括语法和示例，请单击特定命令以转到其参考页面。 名称 描述 applyOps 应用于内部命令OPLOG条目到当前数据集。 isMaster 显示有关此成员在副本集中的角色的信息，包括它是否为主角色。 replSetAbortPrimaryCatchUp 强制选择的主数据库中止同步（追赶），然后完成到主数据库的过渡。 replSetFreeze 防止当前成员在一段时间内寻求选举为主。 replSetGetConfig 返回副本集的配置对象。 replSetGetStatus 返回报告副本集状态的文档。 replSetInitiate 初始化新的副本集。 replSetMaintenance 启用或禁用维护模式，该模式将辅助节点置于一种RECOVERING状态。 replSetReconfig 将新配置应用于现有副本集。 replSetResizeOplog 动态调整副本集成员的操作日志的大小。仅适用于WiredTiger存储引擎。 replSetStepDown 当前primary下台,成为一个secondary，迫使选举。 replSetSyncFrom 显式覆盖用于选择要复制的成员的默认逻辑。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Database-Commands/Sharding-Commands.html":{"url":"docs/Reference/Database-Commands/Sharding-Commands.html","title":"Sharding Commands","keywords":"","body":" 分片命令 注意 有关特定命令的详细信息，包括语法和示例，请单击特定命令以转到其参考页面。 名称 描述 addShard 添加一个分片到分片集群。 addShardToZone 将分片与zone关联。支持在分片群集中配置zone。 balancerStart 启动平衡器线程。 balancerStatus 返回有关平衡器状态的信息。 balancerStop 停止平衡器线程。 checkShardingIndex 验证分片键索引的内部命令。 clearJumboFlag 清除jumbo数据块的标志。 cleanupOrphaned 删除分片键值超出分片拥有的数据块范围之外的孤立数据。 enableSharding 在特定数据库上启用分片。 flushRouterConfig 强制mongod/ mongos实例更新其缓存的路由元数据。 getShardMap 报告分片群集状态的内部命令。 getShardVersion 返回配置服务器版本的内部命令。 isdbgrid 验证进程是否是mongos。 listShards 返回已配置的分片列表。 medianKey 不推荐使用的内部命令。请参阅splitVector。 moveChunk 在分片之间迁移块的内部命令。 movePrimary 从分片集群中删除分片时，重新分配主分片。 mergeChunks 提供在单个分片上组合块的功能。 removeShard 启动从分片群集中删除分片的进程。 removeShardFromZone 删除分片和zone之间的关联。支持在分片群集中配置zone。 setShardVersion 内部命令，用于设置配置服务器版本。 shardCollection 启用集合的分片功能，从而可以对集合进行分片。 shardingState 报告mongod 是否为分片群集的成员。 split 创建一个新的块。 splitChunk 拆分块的内部命令。而是使用方法sh.splitFind()和sh.splitAt()。 splitVector 确定分割点的内部命令。 unsetSharding 影响MongoDB部署中实例之间的连接的内部命令。 updateZoneKeyRange 添加或删除范围内的分片数据与zone之间的关联。支持在分片群集中配置zone。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Database-Commands/Sessions-Commands.html":{"url":"docs/Reference/Database-Commands/Sessions-Commands.html","title":"Sessions Commands","keywords":"","body":" 会话命令 注意 有关特定命令的详细信息，包括语法和示例，请单击特定命令以转到其参考页面。 指令 描述 abortTransaction 中止事务版本4.0中的新功能。 commitTransaction 提交事务版本4.0中的新功能。 endSessions 在会话超时期限之前终止会话。3.6版的新功能。 killAllSessions 杀死所有会话。3.6版的新功能。 killAllSessionsByPattern 杀死所有与指定模式匹配的会话3.6版的新功能。 killSessions 杀死指定的会话。3.6版的新功能。 refreshSessions 刷新空闲会话。3.6版的新功能。 startSession 开始新的会话。3.6版的新功能。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Database-Commands/Administration-Commands.html":{"url":"docs/Reference/Database-Commands/Administration-Commands.html","title":"Administration Commands","keywords":"","body":" 管理命令 注意 有关特定命令的详细信息，包括语法和示例，请单击特定命令以转到其参考页面。 名称 描述 clean 内部名称空间管理命令。 cloneCollection 将集合从远程主机复制到当前主机。 cloneCollectionAsCapped 将未设置上限的集合复制为新的设置上限的集合。 collMod 向集合添加选项或修改视图定义。 compact 对集合进行分片整理并重建索引。 connPoolSync 用于刷新连接池的内部命令。 convertToCapped 将无上限的集合转换为有上限的集合。 create 创建一个集合或视图。 createIndexes 为一个集合构建一个或多个索引。 currentOp 返回一个文档，该文档包含有关数据库实例正在进行的操作的信息。 drop 从数据库中删除指定的集合。 dropDatabase 删除当前数据库。 dropConnections 将外向连接删除到指定的主机列表。 dropIndexes 从集合中删除索引。 filemd5 返回使用GridFS存储的文件的md5哈希值。 fsync 将挂起的写入刷新到存储层，并锁定数据库以允许备份。 fsyncUnlock 解锁一个fsync锁。 getParameter 检索配置选项。 killCursors 杀死集合的指定游标。 killOp 终止操作ID指定的操作。 listCollections 返回当前数据库中的集合列表。 listDatabases 返回列出所有数据库的文档，并返回基本数据库统计信息。 listIndexes 列出集合的所有索引。 logRotate 循环MongoDB日志，以防止单个文件占用过多空间。 reIndex 重建集合上的所有索引。 renameCollection 更改现有集合的名称。 setFeatureCompatibilityVersion 启用或禁用保留向后不兼容的数据的功能。 setParameter 修改配置选项。 shutdown 关闭mongod或mongos进程。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Database-Commands/Diagnostic-Commands.html":{"url":"docs/Reference/Database-Commands/Diagnostic-Commands.html","title":"Diagnostic Commands","keywords":"","body":" 诊断命令 注意 有关特定命令的详细信息，包括语法和示例，请单击特定命令以转到其参考页面。 名称 描述 availableQueryOptions 内部命令，报告当前MongoDB实例的功能。 buildInfo 显示有关MongoDB构建的统计信息。 collStats 报告指定集合的存储利用率静态信息。 connPoolStats 报告从此MongoDB实例到部署中其他MongoDB实例的传出连接的统计信息。 connectionStatus 报告当前连接的身份验证状态。 cursorInfo 在MongoDB 3.2中已删除。替换为metrics.cursor。 dataSize 返回数据范围的数据大小。供内部使用。 dbHash 返回数据库及其集合的哈希值。 dbStats 报告指定数据库的存储利用率统计信息。 diagLogging 在MongoDB 3.6中已删除。要捕获，重放和分析发送到您的MongoDB部署的命令，请使用mongoreplay。 driverOIDTest 将ObjectId转换为字符串以支持测试的内部命令。 explain 返回有关各种操作执行的信息。 features 报告当前MongoDB实例中可用的功能。 getCmdLineOpts 返回带有MongoDB实例及其解析选项的运行时参数的文档。 getLog 返回最近的日志消息。 hostInfo 返回反映基础主机系统的数据。 isSelf 内部命令支持测试。 listCommands 列出当前mongod实例提供的所有数据库命令。 lockInfo 内部命令，返回有关当前正在保留或挂起的锁的信息。仅适用于 mongod实例。 netstat 报告部署内连接性的内部命令。仅适用于mongos实例。 ping 测试部署内连接性的内部命令。 profile 数据库事件探查器的接口。 serverStatus 返回有关实例范围的资源利用率和状态的集合指标。 shardConnPoolStats 报告mongos连接池上的统计信息，以供客户端针对分片进行操作。 top 返回mongod实例中每个数据库的原始使用情况统计信息。 validate 内部命令，用于扫描集合的数据并为正确性编制索引。 whatsmyuri 返回有关当前客户端信息的内部命令。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Database-Commands/Free-Monitoring-Commands.html":{"url":"docs/Reference/Database-Commands/Free-Monitoring-Commands.html","title":"Free Monitoring Commands","keywords":"","body":" 免费监控命令 注意 有关特定命令的详细信息，包括语法和示例，请单击特定命令以转到其参考页面。 名称 描述 getFreeMonitoringStatus 返回空闲监视状态。 setFreeMonitoring 在运行时启用/禁用免费监视。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Database-Commands/System-Events-Auditing-Commands.html":{"url":"docs/Reference/Database-Commands/System-Events-Auditing-Commands.html","title":"System Events Auditing Commands","keywords":"","body":" 数据库命令 注意 有关特定命令的详细信息，包括语法和示例，请单击特定命令以转到其参考页面。 名称 描述 logApplicationMessage 将自定义消息发布到审核日志。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods.html":{"url":"docs/Reference/mongo-Shell-Methods.html","title":"mongo Shell Methods","keywords":"","body":" mongo Shell 方法 在本页面 集合 游标 数据库 查询计划缓存 批量写入操作 用户管理 角色管理 复制 分片 Free监控 构造函数 连接 本机 客户端字段级加密 MONGODB 中的 JAVASCRIPT 虽然这些方法使用 JavaScript，但大多数与 MongoDB 的交互都不使用 JavaScript，而是在交互 application 的语言中使用惯用的司机。 注意 有关特定方法(包括语法和示例)的详细信息，请单击特定方法以转到其 reference 页面。 集合 名称 描述 db.collection.aggregate() 提供对聚合管道的访问。 db.collection.bulkWrite() 提供批量写入操作功能。 db.collection.copyTo() 已过时。包装EVAL以在单个 MongoDB 实例中的集合之间复制数据。 db.collection.count() 包装计数以_return 计算集合或视图中的文档数。 db.collection.createIndex() 在集合上构建索引。 db.collection.createIndexes() 在集合上构建一个或多个索引。 db.collection.dataSize() 返回集合的大小。包装collStats输出中的尺寸字段。 db.collection.deleteOne() 删除集合中的单个文档。 db.collection.deleteMany() 删除集合中的多个文档。 db.collection.distinct() 返回具有指定字段的不同值的文档的 array。 db.collection.drop() 从数据库中删除指定的集合。 db.collection.dropIndex() 删除集合上的指定索引。 db.collection.dropIndexes() 删除集合上的所有索引。 db.collection.ensureIndex() 已过时。使用db.collection.createIndex()。 db.collection.explain() 返回有关各种方法的查询执行的信息。 db.collection.find() 对集合或视图执行查询并返回游标 object。 db.collection.findAndModify() 以原子方式修改并返回单个文档。 db.collection.findOne() 执行查询并返回单个文档。 db.collection.findOneAndDelete() 查找单个文档并将其删除。 db.collection.findOneAndReplace() 查找单个文档并替换它。 db.collection.findOneAndUpdate() 查找单个文档并进行更新。 db.collection.getIndexes() 返回描述集合上现有索引的文档的 array。 db.collection.getShardDistribution() 对于分片群集中的集合，db.collection.getShardDistribution()报告块分布的数据。 db.collection.getShardVersion() 分片 cluster 的内部诊断方法。 db.collection.group() 已过时。提供简单的数据聚合 function。通过 key 对集合中的文档进行分组，并处理结果。使用aggregate()进行更复杂的数据聚合。 db.collection.insert() 在集合中创建新文档。 db.collection.insertOne() 在集合中插入新文档。 db.collection.insertMany() 在集合中插入几个新文档。 db.collection.isCapped() 报告集合是否为上限集合。 db.collection.latencyStats() 返回集合的延迟统计信息。 db.collection.mapReduce() 执行 map-reduce 样式数据聚合。 db.collection.reIndex() 重建集合上的所有现有索引。 db.collection.remove() 从集合中删除文档。 db.collection.renameCollection() 更改集合的 name。 db.collection.replaceOne() 替换集合中的单个文档。 db.collection.save() 在insert()和update()周围提供 wrapper 以插入新文档。 db.collection.stats() 报告集合的 state。在collStats周围提供 wrapper。 db.collection.storageSize() 报告集合使用的总大小(以字节为单位)。在collStats输出的storageSize字段周围提供 wrapper。 db.collection.totalIndexSize() 报告集合上索引使用的总大小。在collStats输出的totalIndexSize字段周围提供 wrapper。 db.collection.totalSize() 报告集合的总大小，包括所有文档的大小和集合上的所有索引。 db.collection.update() 修改集合中的文档。 db.collection.updateOne() 修改集合中的单个文档。 db.collection.updateMany() 修改集合中的多个文档。 db.collection.watch() 在集合上建立变更流。 db.collection.validate() 对集合执行诊断操作。 游标 名称 描述 cursor.addOption() 添加特殊的线程协议标志，用于修改查询的行为。 cursor.batchSize() 控制 MongoDB 将在单个网络消息中 return 到 client 的文档数。 cursor.close() 关闭游标并释放相关的服务器资源。 cursor.isClosed() 如果光标关闭，则返回true。 cursor.collation() 指定db.collection.find()返回的游标的排序规则。 cursor.comment() 将 comment 附加到查询以允许日志和 system.profile 集合中的可跟踪性。 cursor.count() 修改光标以_return 结果集中的文档数而不是文档本身。 cursor.explain() 报告游标的查询执行计划。 cursor.forEach() 对游标中的每个文档应用 JavaScript function。 cursor.hasNext() 如果游标有文档并且可以迭代，则返回 true。 cursor.hint() 强制 MongoDB 为查询使用特定索引。 cursor.isExhausted() 如果光标关闭且批处理中没有剩余 object，则返回true。 cursor.itcount() 通过获取和迭代结果集来计算游标 client-side 中的文档总数。 cursor.limit() 约束游标结果集的大小。 cursor.map() 对函数中的每个文档应用 function，并在 array 中收集 return 值。 cursor.max() 指定游标的独占上限索引。用于cursor.hint()。 cursor.maxScan() 指定要扫描的最大项目数;收集扫描的文档，索引扫描的键。 cursor.maxTimeMS() 指定用于处理游标操作的累积 time 限制(以毫秒为单位)。 cursor.min() 指定游标的包含性较低索引范围。用于cursor.hint() cursor.next() 返回游标中的下一个文档。 cursor.noCursorTimeout() 指示服务器在一段时间不活动后自动关闭光标。 cursor.objsLeftInBatch() 返回当前游标批处理中剩余的文档数。 cursor.pretty() 配置光标以 easy-to-read 格式显示结果。 cursor.readConcern() 为find()操作指定阅读关注。 cursor.readPref() 指定阅读偏好到游标以控制 client 如何将查询定向到副本集。 cursor.returnKey() 将光标修改为 return 索引键而不是文档。 cursor.showRecordId() 向光标返回的每个文档添加内部存储引擎 ID 字段。 cursor.size() 应用skip()和limit()方法后，返回游标中文档的计数。 cursor.skip() 返回仅在传递或跳过多个文档后才开始返回结果的游标。 cursor.sort() 返回根据排序规范排序的结果。 cursor.tailable() 将光标标记为 tailable。仅适用于超过上限集合的游标。 cursor.toArray() 返回包含游标返回的所有文档的 array。 数据库 名称 描述 db.adminCommand() 对admin数据库运行命令。 db.aggregate() 运行不需要底层集合的 admin/diagnostic 管道。 db.cloneCollection() 在 MongoDB 实例之间直接复制数据。包裹cloneCollection。 db.cloneDatabase() 将数据库从 remote host 复制到当前 host。包裹克隆。 db.commandHelp() 返回数据库命令的帮助信息。 db.copyDatabase() 将数据库复制到当前 host 上的另一个数据库。包裹COPYDB。 db.createCollection() 创建新集合或视图。常用于创建上限集合。 db.createView() 创建一个视图。 db.currentOp() 报告当前的 in-progress 操作。 db.dropDatabase() 删除当前数据库。 db.eval() 已过时。将 JavaScript function 传递给mongod实例 server-side JavaScript evaluation。 db.fsyncLock() 刷新写入磁盘并锁定数据库以防止写入操作并协助备份操作。包裹FSYNC。 db.fsyncUnlock() 允许在使用db.fsyncLock()锁定的数据库上写入 continue。 db.getCollection() 返回集合或视图 object。用于访问名称在mongo shell 中无效的集合。 db.getCollectionInfos() 返回当前数据库中所有集合和视图的集合信息。 db.getCollectionNames() 列出当前数据库中的所有集合和视图。 db.getLastError() 检查并返回上一次操作的状态。包裹GetLastError 函数。 db.getLastErrorObj() 返回上一个操作的状态文档。包裹GetLastError 函数。 db.getLogComponents() 返回 log 消息详细级别。 db.getMongo() 返回当前连接的Mongo()连接 object。 db.getName() 返回当前数据库的 name。 db.getPrevError() 返回包含自上次错误重置以来的所有错误的状态文档。包裹getPrevError。 db.getProfilingLevel() 返回数据库操作的当前分析 level。 db.getProfilingStatus() 返回反映当前性能分析 level 和性能分析阈值的文档。 db.getReplicationInfo() 返回包含复制统计信息的文档。 db.getSiblingDB() 提供对指定数据库的访问。 db.help() 显示 common db object 方法的说明。 db.hostInfo() 返回一个文档，其中包含有关运行 MongoDB 的系统的信息。包裹Hostinfo 中。 db.isMaster() 返回报告副本集的 state 的文档。 db.killOp() 终止指定的操作。 db.listCommands() 显示 common 数据库命令的列表。 db.logout() 结束经过身份验证的 session。 db.printCollectionStats() 打印每个集合的统计信息。包裹db.collection.stats()。 db.printReplicationInfo() 从主数据库的角度打印副本集状态的报告。 db.printShardingStatus() 打印分片配置和块范围的报告。 db.printSlaveReplicationInfo() 从辅助节点的角度打印副本集状态的报告。 db.repairDatabase() 在当前数据库上运行修复例程。 db.resetError() 重置db.getPrevError()和getPrevError返回的错误消息。 db.runCommand() 运行数据库命令。 db.serverBuildInfo() 返回显示mongod实例的编译参数的文档。包装buildinfo。 db.serverCmdLineOpts() 返回一个文档，其中包含有关用于启动 MongoDB 实例的运行时的信息。包裹getCmdLineOpts。 db.serverStatus() 返回一个文档，该文档提供数据库 process 的 state 的概述。 db.setLogLevel() 设置单个 log 消息详细程度 level。 db.setProfilingLevel() 修改数据库概要分析的当前 level。 db.shutdownServer() 干净安全地关闭当前的mongod或mongos process。 db.stats() 返回报告当前数据库的 state 的文档。 db.version() 返回mongod实例的 version。 查询计划缓存 名称 描述 db.collection.getPlanCache() 返回一个接口，用于访问集合的查询计划缓存 object 和关联的 PlanCache 方法。 PlanCache.clear() 清除集合的所有缓存查询计划。可通过特定集合的计划缓存 object 访问，即：db.collection.getPlanCache().clear()。 PlanCache.clearPlansByQuery() 清除指定查询形状的缓存查询计划。可通过特定集合的计划缓存 object 访问，即：db.collection.getPlanCache().clearPlansByQuery() PlanCache.getPlansByQuery() 显示指定查询形状的缓存查询计划。可通过特定集合的计划缓存 object 访问，即：db.collection.getPlanCache().getPlansByQuery()。 PlanCache.help() 显示集合的查询计划缓存可用的方法。可通过特定集合的计划缓存 object 访问，即：db.collection.getPlanCache().help()。 PlanCache.listQueryShapes() 显示存在缓存查询计划的查询形状。可通过特定集合的计划缓存 object 访问，即：db.collection.getPlanCache().listQueryShapes()。 批量写入操作 名称 描述 db.collection.initializeOrderedBulkOp() 为有序的操作列表初始化Bulk()操作构建器。 db.collection.initializeUnorderedBulkOp() 为无序的操作列表初始化Bulk()操作构建器。 Bulk() 批量运营建设者。 Bulk.execute() 批量执行操作列表。 Bulk.find() 指定更新或删除操作的查询条件。 Bulk.find.arrayFilters() 指定用于确定要为update或updateOne操作更新 array 的哪些元素的过滤器。 Bulk.find.collation() 指定查询条件的整理。 Bulk.find.remove() 将多个文档删除操作添加到操作列表中。 Bulk.find.removeOne() 将单个文档删除操作添加到操作列表。 Bulk.find.replaceOne() 将单个文档替换操作添加到操作列表中。 Bulk.find.updateOne() 将单个文档更新操作添加到操作列表。 Bulk.find.update() 将multi更新操作添加到操作列表中。 Bulk.find.upsert() 为更新操作指定upsert: true。 Bulk.getOperations() 返回Bulk() operations object 中执行的写操作的 array。 Bulk.insert() 将 Insert 操作添加到操作列表中。 Bulk.tojson() 返回一个 JSON 文档，其中包含Bulk() operations object 中的操作数和批处理数。 Bulk.toString() 将Bulk.tojson()结果作为 string 返回。 用户管理 名称 描述 db.auth() 将用户验证到数据库。 db.changeUserPassword() 更改现有用户的密码。 db.createUser() 创建一个新用户。 db.dropUser() 删除单个用户。 db.dropAllUsers() 删除与数据库关联的所有用户。 db.getUser() 返回有关指定用户的信息。 db.getUsers() 返回有关与数据库关联的所有用户的信息。 db.grantRolesToUser() 向用户授予角色及其权限。 db.removeUser() 已过时。从数据库中删除用户。 db.revokeRolesFromUser() 从用户中删除角色。 db.updateUser() 更新用户数据。 角色管理 名称 描述 db.createRole() 创建角色并指定其权限。 db.dropRole() 删除 user-defined 角色。 db.dropAllRoles() 删除与数据库关联的所有 user-defined 角色。 db.getRole() 返回指定角色的信息。 db.getRoles() 返回数据库中所有 user-defined 角色的信息。 db.grantPrivilegesToRole() 为 user-defined 角色分配权限。 db.revokePrivilegesFromRole() 从 user-defined 角色中删除指定的权限。 db.grantRolesToRole() 指定 user-defined 角色从中继承权限的角色。 db.revokeRolesFromRole() 从角色中删除继承的角色。 db.updateRole() 更新 user-defined 角色。 复制 名称 描述 rs.add() 将成员添加到副本集。 rs.addArb() 将仲裁者添加到副本集。 rs.conf() 返回副本集 configuration 文档。 rs.freeze() 阻止当前成员在 time 期间寻求选举。 rs.help() 返回副本集函数的基本帮助文本。 rs.initiate() 初始化新的副本集。 rs.printReplicationInfo() 从主数据库的角度打印副本集状态的报告。 rs.printSlaveReplicationInfo() 从辅助节点的角度打印副本集状态的报告。 rs.reconfig() Re-configures 通过应用新副本集 configuration object 设置副本。 rs.remove() 从副本集中删除成员。 rs.slaveOk() 为当前连接设置slaveOk property。已过时。使用readPref()和Mongo.setReadPref()设置阅读偏好。 rs.status() 返回包含有关副本集的 state 的信息的文档。 rs.stepDown() 导致当前主成为强制选举的辅助。 rs.syncFrom() 设置此副本集成员将同步的成员，覆盖默认同步目标选择逻辑。 分片 名称 描述 sh.addShard() 将碎片添加到分片 cluster。 sh.addShardTag() 在 MongoDB 3.4 中，此方法别名为sh.addShardToZone()。 sh.addShardToZone() 将碎片与 zone 关联。支持在分片群集中配置zones。 sh.addTagRange() 在 MongoDB 3.4 中，此方法别名为sh.updateZoneKeyRange()。 sh.disableBalancing() 禁用分片数据库中单个集合的平衡。不影响分片 cluster 中其他集合的平衡。 sh.enableBalancing() 如果以前使用sh.disableBalancing()禁用，则激活分片收集平衡器 process。 sh.disableAutoSplit() 禁用分片 cluster 的 auto-splitting。 sh.enableAutoSplit() 为分片 cluster 启用 auto-splitting。 sh.enableSharding() 在特定数据库上启用分片。 sh.getBalancerHost() 从 MongoDB 3.4 开始不推荐使用 sh.getBalancerState() 返回 boolean 以报告当前是否启用了平衡器。 sh.removeTagRange() 在 MongoDB 3.4 中，此方法别名为sh.removeRangeFromZone()。 sh.removeRangeFromZone() 删除一系列分片键和 zone 之间的关联。支持在分片群集中配置zones。 sh.help() 返回sh方法的帮助文本。 sh.isBalancerRunning() 返回 boolean 以报告 balancer process 当前是否正在迁移块。 sh.moveChunk() 在分片 cluster中迁移块。 sh.removeShardTag() 在 MongoDB 3.4 中，此方法别名为sh.removeShardFromZone()。 sh.removeShardFromZone() 删除分片和 zone 之间的关联。用于管理zone 分片。 sh.setBalancerState() 启用或禁用在碎片之间迁移块的平衡器。 sh.shardCollection() 为集合启用分片。 sh.splitAt() 使用碎片 key的特定值作为分割点将现有的块分成两个块。 sh.splitFind() 将包含与查询匹配的文档的现有块划分为两个近似相等的块。 sh.startBalancer() 启用平衡器并等待平衡启动。 sh.status() 报告分片 cluster的状态，如db.printShardingStatus()。 sh.stopBalancer() 禁用平衡器并等待任何正在进行的平衡轮完成。 sh.waitForBalancer() 内部。等待平衡器 state 改变。 sh.waitForBalancerOff() 内部。等到平衡器停止运行。 sh.waitForPingChange() 内部。等待从分片 cluster 中的mongos之一更改 ping state。 sh.updateZoneKeyRange() 将一系列分片键与 zone 关联。支持在分片群集中配置zones。 Free监控 名称 描述 db.enableFreeMonitoring() 在运行时启用Free监控。 db.disableFreeMonitoring() 在运行时禁用Free监控。 db.getFreeMonitoringStatus() 返回空闲监视状态。 构造函数 名称 描述 BulkWriteResult() Wrapper 来自Bulk.execute()的结果集。 Date() 创建 date object。默认情况下，创建包含当前 date 的 date object。 ObjectId() 返回ObjectId。 ObjectId.getTimestamp() 返回ObjectId的时间戳部分。 ObjectId.toString() 显示ObjectId的 string 表示。 ObjectId.valueOf() 将 ObjectId 的str属性显示为十六进制 string。 UUID() 将 32-byte 十六进制 string 转换为 UUID BSON 子类型。 WriteResult() Wrapper 来自 write 方法的结果集。 WriteResult.hasWriteError() 返回一个 boolean，指定结果是否包含WriteResult.writeError。 WriteResult.hasWriteConcernError() 返回一个 boolean，指定结果是否包含WriteResult.writeConcernError。 连接 名称 描述 connect() 连接到 MongoDB 实例和该实例上的指定数据库。 Mongo() 创建一个新连接 object。 Mongo.getDB() 返回数据库 object。 Mongo.getReadPrefMode() 返回 MongoDB 连接的当前读取首选项模式。 Mongo.getReadPrefTagSet() 返回 MongoDB 连接的读取首选项标记集。 Mongo.isCausalConsistency() 指示是否在连接 object 上启用了因果一致性。 Mongo.setCausalConsistency() 启用或禁用连接 object 上的因果一致性。 Mongo.setReadPref() 为 MongoDB 连接设置阅读偏好。 Mongo.setSlaveOk() 允许当前连接上的操作从次要成员读取。 Mongo.startSession() 在连接 object 上启动 session。 session session object。 SessionOptions 选项 object 为 session。 本机 名称 描述 cat() 返回指定文件的内容。 cd() 将当前工作目录更改为指定的路径。 copyDbpath() 复制本地DBPATH。供内部使用。 fuzzFile() 供内部使用以支持测试。 getHostName() 返回系统的主机名运行mongo shell。 getMemInfo() 返回报告 shell 使用的 memory 数量的文档。 hostname() 返回系统的主机名运行 shell。 listFiles() 返回给出目录中每个 object 的 name 和大小的文档的 array。 load() 在 shell 中加载并运行 JavaScript 文件。 ls() 返回当前目录中 files 的列表。 md5sumFile() 指定文件的MD5哈希值。 mkdir() 在指定的路径创建目录。 pwd() 返回当前目录。 quit() 退出当前的 shell session。 removeFile() 从本地文件系统中删除指定的文件。 resetDbpath() 删除本地DBPATH。供内部使用。 sleep() 在给定的 time 期间暂停mongo shell。 setVerboseShell() 配置mongo shell 以报告操作时间。 version() 返回mongo shell 实例的当前 version。 _isWindows() 如果 shell 在 Windows 系统上运行，则返回true; false如果是 Unix 或 Linux 系统。 _rand() 返回0和1之间的随机数。 _srand() 供内部使用。 客户端字段级加密 注意 该mongo客户端的字段级的加密方法需要与客户端的字段级加密的数据库连接启用。如果当前数据库连接不是在启用客户端字段级加密的情况下启动的，则可以： 使用shell程序中的Mongo()构造函数mongo与所需的客户端字段级加密选项建立连接。该Mongo()方法同时支持Amazon Web Services和本地密钥管理服务（KMS）提供程序以进行客户主密钥（CMK）管理。 要么 使用mongoshell 命令行选项与所需选项建立连接。命令行选项仅支持AWS KMS提供程序进行CMK管理。 名称 描述 getKeyVault() 返回当前MongoDB连接的密钥保险库对象。 KeyVault.createKey() 创建用于客户端字段级加密的数据加密密钥。 KeyVault.deleteKey() 从密钥库中删除指定的数据加密密钥。 KeyVault.getKey() 从密钥库中检索指定的数据加密密钥。 KeyVault.getKeys() 检索密钥库中的所有密钥。 KeyVault.addKeyAlternateName() 将密钥替代名称与指定的数据加密密钥相关联。 KeyVault.removeKeyAlternateName() 从指定的数据加密密钥中删除密钥替代名称。 KeyVault.getKeyByAltName() 检索具有指定键替代名称的键。 getClientEncryption() 返回用于支持字段的显式加密/解密的客户端加密对象。 ClientEncryption.encrypt() 使用指定的数据加密密钥和加密算法对字段进行加密。 ClientEncryption.decrypt() 使用关联的数据加密密钥和加密算法解密字段。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods.html","title":"Collection Methods","keywords":"","body":" mongo Shell 方法 注意 有关特定方法(包括语法和示例)的详细信息，请单击特定方法以转到其 reference 页面。 名称 描述 db.collection.aggregate() 提供对聚合管道的访问。 db.collection.bulkWrite() 提供批量写入操作功能。 db.collection.copyTo() 已过时。包装EVAL以在单个 MongoDB 实例中的集合之间复制数据。 db.collection.count() 包装计数以_return 计算集合或视图中的文档数。 db.collection.createIndex() 在集合上构建索引。 db.collection.createIndexes() 在集合上构建一个或多个索引。 db.collection.dataSize() 返回集合的大小。包装collStats输出中的尺寸字段。 db.collection.deleteOne() 删除集合中的单个文档。 db.collection.deleteMany() 删除集合中的多个文档。 db.collection.distinct() 返回具有指定字段的不同值的文档的 array。 db.collection.drop() 从数据库中删除指定的集合。 db.collection.dropIndex() 删除集合上的指定索引。 db.collection.dropIndexes() 删除集合上的所有索引。 db.collection.ensureIndex() 已过时。使用db.collection.createIndex()。 db.collection.explain() 返回有关各种方法的查询执行的信息。 db.collection.find() 对集合或视图执行查询并返回游标 object。 db.collection.findAndModify() 以原子方式修改并返回单个文档。 db.collection.findOne() 执行查询并返回单个文档。 db.collection.findOneAndDelete() 查找单个文档并将其删除。 db.collection.findOneAndReplace() 查找单个文档并替换它。 db.collection.findOneAndUpdate() 查找单个文档并进行更新。 db.collection.getIndexes() 返回描述集合上现有索引的文档的 array。 db.collection.getShardDistribution() 对于分片群集中的集合，db.collection.getShardDistribution()报告块分布的数据。 db.collection.getShardVersion() 分片 cluster 的内部诊断方法。 db.collection.group() 已过时。提供简单的数据聚合 function。通过 key 对集合中的文档进行分组，并处理结果。使用aggregate()进行更复杂的数据聚合。 db.collection.insert() 在集合中创建新文档。 db.collection.insertOne() 在集合中插入新文档。 db.collection.insertMany() 在集合中插入几个新文档。 db.collection.isCapped() 报告集合是否为上限集合。 db.collection.latencyStats() 返回集合的延迟统计信息。 db.collection.mapReduce() 执行 map-reduce 样式数据聚合。 db.collection.reIndex() 重建集合上的所有现有索引。 db.collection.remove() 从集合中删除文档。 db.collection.renameCollection() 更改集合的 name。 db.collection.replaceOne() 替换集合中的单个文档。 db.collection.save() 在insert()和update()周围提供 wrapper 以插入新文档。 db.collection.stats() 报告集合的 state。在collStats周围提供 wrapper。 db.collection.storageSize() 报告集合使用的总大小(以字节为单位)。在collStats输出的storageSize字段周围提供 wrapper。 db.collection.totalIndexSize() 报告集合上索引使用的总大小。在collStats输出的totalIndexSize字段周围提供 wrapper。 db.collection.totalSize() 报告集合的总大小，包括所有文档的大小和集合上的所有索引。 db.collection.update() 修改集合中的文档。 db.collection.updateOne() 修改集合中的单个文档。 db.collection.updateMany() 修改集合中的多个文档。 db.collection.watch() 在集合上建立变更流。 db.collection.validate() 对集合执行诊断操作。 db.collection.countDocuments() $group包装聚合阶段用$sum表达式，以返回集合或视图中文档数量的计数。 db.collection.estimatedDocumentCount() 包装count以返回集合或视图中文档的大概数量。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-aggregate.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-aggregate.html","title":"db.collection.aggregate()","keywords":"","body":" db.collection.aggregate（） 在本页面 定义 行为 例子 定义 db.collection. aggregate(管道，选项) 计算集合中数据的聚合值或视图。 参数 类型 描述 pipeline array 一系列数据聚合操作或阶段。有关详细信息，请参阅聚合管道运算符。 在 version 2.6 中更改：该方法仍然可以接受管道阶段作为单独的 arguments 而不是 array 中的元素;但是，如果未将pipeline指定为 array，则无法指定options参数。 options document 可选的。 aggregate()传递给aggregate命令的其他选项。 version 2.6 中的新内容：仅当您将pipeline指定为 array 时才可用。 options文档可以包含以下字段和值： 字段 类型 描述 explain boolean 可选的。指定 return 有关管道处理的信息。有关 example，请参见返回有关聚合管道操作的信息。version 2.6 中的新内容。在多文档交易中不可用。 allowDiskUse boolean 可选的。允许写入临时文件。设置为时 true，大多数聚合操作可以将数据写入_tmp目录中的 dbPath子目录，但以下情况除外：$graphLookup]阶段$addToSet该$group阶段中使用的累加器表达式 （从4.2.3、4.0.14、3.6.17版本开始）$push该$group阶段中使用的累加器表达式 （从4.2.3、4.0.14、3.6.17版本开始）有关allowDiskUse的示例，请参见 使用外部排序执行大型排序操作。从MongoDB 4.2开始，事件探查器日志消息和诊断日志消息包括一个usedDisk 指示符，指示是否有任何聚合阶段由于内存限制而将数据写入临时文件。 cursor document 可选的。指定游标的初始批处理大小。 cursor字段的 value 是一个带有batchSize字段的文档。有关语法和 example，请参阅指定初始批量大小。 version 2.6 中的新内容。 maxTimeMS non-negative integer 可选的。指定处理游标操作的 time 限制(以毫秒为单位)。如果没有为 maxTimeMS 指定 value，则操作不会 timeout。 0的 value 显式指定默认的无界行为。 MongoDB 使用与db.killOp()相同的机制终止超出其分配的 time 限制的操作。 MongoDB 仅在其指定的中断点之一处终止操作。 bypassDocumentValidation boolean 可选的。仅在指定$out或$merge]聚合阶段时可用。 在操作期间启用db.collection.aggregate以绕过文档验证。这使您可以插入不符合验证要求的文档。 version 3.2 中的新内容。 readConcern document 可选的。指定读关注。 readConcern 选项具有以下语法：在 version 3.6 中更改。 readConcern: { level: } 可能的阅读关注级别为： “local”。这是 level 的默认读取问题。 “available”。当阅读操作和 Causally Consistent Sessions和“level”未指定时，这是对二级的读取的默认值。查询返回实例的最新数据。 “manority”。适用于使用WiredTiger 存储引擎的副本集。 “linerizable”。仅适用于主的读取操作。 有关读取关注级别的更多信息，请参阅读关注级别。 从MongoDB 4.2开始，该$out阶段不能与读取关注一起使用\"linearizable\"。也就是说，如果您为指定了\"linearizable\"读取关注 db.collection.aggregate()，则不能将$out阶段包括 在管道中。该$merge阶段不能与已关注的内容一起使用\"linearizable\"。也就是说，如果您为指定了 \"linearizable\"读取关注 db.collection.aggregate()，则不能将$merge阶段包括 在管道中。 collation document 可选的。 指定要用于操作的整理。 整理允许用户为 string 比较指定 language-specific 规则，例如字母和重音标记的规则。 排序规则选项具有以下语法：排序规则：{ locale：， caseLevel：， caseFirst：， strength：， numericOrdering：， alternate：， maxVariable：， backwards ： } 指定排序规则时，locale字段是必填字段;所有其他校对字段都是可选的。有关字段的说明，请参阅整理文件。 如果未指定排序规则但集合具有默认排序规则(请参阅db.createCollection()，则操作将使用为集合指定的排序规则。 如果没有为集合或操作指定排序规则，MongoDB 使用先前版本中用于 string 比较的简单二进制比较。 您无法为操作指定多个排序规则。对于 example，您不能为每个字段指定不同的排序规则，或者如果使用排序执行查找，则不能对查找使用一个排序规则，而对排序使用另一个排序规则。 version 3.4 中的新内容。 hint string or document 可选的。用于聚合的索引。索引位于初始 collection/view，聚合为 run。 通过索引 name 或索引规范文档指定索引。 注意 hint不适用于$lookup和$graphLookup阶段。 version 3.6 中的新内容。 comment string 可选的。用户可以指定任意 string 以帮助通过数据库探查器，currentOp 和日志跟踪操作。 version 3.6 中的新内容。 writeConcern document 可选的。表示 与or 阶段一起使用的[写关注点](的文档。$out $merge忽略对$outor $merge阶段使用默认的写关注。 返回值： 一个游标通过聚合管道操作的最后阶段产生的文件，或者包括 explain选项，提供了聚合操作的处理细节的文件。如果管道包含$out运算符，则 aggregate()返回一个空游标。请参阅 $out以获取更多信息。 行为 错误处理 如果发生错误，aggregate()帮助程序将抛出 exception。 游标行为 在mongo shell 中，如果从db.collection.aggregate()返回的游标未使用var关键字分配给变量，则mongo shell 会自动迭代光标 20 次。请参阅在 mongo Shell 中迭代一个 Cursor以处理mongo shell 中的游标。 从聚合返回的游标仅支持对已评估的游标(已检索其第一批的，即：游标)进行操作的游标方法，例如以下方法： cursor.hasNext()cursor.next()cursor.toArray()cursor.forEach() cursor.map()cursor.objsLeftInBatch()cursor.itcount()cursor.pretty() 也可以看看 有关更多信息，请参阅聚合管道，聚合参考，聚合管道限制和聚合。 会话 版本4.0中的新功能。 对于在会话内创建的游标，不能在getMore会话外调用 。 同样，对于在会话外部创建的游标，不能在getMore会话内部调用 。 会话空闲超时 从MongoDB 3.6开始，MongoDB驱动程序和mongoshell程序将所有操作与服务器会话相关联，但未确认的写操作除外。对于未与会话明确关联的操作（即使用Mongo.startSession()），MongoDB驱动程序和mongoshell程序会创建一个隐式会话并将其与该操作相关联。 如果会话空闲时间超过30分钟，则MongoDB服务器会将会话标记为已过期，并可以随时关闭它。当MongoDB服务器关闭会话时，它还会终止所有正在进行的操作并打开与该会话关联的游标。这包括配置了30分钟noCursorTimeout或maxTimeMS30分钟以上的光标。 对于返回游标的操作，如果游标可能闲置了30分钟以上，请在显式会话中使用发出操作，Session.startSession()并使用refreshSessions命令定期刷新该会话。请参阅 以获取更多信息。Session Idle Timeout 事务 db.collection.aggregate()可以在多文档事务中使用。 但是，事务中不允许以下阶段： $collStats $currentOp $indexStats $listLocalSessions $listSessions $out $merge $planCacheStats 您也不能指定该explain选项。 对于在事务外部创建的游标，不能getMore在事务内部调用 。 对于在事务中创建的游标，不能getMore在事务外部调用 。 重要 在大多数情况下，与单文档写入相比，多文档事务产生的性能成本更高，并且多文档事务的可用性不应替代有效的架构设计。在许多情况下， 非规范化数据模型（嵌入式文档和数组）将继续是您的数据和用例的最佳选择。也就是说，在许多情况下，适当地对数据建模将最大程度地减少对多文档交易的需求。 有关其他事务使用方面的注意事项（例如运行时限制和操作日志大小限制），另请参见 生产注意事项。 客户端断开 对于db.collection.aggregate()不包含$out或$merge阶段的操作： 从MongoDB 4.2开始，如果发出db.collection.aggregate()断开连接的客户端在操作完成之前断开连接，则MongoDB将标记db.collection.aggregate()为终止（即在操作上killOp）。 例子 以下示例使用包含以下文档的集合orders： { _id: 1, cust_id: \"abc1\", ord_date: ISODate(\"2012-11-02T17:04:11.102Z\"), status: \"A\", amount: 50 } { _id: 2, cust_id: \"xyz1\", ord_date: ISODate(\"2013-10-01T17:04:11.102Z\"), status: \"A\", amount: 100 } { _id: 3, cust_id: \"xyz1\", ord_date: ISODate(\"2013-10-12T17:04:11.102Z\"), status: \"D\", amount: 25 } { _id: 4, cust_id: \"xyz1\", ord_date: ISODate(\"2013-10-11T17:04:11.102Z\"), status: \"D\", amount: 125 } { _id: 5, cust_id: \"abc1\", ord_date: ISODate(\"2013-11-12T17:04:11.102Z\"), status: \"A\", amount: 25 } 分组和计算总和 以下聚合操作选择状态等于\"A\"的文档，按cust_id字段对匹配文档进行分组，并从amount字段的总和计算每个cust_id字段的total，并按降序 order 中的total字段对结果进行排序： db.orders.aggregate([ { $match: { status: \"A\" } }, { $group: { _id: \"$cust_id\", total: { $sum: \"$amount\" } } }, { $sort: { total: -1 } } ]) 该操作返回带有以下文档的游标： { \"_id\" : \"xyz1\", \"total\" : 100 } { \"_id\" : \"abc1\", \"total\" : 75 } mongo shell 自动迭代返回的光标以打印结果。有关在mongo shell 中手动处理游标的信息，请参阅在 mongo Shell 中迭代一个 Cursor。 返回有关聚合管道操作的信息 以下聚合操作将选项explain设置为true以_return 有关聚合操作的信息。 db.orders.aggregate( [ { $match: { status: \"A\" } }, { $group: { _id: \"$cust_id\", total: { $sum: \"$amount\" } } }, { $sort: { total: -1 } } ], { explain: true } ) 该操作返回带有文档的游标，该文档包含有关聚合管道处理的详细信息。例如，除了其他细节之外，文档可以显示所使用的操作的索引(如果有的话)。 [1]如果orders集合是分片集合，则文档还将显示分片和合并操作之间的分工，以及目标查询，目标分片。 注意 explain输出文档的预期 readers 是人类，而不是机器，输出格式可能会在不同版本之间发生变化。 mongo shell 自动迭代返回的光标以打印结果。有关在mongo shell 中手动处理游标的信息，请参阅在 mongo Shell 中迭代一个 Cursor。 [1]索引过滤器会影响所用索引的选择。有关详细信息，请参见索引过滤器。 使用外部排序执行大型排序操作 聚合管道阶段有最大 memory 使用限制。要处理大型数据集，请将allowDiskUse选项设置为true以启用将数据写入临时 files，如下面的示例所示： var results = db.stocks.aggregate( [ { $project : { cusip: 1, date: 1, price: 1, _id: 0 } }, { $sort : { cusip : 1, date: 1 } } ], { allowDiskUse: true } ) 从MongoDB 4.2开始，事件profiler log massages和diagnostic log massages包括一个usedDisk 指示符，指示是否有任何聚合阶段由于内存限制而将数据写入临时文件。 指定初始批量大小 要指定游标的初始批处理大小，请对cursor选项使用以下语法： cursor: { batchSize: } 对于 example，以下聚合操作指定游标的初始批处理大小0： db.orders.aggregate( [ { $match: { status: \"A\" } }, { $group: { _id: \"$cust_id\", total: { $sum: \"$amount\" } } }, { $sort: { total: -1 } }, { $limit: 2 } ], { cursor: { batchSize: 0 } } ) A batchSize 0表示空的第一批，对于快速返回游标或失败消息而不执行重要的 server-side 工作非常有用。与其他 MongoDB 游标一样，将后续批量大小指定为OP_GET_MORE操作。 mongo shell 自动迭代返回的光标以打印结果。有关在mongo shell 中手动处理游标的信息，请参阅在 mongo Shell 中迭代一个 Cursor。 指定排序规则 version 3.4 中的新内容。 整理允许用户为 string 比较指定 language-specific 规则，例如字母和重音标记的规则。 集合myColl具有以下文档： { _id: 1, category: \"café\", status: \"A\" } { _id: 2, category: \"cafe\", status: \"a\" } { _id: 3, category: \"cafE\", status: \"a\" } 以下聚合操作包括整理选项： db.myColl.aggregate( [ { $match: { status: \"A\" } }, { $group: { _id: \"$category\", count: { $sum: 1 } } } ], { collation: { locale: \"fr\", strength: 1 } } ); 注意 如果执行涉及多个视图的聚合(例如$lookup或$graphLookup)，则视图必须具有相同的整理。 有关归类字段的说明，请参阅整理文件。 提示索引 version 3.6 中的新内容。 使用以下文档创建集合foodColl： db.foodColl.insert([ { _id: 1, category: \"cake\", type: \"chocolate\", qty: 10 }, { _id: 2, category: \"cake\", type: \"ice cream\", qty: 25 }, { _id: 3, category: \"pie\", type: \"boston cream\", qty: 20 }, { _id: 4, category: \"pie\", type: \"blueberry\", qty: 15 } ]) 创建以下索引： db.foodColl.createIndex( { qty: 1, type: 1 } ); db.foodColl.createIndex( { qty: 1, category: 1 } ); 以下聚合操作包括强制使用指定索引的hint选项： db.foodColl.aggregate( [ { $sort: { qty: 1 }}, { $match: { category: \"cake\", qty: 10 } }, { $sort: { type: -1 } } ], { hint: { qty: 1, category: 1 } } ) 覆盖 readConcern 使用该readConcern选项可以指定操作的读取关注点。 您不能将$out或$merge阶段与阅读关注结合使用\"linearizable\"。也就是说，如果您为指定了\"linearizable\"读取关注 db.collection.aggregate()，则不能在管道中包括任何一个阶段。 对副本集的以下操作指定“ 读取关注点”，\"majority\"以读取已确认已写入大多数节点的数据的最新副本。 注意 要使用“多数”的阅读关注 level，replica sets 必须使用WiredTiger 存储引擎并选举protocol version 1。从 MongoDB 3.6 开始，默认情况下启用对读取问题“多数”的支持。对于 MongoDB 3.6.1 - 3.6.x，您可以禁用读取关注“多数”。有关更多信息，请参阅禁用阅读关注多数。 要确保单个线程可以读取自己的写入，请对副本集的主要使用“多数”读取关注和“多数”写入问题。 要使用“多数”的阅读关注 level，您不能包含$out阶段。 无论阅读关注 level 如何，节点上的最新数据可能无法反映系统中数据的最新 version。 db.restaurants.aggregate( [ { $match: { rating: { $lt: 5 } } } ], { readConcern: { level: \"majority\" } } ) 指定 Comment 名为movies的集合包含格式如下的文档： { \"_id\" : ObjectId(\"599b3b54b8ffff5d1cd323d8\"), \"title\" : \"Jaws\", \"year\" : 1975, \"imdb\" : \"tt0073195\" } 以下聚合操作查找在 1995 年创建的影片，并包含comment选项以在logs，db.system.profile集合和db.currentOp中提供跟踪信息。 db.movies.aggregate( [ { $match: { year : 1995 } } ], { comment : \"match_all_movies_from_1995\" } ).pretty() 在启用了性能分析的系统上，您可以查询system.profile集合以查看所有最近的类似聚合，如下所示： db.system.profile.find( { \"command.aggregate\": \"movies\", \"command.comment\" : \"match_all_movies_from_1995\" } ).sort( { ts : -1 } ).pretty() 这将以下列格式返回一组探查器结果： { \"op\" : \"command\", \"ns\" : \"video.movies\", \"command\" : { \"aggregate\" : \"movies\", \"pipeline\" : [ { \"$match\" : { \"year\" : 1995 } } ], \"comment\" : \"match_all_movies_from_1995\", \"cursor\" : { }, \"$db\" : \"video\" }, ... } 应用程序可以编码 order 中的任意信息，以便更轻松地跟踪或识别系统中的特定操作。例如，application 可能附加 string comment，其中包含 process ID，线程 ID，client 主机名和发出命令的用户。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-bulkWrite.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-bulkWrite.html","title":"db.collection.bulkWrite()","keywords":"","body":" db.collection.bulkWrite（） 在本页面 定义 行为 例子 定义 db.collection. bulkWrite () version 3.2 中的新内容。 使用 order 执行控件执行多个写操作。 bulkWrite()具有以下语法： db.collection.bulkWrite( [ , , ... ], { writeConcern : , ordered : } ) 参数 类型 描述 operations array bulkWrite()写操作的 array。 有效操作为： insertOne updateOne updateMany deleteOne deleteMany replaceOne 有关每个操作的使用情况，请参阅写操作。 writeConcern document 可选的。表示写关注的文件。省略使用默认写入问题。 ordered boolean 可选的。一个 boolean，指定mongod实例是否应执行有序或无序操作执行。默认为true。 参阅执行操作 返回值： 一个布尔值acknowledged，true好像该操作在运行时带有 写关注点，或者false禁用了写关注点。 每个写入操作的计数。 一个数组，其中包含_id每个成功插入或插入的文档的。 行为 bulkWrite()采用 array 写操作并执行每个操作。默认情况下，操作在 order 中执行。请参阅执行操作以控制写操作执行的 order。 写操作 insertOne 将单个文档插入集合中。 见db.collection.insertOne()。 db.collection.bulkWrite( [ { insertOne : { \"document\" : } } ] ) updateOne 和 updateMany 更改 version 3.6：updateOne和updateMany操作添加了对arrayFilters参数的支持，该参数确定要在 array 字段中修改哪些元素。有关详细信息，请参阅db.collection.updateOne()和db.collection.updateMany()。 已更改 version 3.4：添加对整理的支持。有关详细信息，请参阅db.collection.updateOne()和db.collection.updateMany() updateOne更新集合中与过滤器匹配的单个文档。如果多个文档 match，updateOne将仅更新第一个匹配的文档。见db.collection.updateOne()。 db.collection.bulkWrite( [ { updateOne : { \"filter\" : , \"update\" : , \"upsert\" : , \"collation\": , \"arrayFilters\": [ , ... ] } } ] ) updateMany更新集合中匹配过滤器的所有文档。见db.collection.updateMany()。 db.collection.bulkWrite( [ { updateMany : { \"filter\" : , \"update\" : , \"upsert\" : , \"collation\": , \"arrayFilters\": [ , ... ] } } ] ) 字段 描述 filter 更新的选择标准。提供与 方法中相同的查询选择器db.collection.find()。 update 要执行的更新操作。可以指定：仅包含更新运算符表达式的文档。一个聚合管道 ，指定要执行的修改。[ , , ... ] upsert 可选的。一个布尔值，指示是否执行upsert。默认情况下upsert为false。 arrayFilters 可选的。筛选器文档数组，用于确定要对数组字段进行更新操作要修改的数组元素。 collation 可选的。指定用于操作的排序规则。 hint 可选的。用于支持更新的索引filter。如果指定的索引不存在，则操作错误。4.2.1版中的新功能。 有关详细信息，请参见db.collection.updateOne()和 db.collection.updateMany()。 replaceOne replaceOne替换与过滤器匹配的集合中的单个文档。如果多个文档 match，replaceOne将仅替换第一个匹配的文档。 db.collection.bulkWrite([ { replaceOne : { \"filter\" : , \"replacement\" : , \"upsert\" : } } ] ) 字段 描述 filter 替换操作的选择标准。提供与 方法中相同的 查询选择器db.collection.find()。 replacement 替换文件。该文档不能包含 更新运算符。 upsert 可选的。一个布尔值，指示是否执行upsert。默认情况下upsert为false。 collation 可选的。指定用于操作的排序规则。 hint 可选的。用于支持更新的索引filter。如果指定的索引不存在，则操作错误。4.2.1版中的新功能。 有关详细信息，请参见db.collection.replaceOne()。 deleteOne 和 deleteMany deleteOne删除集合中的一个文件 match 过滤器。如果多个文档 match，deleteOne将仅删除第一个匹配的文档。见db.collection.deleteOne()。 db.collection.bulkWrite([ { deleteOne : { \"filter\" : } } ] ) deleteMany删除集合中匹配过滤器的所有文档。见db.collection.deleteMany()。 db.collection.bulkWrite([ { deleteMany : { \"filter\" : } } ] ) 字段 描述 filter 删除操作的选择标准。提供与 方法中相同的 查询选择器db.collection.find()。 collation 可选的。指定用于操作的排序规则。 有关详细信息，请参见db.collection.deleteOne()和 db.collection.deleteMany()。 _id 字段 如果文档未指定_id字段，则mongod添加_id字段并在插入或插入文档之前为文档指定唯一的ObjectId。大多数驱动程序创建一个 ObjectId 并插入_id字段，但如果驱动程序或 application 没有，mongod将创建并填充_id。 如果文档包含_id字段，则_id value 在集合中必须是唯一的，以避免重复的 key 错误。 更新或替换操作不能指定与原始文档不同的_id value。 执行操作 ordered参数指定bulkWrite()是否将在 order 中执行操作。默认情况下，操作在 order 中执行。 以下 code 表示带有五个操作的bulkWrite()。 db.collection.bulkWrite( [ { insertOne : }, { updateOne : }, { updateMany : }, { replaceOne : }, { deleteOne : }, { deleteMany : } ] ) 在默认的ordered : true state 中，每个操作都将在 order 中执行，从第一个操作insertOne到最后一个操作deleteMany。 如果ordered设置为 false，则mongod可以重新排序操作以增加 performance。 Applications 不应该依赖于 order 操作执行。 以下 code 表示无序bulkWrite()，包含六个操作： db.collection.bulkWrite( [ { insertOne : }, { updateOne : }, { updateMany : }, { replaceOne : }, { deleteOne : }, { deleteMany : } ], { ordered : false } ) 使用ordered : false时，操作结果可能会有所不同。对于 example，deleteOne或deleteMany可能会删除更多或更少的文档，具体取决于insertOne，updateOne，updateMany或replaceOne操作之前或之后的 run。 每个 group 中的操作数不能超过数据库maxWriteBatchSize的 value。从 MongoDB 3.6 开始，这个 value 是100,000。此值显示在isMaster.maxWriteBatchSize字段中。 此限制可防止出现超大错误消息的问题。如果 group 超过此limit，则 client 驱动程序将 group 分成较小的组，其计数小于或等于限制的 value。例如，对于100,000的maxWriteBatchSize value，如果队列包含200,000操作，则驱动程序将创建 2 个组，每个组具有100,000个操作。 注意 使用 high-level API 时，驱动程序仅将 group 分为较小的组。如果直接使用db.runCommand()(对于 example，在编写驱动程序时)，MongoDB 在尝试执行超出限制的写入批处理时会抛出错误。 从 MongoDB 3.6 开始，一旦单个批处理的错误报告变得太大，MongoDB 会将所有剩余的错误消息截断为空的 string。目前，一旦至少有 2 个错误消息，总大小大于1MB，则开始。 尺寸和分组机械是内部性能细节，在将来的版本中可能会有所变化。 在分片集合上执行有序操作列表通常比执行无序列表慢，因为对于有序列表，每个操作必须等待上一个操作完成。 上限收藏 bulkWrite()写操作在上限集合上使用时有限制。 如果update条件增加了要修改的文档的大小，则updateOne和updateMany抛出WriteError。 如果replacement文档的大小比原始文档大，则replaceOne抛出WriteError。 如果在上限集合中使用deleteOne和deleteMany则抛出WriteError。 错误处理 bulkWrite()会在错误上抛出BulkWriteError exception。 排除写关注错误，有序操作在发生错误后停止，而无序操作继续处理队列中任何剩余的写操作。 写入关注错误显示在writeConcernErrors字段中，而所有其他错误显示在writeErrors字段中。如果遇到错误，则显示成功写入操作的数量而不是插入的_id值。有序操作显示遇到的单个错误，而无序操作显示 array 中的每个错误。 事务 db.collection.bulkWrite()可以在多文档事务中使用。 如果在事务中运行，则集合必须已经存在才能进行插入和操作。upsert: true 如果在事务中运行，请不要为操作明确设置写关注点。要对事务使用写关注，请参见 事务和写关注。 重要 在大多数情况下，与单文档写入相比，多文档事务产生的性能成本更高，并且多文档事务的可用性不应替代有效的架构设计。在许多情况下， 非规范化数据模型（嵌入式文档和数组）将继续是您的数据和用例的最佳选择。也就是说，在许多情况下，适当地对数据建模将最大程度地减少对多文档交易的需求。 有关其他事务使用方面的注意事项（例如运行时限制和操作日志大小限制），另请参见 生产注意事项。 事务里面的错误处理 从MongoDB 4.2开始，如果db.collection.bulkWrite()操作在事务内部遇到错误，则该方法将引发BulkWriteException（与事务外部相同）。 在4.0中，如果bulkWrite操作在事务内部遇到错误，则抛出的错误不会包装为 BulkWriteException。 在事务内部，即使批量写入是无序的，批量写入中的第一个错误也会导致整个批量写入失败并中止事务。 例子 批量写操作 guidebook数据库中的characters集合包含以下文档： { \"_id\" : 1, \"char\" : \"Brisbane\", \"class\" : \"monk\", \"lvl\" : 4 }, { \"_id\" : 2, \"char\" : \"Eldon\", \"class\" : \"alchemist\", \"lvl\" : 3 }, { \"_id\" : 3, \"char\" : \"Meldane\", \"class\" : \"ranger\", \"lvl\" : 3 } 以下bulkWrite()对集合执行多个操作： try { db.characters.bulkWrite([ { insertOne: { \"document\": { \"_id\": 4, \"char\": \"Dithras\", \"class\": \"barbarian\", \"lvl\": 4 } } }, { insertOne: { \"document\": { \"_id\": 5, \"char\": \"Taeln\", \"class\": \"fighter\", \"lvl\": 3 } } }, { updateOne : { \"filter\" : { \"char\" : \"Eldon\" }, \"update\" : { $set : { \"status\" : \"Critical Injury\" } } } }, { deleteOne : { \"filter\" : { \"char\" : \"Brisbane\"} } }, { replaceOne : { \"filter\" : { \"char\" : \"Meldane\" }, \"replacement\" : { \"char\" : \"Tanys\", \"class\" : \"oracle\", \"lvl\": 4 } } } ]); } catch (e) { print(e); } 该操作返回以下内容： { \"acknowledged\" : true, \"deletedCount\" : 1, \"insertedCount\" : 2, \"matchedCount\" : 2, \"upsertedCount\" : 0, \"insertedIds\" : { \"0\" : 4, \"1\" : 5 }, \"upsertedIds\" : { } } 如果集合在执行批量写入之前包含带有\"_id\" : 5\"的文档，则在执行批量写入时，将为第二个 insertOne 抛出以下重复的 key exception： BulkWriteError({ \"writeErrors\" : [ { \"index\" : 1, \"code\" : 11000, \"errmsg\" : \"E11000 duplicate key error collection: guidebook.characters index: _id_ dup key: { : 5.0 }\", \"op\" : { \"_id\" : 5, \"char\" : \"Taeln\", \"class\" : \"fighter\", \"lvl\" : 3 } } ], \"writeConcernErrors\" : [ ], \"nInserted\" : 1, \"nUpserted\" : 0, \"nMatched\" : 0, \"nModified\" : 0, \"nRemoved\" : 0, \"upserted\" : [ ] }) 由于ordered默认为 true，因此只有第一个操作成功完成。 rest 未执行。 尽管出现错误，使用ordered : false运行bulkWrite()将允许剩余的操作完成。 无序批量写入 guidebook数据库中的characters集合包含以下文档： { \"_id\" : 1, \"char\" : \"Brisbane\", \"class\" : \"monk\", \"lvl\" : 4 }, { \"_id\" : 2, \"char\" : \"Eldon\", \"class\" : \"alchemist\", \"lvl\" : 3 }, { \"_id\" : 3, \"char\" : \"Meldane\", \"class\" : \"ranger\", \"lvl\" : 3 } 以下bulkWrite()对characters集合执行多个unordered操作。请注意，其中一个insertOne阶段具有重复的_id value： try { db.characters.bulkWrite([ { insertOne: { \"document\": { \"_id\": 4, \"char\": \"Dithras\", \"class\": \"barbarian\", \"lvl\": 4 } } }, { insertOne: { \"document\": { \"_id\": 4, \"char\": \"Taeln\", \"class\": \"fighter\", \"lvl\": 3 } } }, { updateOne : { \"filter\" : { \"char\" : \"Eldon\" }, \"update\" : { $set : { \"status\" : \"Critical Injury\" } } } }, { deleteOne : { \"filter\" : { \"char\" : \"Brisbane\"} } }, { replaceOne : { \"filter\" : { \"char\" : \"Meldane\" }, \"replacement\" : { \"char\" : \"Tanys\", \"class\" : \"oracle\", \"lvl\": 4 } } } ], { ordered : false } ); } catch (e) { print(e); } 该操作返回以下内容： BulkWriteError({ \"writeErrors\" : [ { \"index\" : 1, \"code\" : 11000, \"errmsg\" : \"E11000 duplicate key error collection: guidebook.characters index: _id_ dup key: { : 4.0 }\", \"op\" : { \"_id\" : 4, \"char\" : \"Taeln\", \"class\" : \"fighter\", \"lvl\" : 3 } } ], \"writeConcernErrors\" : [ ], \"nInserted\" : 1, \"nUpserted\" : 0, \"nMatched\" : 2, \"nModified\" : 2, \"nRemoved\" : 1, \"upserted\" : [ ] }) 由于这是unordered操作，因此尽管存在 exception，仍会处理队列中剩余的写入。 批量写与写关注 enemies集合包含以下文档： { \"_id\" : 1, \"char\" : \"goblin\", \"rating\" : 1, \"encounter\" : 0.24 }, { \"_id\" : 2, \"char\" : \"hobgoblin\", \"rating\" : 1.5, \"encounter\" : 0.30 }, { \"_id\" : 3, \"char\" : \"ogre\", \"rating\" : 3, \"encounter\" : 0.2 }, { \"_id\" : 4, \"char\" : \"ogre berserker\" , \"rating\" : 3.5, \"encounter\" : 0.12} 以下bulkWrite()使用\"majority\" value \"majority\"和超时 value 为 100 毫秒对集合执行多个操作： try { db.enemies.bulkWrite( [ { updateMany : { \"filter\" : { \"rating\" : { $gte : 3} }, \"update\" : { $inc : { \"encounter\" : 0.1 } } }, }, { updateMany : { \"filter\" : { \"rating\" : { $lt : 2} }, \"update\" : { $inc : { \"encounter\" : -0.25 } } }, }, { deleteMany : { \"filter\" : { \"encounter\": { $lt : 0 } } } }, { insertOne : { \"document\" : { \"_id\" :5, \"char\" : \"ogrekin\" , \"rating\" : 2, \"encounter\" : 0.31 } } } ], { writeConcern : { w : \"majority\", wtimeout : 100 } } ); } catch (e) { print(e); } 如果副本集中所有必需节点确认写入操作所需的总 time 大于wtimeout，则在wtimeout期间过后将显示以下writeConcernError。 BulkWriteError({ \"writeErrors\" : [ ], \"writeConcernErrors\" : [ { \"code\" : 64, \"codeName\" : \"WriteConcernFailed\", \"errInfo\" : { \"wtimeout\" : true }, \"errmsg\" : \"waiting for replication timed out\" }, { \"code\" : 64, \"codeName\" : \"WriteConcernFailed\", \"errInfo\" : { \"wtimeout\" : true }, \"errmsg\" : \"waiting for replication timed out\" }, { \"code\" : 64, \"codeName\" : \"WriteConcernFailed\", \"errInfo\" : { \"wtimeout\" : true }, \"errmsg\" : \"waiting for replication timed out\" } ], \"nInserted\" : 1, \"nUpserted\" : 0, \"nMatched\" : 4, \"nModified\" : 4, \"nRemoved\" : 1, \"upserted\" : [ ] }) 结果集显示执行的操作，因为writeConcernErrors错误不是任何写操作失败的指示。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-copyTo.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-copyTo.html","title":"db.collection.copyTo()","keywords":"","body":" db.collection.copyTo（） 在本页面 定义 行为 例子 定义 db.collection. copyTo(newCollection) 自 version 3.0 以来已弃用。 使用 server-side JavaScript 将collection中的所有文档复制到newCollection。如果newCollection不存在，MongoDB 会创建它。 如果启用了授权，则必须能够访问 order run db.collection.copyTo()中所有资源的所有操作。建议不要提供此类访问权限，但如果您的组织要求用户 run db.collection.copyTo()，请创建一个在anyResource上授予anyAction的角色。不要将此角色分配给任何其他用户。 参数 类型 描述 newCollection string 要将数据写入的集合的 name。 警告 使用 db.collection.copyTo()检查字段类型时，确保操作不会在从 BSON 转换为 JSON 期间从文档中删除类型信息。 db.collection.copyTo()方法在内部使用EVAL命令。因此，db.collection.copyTo()操作采用 global 锁定，阻止所有其他读取和写入操作，直到db.collection.copyTo()完成。 copyTo()返回复制的文档数。如果复制失败，则抛出 exception。 行为 因为copyTo()在内部使用EVAL，所以复制操作将阻止mongod实例上的所有其他操作。 例子 以下操作将source集合中的所有文档复制到target集合中。 db.source.copyTo(target) Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-count.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-count.html","title":"db.collection.count()","keywords":"","body":" db.collection.count（） 在本页面 定义 行为 例子 定义 db.collection. count(查询，选项) 返回将_查询集合或视图的find()查询的文档计数。 db.collection.count()方法不执行find()操作，而是计算并返回匹配查询的结果数。 注意 与4.0功能兼容的MongoDB驱动程序弃用各自的游标和收集count()的API，取而代之的是新的API countDocuments()和estimatedDocumentCount()。有关给定驱动程序的特定API名称，请参阅驱动程序文档。 重要 避免使用 db.collection.count() 没有查询谓词的方法，因为如果没有查询谓词，该方法将基于集合的元数据返回结果，这可能会导致近似计数。特别是， 在分片群集上，结果计数将无法正确过滤出孤立的文档。 不正常关机后，计数可能不正确。 有关基于集合元数据的计数，另请参阅 带有count选项的collStats管道阶段。 参数 类型 描述 query document 查询选择标准。 options document 可选的。修改计数的额外选项。 options文档包含以下字段： 领域 类型 描述 limit integer 可选的。要计算的最大文档数。 skip integer 可选的。计数前要跳过的文档数。 hint string or document 可选的。查询的索引 name 提示或规范。 version 2.6 中的新内容。 maxTimeMS integer 可选的。允许查询 run 的最大 time 时间。 readConcern string 可选的。指定阅读关注。默认的 level 是“本地”。 要使用阅读关注的阅读关注 level，replica sets 必须使用WiredTiger 存储引擎并选举protocol version 1。 从 MongoDB 3.6 开始，默认情况下启用对读取关注“多数”的支持。对于 MongoDB 3.6.1 - 3.6.x，您可以禁用读取关注“多数”。有关更多信息，请参阅禁用阅读关注多数。 要确保单个线程可以读取自己的写入，请对副本集的主要使用“多数”读取关注和“多数”写入关注。 要使用“多数”的阅读关注 level，必须指定非空query条件。 version 中的新内容 3.2. collation document 可选的。指定 用于操作的排序规则。归类允许用户为字符串比较指定特定于语言的规则，例如字母大写和重音符号的规则。排序规则选项具有以下语法：collation: { locale: , caseLevel: , caseFirst: , strength: , numericOrdering: , alternate: , maxVariable: , backwards: }指定排序规则时，该locale字段为必填字段；所有其他排序规则字段都是可选的。有关字段的说明，请参见整理文档。如果未指定排序规则，但是集合具有默认排序规则（请参阅参考资料db.createCollection()），则该操作将使用为集合指定的排序规则。如果没有为集合或操作指定排序规则，则MongoDB会将以前版本中使用的简单二进制比较用于字符串比较。您不能为一个操作指定多个排序规则。例如，您不能为每个字段指定不同的排序规则，或者如果对排序执行查找，则不能对查找使用一种排序规则，而对排序使用另一种排序规则。3.4版的新功能。 count()等同于db.collection.find(query).count()。 也可以看看 cursor.count() 行为 Sharded Clusters 在分片 cluster 上，如果孤儿文件存在或块迁移正在进行中，db.collection.count()可能导致计数不准确。 要避免这些情况，请在分片 cluster 上使用db.collection.aggregate()方法： 您可以使用$count阶段来计算文档。对于 example，以下操作计算集合中的文档： db.collection.aggregate([ { $count: \"myCount\" } ]) $count阶段等效于以下$group $project序列： db.collection.aggregate( [ { $group: { _id: null, myCount: { $sum: 1 } } }, { $project: { _id: 0 } } ] ) 要获取匹配查询条件的文档计数，还要包括$match阶段： db.collection.aggregate( [ { $match: }, { $count: \"myCount\" } ] ) 或者，如果使用$group + $project等效： db.collection.aggregate( [ { $match: }, { $count: \"myCount\" } ] ) 也可以看看 $collStats返回基于集合的元数据的近似计数。 索引使用 考虑具有以下索引的集合： { a: 1, b: 1 } 执行计数时，如果出现以下情况，MongoDB 可以仅使用索引返回计数： 查询可以使用索引， 查询只包含索引键的条件，和 查询谓词访问单个连续范围的索引键。 对于 example，以下操作可以仅使用索引_return 计数： db.collection.find( { a: 5, b: 5 } ).count() db.collection.find( { a: { $gt: 5 } } ).count() db.collection.find( { a: 5, b: { $gt: 10 } } ).count() 但是，如果查询可以使用索引但查询谓词不访问单个连续范围的索引键，或者查询还包含索引外部字段的条件，那么除了使用索引之外，MongoDB 还必须读取文档要_return 计数。 db.collection.find( { a: 5, b: { $in: [ 1, 2, 3 ] } } ).count() db.collection.find( { a: { $gt: 5 }, b: 5 } ).count() db.collection.find( { a: 5, b: 5, c: 5 } ).count() 在这种情况下，在初始读取文档期间，MongoDB 将文档分页到 memory，以便后续 calls 相同的计数操作将具有更好的 performance。 意外关机后的准确性 使用有线老虎存储引擎不正常关闭mongod后，count()报告的计数统计信息可能不准确。 漂移量取决于在最后检查站和不干净关闭之间执行的 insert，update 或 delete 操作的数量。检查点通常每 60 秒发生一次。但是，使用 non-default --syncdelay设置运行mongod实例可能会有更多或更少的检查点。 在mongod上的每个集合上运行验证以在不正常关闭后恢复正确的统计信息。 注意 这种精度损失仅适用于不包含查询谓词的count()操作。 例子 计算集合中的所有文档 要计算orders集合中所有文档的数量，请使用以下操作： db.orders.count() 此操作等效于以下内容： db.orders.find().count() 计算匹配查询的所有文档 使用大于new Date('01/01/2012')的字段ord_dt计算orders集合中的文档数： db.orders.count( { ord_dt: { $gt: new Date('01/01/2012') } } ) 该查询等效于以下内容： db.orders.find( { ord_dt: { $gt: new Date('01/01/2012') } } ).count() Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-countDocuments.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-countDocuments.html","title":"db.collection.countDocuments()","keywords":"","body":" db.collection.countDocuments（） 在本页面 定义 行为 例子 定义 db.collection.countDocuments(query, options) 版本4.0.3中的新功能。 参数 类型 描述 query document 查询选择条件。要计算所有文档，请指定一个空文档。另请参阅查询限制。 options document 可选的。影响计数行为的其他选项。 该options文档可以包含以下内容： 字段 类型 描述 limit integer 可选的。要计算的最大文件数。 skip integer 可选的。计数前要跳过的文档数。 hint string or document 可选的。用于查询的索引名称或索引规范。 maxTimeMS integer 可选的。允许计数运行的最长时间。 行为 结构 与db.collection.count()， db.collection.countDocuments()不使用元数据返回计数不同。相反，它会执行文档的聚合以返回准确的计数，即使是在异常关闭后或分片群集中存在孤立的文档之后。 db.collection.countDocuments()包装以下聚合操作并仅返回的值n： db.collection.aggregate([ { $match: }, { $group: { _id: null, n: { $sum: 1 } } } ]) 空或不存在的集合和视图 从版本4.2.1（和版本4.0.13中的4.0系列）开始， db.collection.countDocuments()返回0在一个空的或不存在的集合或视图。 在MongoDB的早期版本中，db.collection.countDocuments()查询空或不存在的集合或视图会报错。 查询限制 您不能在db.collection.countDocuments()中将以下查询运算符用作以下查询表达式的一部分： 限制操作符 替代 $where 使用$expr代替 $near $geoWithin与$center一起使用。即：{ $geoWithin: { $center: [ [ , ], ] } } $nearSphere $geoWithin与$centerSphere一起使用。即：{ $geoWithin: { $centerSphere: [ [ , ], ] } } 事务 db.collection.countDocuments()可以在多文档事务中使用。 重要 在大多数情况下，与单文档写入相比，多文档事务产生的性能成本更高，并且多文档事务的可用性不应替代有效的架构设计。在许多情况下， 非规范化数据模型（嵌入式文档和数组）将继续是您的数据和用例的最佳选择。也就是说，在许多情况下，适当地对数据建模将最大程度地减少对多文档事务的需求。 有关其他事务使用方面的注意事项（例如运行时限制和操作日志大小限制），另请参见 生产注意事项。 客户端断开 从MongoDB 4.2开始，如果发出db.collection.countDocuments()断开连接的客户端 在操作完成之前断开连接，则MongoDB将标记为终止db.collection.countDocuments()（即在操作上killOp）。 例子 计算集合中的所有文档 要计算orders集合中所有文档的数量，请使用以下操作： db.orders.countDocuments({}) 计算与查询匹配的所有文档 计算orders 集合中具有ord_dt大于的字段的文档数：new Date('01/01/2012')： db.orders.countDocuments( { ord_dt: { $gt: new Date('01/01/2012') } }, { limit: 100 } ) 也可以看看 db.collection.estimatedDocumentCount() $group 和 $sum count 带有count选项的collStats pipeline stage。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-estimatedDocumentCount.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-estimatedDocumentCount.html","title":"db.collection.estimatedDocumentCount()","keywords":"","body":" db.collection.estimatedDocumentCount（） 在本页面 定义 行为 例子 定义 db.collection.estimatedDocumentCount（options） 版本4.0.3中的新功能。 返回集合或视图中所有文档的计数。该方法包装count命令。 db.collection.estimatedDocumentCount( ) 参数 类型 描述 options document 可选的。影响计数行为的其他选项。 该options文档可以包含以下内容： 字段 类型 描述 maxTimeMS integer 可选的。允许计数运行的最长时间。 行为 结构 db.collection.estimatedDocumentCount()不使用查询过滤器，而是使用元数据返回集合的计数。 分片集群 在分片群集上，结果计数将无法正确过滤出 orphaned document。 不正常关机 不正常关机后，计数可能不正确。 mongod使用Wired Tiger存储引擎不正常关闭后，所报告的计数统计信息 db.collection.estimatedDocumentCount()可能不准确。 偏移量取决于在最后一个checkpoint与异常关闭之间执行的插入，更新或删除操作的数量。检查点通常每60秒出现一次。但是，mongod使用非默认--syncdelay设置运行的实例可能具有或多或少的频繁检查点。 validate在mongod异常关闭后，对上的每个集合运行以恢复正确的统计信息。 客户端断开 从MongoDB 4.2开始，如果发出db.collection.estimatedDocumentCount()断开连接的客户端在操作完成之前断开连接，则MongoDB将标记为终止db.collection.estimatedDocumentCount()（即在操作上killOp）。 例子 以下示例用于 db.collection.estimatedDocumentCount检索orders集合中所有文档的计数： db.orders.estimatedDocumentCount({}) 也可以看看 db.collection.countDocuments() count 带有count选项的collStats pipeline stage。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-createIndex.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-createIndex.html","title":"db.collection.createIndex()","keywords":"","body":" db.collection.createIndex（） 在本页面 定义 选项 行为 例子 附加信息 定义 db.collection. createIndex(键，选项) 在集合上创建索引。 在 version 3.2 中更改：MongoDB 禁止创建version 0索引。要升级现有的 version 0 索引，请参阅Version 0 索引。 参数 类型 描述 keys document 包含字段和 value 对的文档，其中字段是索引 key，value 描述该字段的索引类型。对于字段的升序索引，请指定的 value;对于降序索引，请指定-1的 value。 MongoDB 支持几种不同的索引类型，包括文本，地理空间和哈希索引。有关更多信息，请参见索引类型。 从 3.6 开始，您不能将*指定为索引 name。MongoDB支持几种不同的索引类型，包括 text，geospatial和hashed索引。有关 更多信息，请参见索引类型。在版本4.2中进行了更改： MongoDB 4.2 通配符索引 支持工作负载，用户可以在其中查询自定义字段或集合中各种字段：要在文档中的所有字段和子字段上创建通配符索引，请指定为索引键。创建通配符索引时，不能指定降序索引键。{ \"$**\" : 1 }，您还可以使用可选参数在索引中包括或排除特定字段及其子字段 wildcardProjection。_id默认情况下，通配符索引会忽略该字段。要将_id字段包含 在通配符索引中，必须在wildcardProjection文档中明确包含它：{ “ wildcardProjection”：{ “ _id”：1 “ ”：0 | 1 } }除了显式包含 _id字段外，您无法在wildcardProjection文档中组合包含和排除语句 。您可以在特定字段及其子路径上创建通配符索引，方法是将该字段的完整路径指定为索引键并附\"$**\"加到该路径：{ \"path.to.field.$**\" : 1 }特定于路径的通配符索引语法与该wildcardProjection选项不兼容 。您不能在指定的路径上指定其他包含或排除。通配符索引键必须使用上面列出的语法之一。例如，您不能指定 复合索引键。有关通配符索引的更完整文档（包括对其创建的限制），请参阅通配符索引限制。该featureCompatibilityVersion必须创建通配符索引。有关设置fCV的说明，请参阅 在MongoDB 4.2部署上设置功能兼容版本。mongod 4.2 options document 可选的。包含一组控制索引创建的选项的文档。有关详细信息，请参阅选项。 db.collection.createIndex()是createIndexes命令周围的 wrapper。 要最小化 building 索引对复制集和分片群集的影响，请使用在复制集上建立索引中所述的滚动索引 build 过程。 选项 options文档包含一组控制索引创建的选项。不同的索引类型可以具有特定于该类型的附加选项。 更改了 version 3.4：添加了对整理选项的支持。 所有索引类型的选项 除非另有说明，否则以下选项适用于所有索引类型： 更改 version 3.0：dropDups选项不再可用。 参数 类型 描述 background boolean 可选的。在MongoDB 4.2中已弃用。对于功能兼容版本（fcv）\"4.0\"，指定可指示MongoDB在后台构建索引。后台构建 不会阻止对集合的操作。默认值为 。background: true/false在版本4.2中进行了更改。对于功能兼容版本（fcv）\"4.2\"，所有索引构建都使用优化的 构建过程，该过程仅在构建过程的开始和结束时才持有排他锁。其余的构建过程将产生交错的读写操作。background如果指定，MongoDB将忽略该选项。 unique boolean 可选的。创建唯一索引，以便集合不接受索引 key value 与索引中现有 value 匹配的文档的插入或更新。 指定true以创建唯一索引。默认的 value 是false。 该选项不适用于哈希索引。 name String 可选的。索引的 name。如果未指定，MongoDB 通过连接索引字段和 sort order 的名称来生成索引 name。 从4.2版开始，对于featureCompatibilityVersion设置为\"4.2\"或更大的版本，MongoDB删除了 最大127个字节的限制。在早期版本或将featureCompatibilityVersion（fCV）设置为MongoDB的版本 中 ，索引名称必须位于内 。Index Name Length \"4.0\" limit partialFilterExpression document 可选的。如果指定，则索引仅 references 与匹配过滤器表达式的文档。有关更多信息，请参见部分索引。 过滤器表达式可以包括：等式表达式(即：field: value或使用$eq operator)， $exists：true表达式， $gt，$gte，$lt，$lte表达式， $type表达式， $and operator 仅 top-level 您可以指定所有 MongoDB 索引类型的partialFilterExpression选项。 version 3.2 中的新内容。 sparse boolean 可选的。如果true，则索引仅使用指定字段 references 文档。这些索引使用较少的空间，但在某些情况下(特别是排序)表现不同。默认的 value 是false。有关更多信息，请参见稀疏索引。 在 version 3.2 中更改：从 MongoDB 3.2 开始，MongoDB 提供了创建部分索引的选项。部分索引提供了稀疏索引功能的超集。如果您使用 MongoDB 3.2 或更高版本，则部分索引应优先于稀疏索引。 version 2.6 中更改：2 dsphere索引默认为稀疏，并忽略此选项。对于包含2dsphere index key(s)的复合索引以及其他类型的键，只有2dsphere索引字段确定索引是否引用文档。 2 d，geoHaystack和文本索引的行为与2 dsphere索引类似。 expireAfterSeconds integer 可选的。将 value(以秒为单位)指定为TTL，以控制 long MongoDB 如何保留此集合中的文档。有关此功能的更多信息，请参见通过设置 TTL 使集合中的数据过期。这仅适用于TTL索引。 storageEngine document 可选的。允许用户在_创建索引时以 per-index 为基础配置存储引擎。 storageEngine选项应采用以下形式： storageEngine: { : } 在验证 creating 索引时指定的存储引擎 configuration 选项，并在复制期间记录到OPLOG以支持具有使用不同存储引擎的成员的副本_set。 version 3.0 中的新内容。 整理选项 version 3.4 中的新内容。 警告 MongoDB 3.2 和早期版本不支持排序规则。在 MongoDB 3.2 及更早版本中，不要使用不受支持的排序规则选项创建索引，因为这会阻止升级到 3.4，这将强制执行更严格的索引选项验证。 参数 类型 描述 collation document 可选的。指定索引的整理。 整理允许用户为 string 比较指定 language-specific 规则，例如字母和重音标记的规则。 如果已在集合 level 中指定了排序规则，则：如果在创建索引时未指定排序规则，MongoDB 将使用集合的默认排序规则创建索引。 如果在创建索引时指定了排序规则，MongoDB 将使用指定的排序规则创建索引。 排序规则选项具有以下语法：排序规则：{ locale：， caseLevel：， caseFirst：， strength：， numericOrdering：， alternate：， maxVariable：， backwards ： } 指定排序规则时，locale字段是必填字段;所有其他校对字段都是可选的。有关字段的说明，请参阅整理文件。 version 3.4 中的新内容。 以下索引仅支持简单的二进制比较，不支持整理： 文本索引， 2 d索引和 geoHaystack索引。 建议 要在具有 non-simple 归类的集合上创建text，2d或geoHaystack索引，必须在创建索引时显式指定{collation: {locale: \"simple\"} }。 整理和索引使用 如果已在集合 level 中指定了排序规则，则： 如果在创建索引时未指定排序规则，MongoDB 将使用集合的默认排序规则创建索引。 如果在创建索引时指定了排序规则，MongoDB 将使用指定的排序规则创建索引。 建议 通过指定1或2的归类strength，可以创建 case-insensitive 索引。 1的整理strength的索引是变音符号和 case-insensitive。 与其他索引选项不同，您可以使用不同的排序规则在同一 key(s) 上创建多个索引。要使用相同的 key pattern 但不同的排序规则创建索引，必须提供唯一的索引名称。 要使用索引进行 string 比较，操作还必须指定相同的排序规则。也就是说，如果操作指定了不同的排序规则，则具有排序规则的索引不能支持对索引字段执行 string 比较的操作。 对于 example，集合myColl在 string 字段category上有一个索引，其中包含整理 locale \"fr\"。 db.myColl.createIndex( { category: 1 }, { collation: { locale: \"fr\" } } ) 以下查询操作(指定与索引相同的排序规则)可以使用索引： db.myColl.find( { category: \"cafe\" } ).collation( { locale: \"fr\" } ) 但是，以下查询操作(默认情况下使用“简单”二进制文件夹)无法使用索引： db.myColl.find( { category: \"cafe\" } ) 对于索引前缀键不是 strings，数组和嵌入文档的复合索引，指定不同排序规则的操作仍然可以使用索引来支持对索引前缀键的比较。 对于 example，集合myColl在数字字段score和price以及 string 字段category上具有复合索引;使用用于 string 比较的排序规则 locale \"fr\"创建索引： db.myColl.createIndex( { score: 1, price: 1, category: 1 }, { collation: { locale: \"fr\" } } ) 以下操作(使用\"simple\"二进制排序规则进行 string 比较)可以使用索引： db.myColl.find( { score: 5 } ).sort( { price: 1 } ) db.myColl.find( { score: 5, price: { $gt: NumberDecimal( \"10\" ) } } ).sort( { price: 1 } ) 以下操作在索引的category字段上使用\"simple\"二进制排序规则进行 string 比较，可以使用索引仅满足查询的score: 5部分： db.myColl.find( { score: 5, category: \"cafe\" } ) 文本索引的选项 以下选项仅适用于文本索引： 参数 类型 描述 weights document 可选的。对于文本索引，包含字段和权重对的文档。权重是 1 到 99,999 之间的整数，并且表示该字段相对于其他索引字段在分数方面的重要性。您可以为部分或全部索引字段指定权重。请参阅使用权重控制搜索结果以调整分数。默认的 value 是1。 default_language String 可选的。对于文本索引，确定停用词列表的语言以及词干分析器和标记生成器的规则。有关可用语言，请参阅文本搜索语言;有关详细信息和示例，请参阅指定文本索引的语言。默认的 value 是english。 language_override String 可选的。对于文本索引，集合文档中字段的 name 包含文档的覆盖语言。默认的 value 是language。有关 example，请参阅使用任何字段指定文档的语言。 textIndexVersion integer 可选的。 text索引 version number。用户可以使用此选项覆盖默认的 version number。 有关可用版本，请参阅版本。 version 2.6 中的新内容。 2dsphere 索引的选项 以下选项仅适用于2 dsphere索引： 参数 类型 描述 2dsphereIndexVersion integer 可选的。 2dsphere索引 version number。用户可以使用此选项覆盖默认的 version number。 有关可用版本，请参阅版本。 version 2.6 中的新内容。 2d 索引的选项 以下选项仅适用于2 d索引： 参数 类型 描述 bits integer 可选的。对于2 d索引，存储位置数据的地理散列 value 的精度数。 bits value 的范围是 1 到 32(含)。默认的 value 是26。 min number 可选的。对于2 d索引，经度和纬度值的下包含边界。默认的 value 是-180.0。 max number 可选的。对于2 d索引，经度和纬度值的上包含边界。默认的 value 是180.0。 geoHaystack 索引的选项 以下选项仅适用于geoHaystack索引： 参数 类型 描述 bucketSize number 对于geoHaystack索引，请指定要对位置值进行分组的单位数; 即： group 在同一个存储桶中的那些位置值在指定的单位数内。 value 必须大于 0。 wildcard索引的选项 以下选项仅适用于 通配符索引： 参数 类型 描述 wildcardProjection document 可选的。允许用户使用 键模式在通配符索引中包括或排除特定字段路径。仅当在所有文档字段上创建通配符索引时，此选项才有效。如果在特定字段路径及其子字段上创建通配符索引，则无法指定此选项，例如 { \"$**\" : 1} { \"path.to.field.$**\" : 1 }该wildcardProjection选项采用以下形式：wildcardProjection: { \"path.to.field.a\" : , \"path.to.field.b\" : }该可以是以下几点：1. 1或true将该字段包括在通配符索引中。2. 0或false从通配符索引中排除该字段。_id默认情况下，通配符索引会忽略该字段。要将_id字段包含 在通配符索引中，必须在wildcardProjection文档中明确包含它：{ \"wildcardProjection\" : { \"_id\" : 1, \"\" : 01}}除了显式包含 _id字段外，您无法在wildcardProjection文档中组合包含和排除语句 。 行为 并发 在版本4.2中进行了更改。 对于featureCompatibilityVersion \"4.2\"，db.collection.createIndex()使用优化的构建过程，该过程在索引构建的开始和结束时获取并持有对指定集合的排他锁。集合上的所有后续操作必须等到db.collection.createIndex()释放排他锁。db.collection.createIndex()允许在大多数索引构建期间交错进行读写操作。 对于featureCompatibilityVersion \"4.0\"，db.collection.createIndex()使用4.2之前的索引构建过程，默认情况下会在构建过程的整个过程中获取父数据库的互斥锁。4.2之前的构建过程将阻止对数据库及其所有集合的所有操作，直到操作完成。background索引不使用排他锁。 有关的锁定行为的更多信息db.collection.createIndex()，请参见 填充集合的索引构建。 重塑现有的索引 如果您要求db.collection.createIndex()已经存在的索引，则MongoDB不会重新创建该索引。 指数设置 非归类选项 除排序规则选项外，如果您创建具有一组索引选项的索引，然后尝试重新创建相同的索引但具有不同的索引选项，则MongoDB不会更改选项，也不会重新创建索引。 要更改这些索引选项，请db.collection.dropIndex()在db.collection.createIndex()使用新选项运行之前 删除现有索引 。 排序规则选项 与其他索引选项不同，您可以在具有不同排序规则的同一键上创建多个索引。要创建具有相同键模式但排序规则不同的索引，必须提供唯一的索引名称。 索引键长度限制 对于将featureCompatibilityVersion（fCV）设置为\"4.0\"或更早版本的MongoDB 2.6至MongoDB版本， 如果现有文档的索引条目超过，则MongoDB 不会在集合上创建索引。Maximum Index Key Length 例子 在单个字段上创建升序索引 以下 example 在字段orderDate上创建升序索引。 db.collection.createIndex( { orderDate: 1 } ) 如果keys文档指定了多个字段，则createIndex()创建复合指数。 在多个字段上创建索引 以下 example 在orderDate字段(在升序 order 中)和zipcode字段(在降序 order.)中)创建复合索引 db.collection.createIndex( { orderDate: 1, zipcode: -1 } ) 复合索引不能包含哈希指数 component。 注意 索引的 order 对于使用索引支持sort()操作很重要。 使用指定的排序规则创建索引 version 3.4 中的新内容。 以下 example 创建名为category_fr的索引。 example 使用整理创建索引，指定 locale fr和比较强度2： db.collection.createIndex( { category: 1 }, { name: \"category_fr\", collation: { locale: \"fr\", strength: 2 } } ) 以下 example 使用整理创建名为date_category_fr的复合索引。排序规则仅适用于具有 string 值的索引键。 db.collection.createIndex( { orderDate: 1, category: 1 }, { name: \"date_category_fr\", collation: { locale: \"fr\", strength: 2 } } ) 排序规则适用于值为 string 的索引键。 对于使用相同排序规则的索引键的查询或排序操作，MongoDB 可以使用索引。有关详细信息，请参阅整理和索引使用。 创建一个通配符指数 4.2版中的新功能。 该featureCompatibilityVersion必须创建通配符索引。有关设置fCV的说明，请参阅 在MongoDB 4.2部署上设置功能兼容版本。mongod 4.2 _id默认情况下，通配符索引会忽略该字段。要将_id字段包含 在通配符索引中，必须在wildcardProjection文档中明确包含它： { \"wildcardProjection\" : { \"_id\" : 1, \"\" : 0|1 } } 除了显式包含 _id字段外，您无法在wildcardProjection文档中组合包含和排除语句 。 通配符索引不支持以下索引类型或属性： Compound TTL Text 2d (Geospatial) 2dsphere (Geospatial) Hashed Unique 注意 通配符索引与通配符文本索引不同并且不兼容 。通配符索引不能支持使用$text运算符的查询。 有关通配符索引限制的完整文档，请参见 通配符索引限制。 有关通配符索引的完整文档，请参见 通配符索引。 以下列出了创建通配符索引的示例： 在单个字段路径上创建通配符索引 在所有字段路径上创建通配符索引 在通配符索引覆盖率中包括特定字段 从通配符索引覆盖率中忽略特定字段 在单个字段路径上创建通配符索引 考虑一个集合products_catalog，其中文档可能包含一个 product_attributes字段。该product_attributes字段可以包含任意嵌套的字段，包括嵌入式文档和数组： { \"_id\" : ObjectId(\"5c1d358bf383fbee028aea0b\"), \"product_name\" : \"Blaster Gauntlet\", \"product_attributes\" : { \"price\" : { \"cost\" : 299.99 \"currency\" : USD } ... } }, { \"_id\" : ObjectId(\"5c1d358bf383fbee028aea0c\"), \"product_name\" : \"Super Suit\", \"product_attributes\" : { \"superFlight\" : true, \"resistance\" : [ \"Bludgeoning\", \"Piercing\", \"Slashing\" ] ... }, } 以下操作在product_attributes字段上创建通配符索引 ： use inventory db.products_catalog.createIndex( { \"product_attributes.$**\" : 1 } ) 使用此通配符索引，MongoDB索引的所有标量值 product_attributes。如果字段是嵌套的文档或数组，则通配符索引将递归到文档/数组中，并为文档/数组中的所有标量字段建立索引。 通配符索引可以支持product_attributes对其嵌套字段之一或其嵌套字段进行任意单字段查询 ： db.products_catalog.find( { \"product_attributes.superFlight\" : true } ) db.products_catalog.find( { \"product_attributes.maxSpeed\" : { $gt : 20 } } ) db.products_catalog.find( { \"product_attributes.elements\" : { $eq: \"water\" } } ) 注意 特定于路径的通配符索引语法与该wildcardProjection选项不兼容 。有关更多信息，请参见参数文档。 在所有字段路径上创建通配符索引 考虑一个集合products_catalog，其中文档可能包含一个 product_attributes字段。该product_attributes字段可以包含任意嵌套的字段，包括嵌入式文档和数组： { \"_id\" : ObjectId(\"5c1d358bf383fbee028aea0b\"), \"product_name\" : \"Blaster Gauntlet\", \"product_attributes\" : { \"price\" : { \"cost\" : 299.99 \"currency\" : USD } ... } }, { \"_id\" : ObjectId(\"5c1d358bf383fbee028aea0c\"), \"product_name\" : \"Super Suit\", \"product_attributes\" : { \"superFlight\" : true, \"resistance\" : [ \"Bludgeoning\", \"Piercing\", \"Slashing\" ] ... }, } 以下操作在所有标量字段（不包括_id字段）上创建通配符索引： use inventory db.products_catalog.createIndex( { \"$**\" : 1 } ) 使用此通配符索引，MongoDB可以索引集合中每个文档的所有标量字段。如果给定字段是嵌套文档或数组，则通配符索引将递归到文档/数组中，并为文档/数组中的所有标量字段建立索引。 创建的索引可以支持对集合中文档中任意字段的查询： db.products_catalog.find( { \"product_price\" : { $lt : 25 } } ) db.products_catalog.find( { \"product_attributes.elements\" : { $eq: \"water\" } } ) 注意 _id默认情况下，通配符索引会忽略该字段。要将_id字段包括 在通配符索引中，必须在wildcardProjection文档中明确包含它。有关更多信息，请参见参数文档。 在通配符索引覆盖率中包括特定字段 考虑一个集合products_catalog，其中文档可能包含一个 product_attributes字段。该product_attributes字段可以包含任意嵌套的字段，包括嵌入式文档和数组： { \"_id\" : ObjectId(\"5c1d358bf383fbee028aea0b\"), \"product_name\" : \"Blaster Gauntlet\", \"product_attributes\" : { \"price\" : { \"cost\" : 299.99 \"currency\" : USD } ... } }, { \"_id\" : ObjectId(\"5c1d358bf383fbee028aea0c\"), \"product_name\" : \"Super Suit\", \"product_attributes\" : { \"superFlight\" : true, \"resistance\" : [ \"Bludgeoning\", \"Piercing\", \"Slashing\" ] ... }, } 以下操作将创建一个通配符索引，并使用该wildcardProjection选项在索引中仅包含product_attributes.elements和product_attributes.resistance 字段的标量值 。 use inventory db.products_catalog.createIndex( { \"$**\" : 1 }, { \"wildcardProjection\" : { \"product_attributes.elements\" : 1, \"product_attributes.resistance\" : 1 } } ) 尽管键模式\"$**\"涵盖了文档中的所有字段，但该 wildcardProjection字段将索引限制为仅包含的字段。有关的完整文档wildcardProjection，请参阅 通配符索引的选项。 如果字段是嵌套文档或数组，则通配符索引将递归到文档/数组中，并索引文档/数组中的所有标量字段。 创建的索引可以支持对以下内容中包含的任何标量字段的查询wildcardProjection： db.products_catalog.find( { \"product_attributes.elements\" : { $eq: \"Water\" } } ) db.products_catalog.find( { \"product_attributes.resistance\" : \"Bludgeoning\" } ) 注意 通配符索引不支持在wildcardProjection文档中混合包含和排除语句，除非明确包含该_id字段。有关更多信息 wildcardProjection，请参见参数文档。 从通配符索引覆盖率中忽略特定字段 考虑一个集合products_catalog，其中文档可能包含一个 product_attributes字段。该product_attributes字段可以包含任意嵌套的字段，包括嵌入式文档和数组： { \"_id\" : ObjectId(\"5c1d358bf383fbee028aea0b\"), \"product_name\" : \"Blaster Gauntlet\", \"product_attributes\" : { \"price\" : { \"cost\" : 299.99 \"currency\" : USD } ... } }, { \"_id\" : ObjectId(\"5c1d358bf383fbee028aea0c\"), \"product_name\" : \"Super Suit\", \"product_attributes\" : { \"superFlight\" : true, \"resistance\" : [ \"Bludgeoning\", \"Piercing\", \"Slashing\" ] ... }, } 以下操作创建一个通配符指数，并使用wildcardProjection文件索引的所有标量场的每个文档的集合中，排除了 product_attributes.elements和product_attributes.resistance 字段： use inventory db.products_catalog.createIndex( { \"$**\" : 1 }, { \"wildcardProjection\" : { \"product_attributes.elements\" : 0, \"product_attributes.resistance\" : 0 } } ) 尽管键模式\"$**\"涵盖了文档中的所有字段，但 wildcardProjection该字段从索引中排除了指定的字段。有关的完整文档wildcardProjection，请参阅 通配符索引的选项。 如果字段是嵌套文档或数组，则通配符索引将递归到文档/数组中，并索引文档/数组中的所有标量字段。 创建的索引可以支持对任何标量字段的查询，但 以下项除外wildcardProjection： db.products_catalog.find( { \"product_attributes.maxSpeed\" : { $gt: 25 } } ) db.products_catalog.find( { \"product_attributes.superStrength\" : true } ) 注意 通配符索引不支持在wildcardProjection文档中混合包含和排除语句，除非明确包含该_id字段。有关更多信息 wildcardProjection，请参见参数文档。 附加信息 本手册的索引部分用于 MongoDB 中索引和索引的完整文档。 db.collection.getIndexes()查看集合的现有索引的规范。 文字索引有关 creating text索引的详细信息。 地理空间索引和geoHaystack 索引用于地理空间查询。 TTL 指数表示数据到期。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-createIndexes.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-createIndexes.html","title":"db.collection.createIndexes()","keywords":"","body":" db.collection.createIndexes（） 在本页面 定义 选项 行为 例子 附加信息 定义 db.collection. createIndexes([*keyPatterns,]options) version 3.2 中的新内容。 在集合上创建一个或多个索引。 参数 类型 描述 keyPatterns document 包含字段和 value 对的文档，其中字段是索引 key，value 描述该字段的索引类型。对于字段的升序索引，请指定的 value;对于降序索引，请指定-1的 value。 MongoDB 支持几种不同的索引类型，包括文本，地理空间和哈希索引。有关更多信息，请参见索引类型。 从 3.6 开始，您不能将*指定为索引 name。MongoDB支持几种不同的索引类型，包括 text，geospatial和hashed索引。有关 更多信息，请参见索引类型。在版本4.2中进行了更改： MongoDB 4.2 通配符索引 支持工作负载，用户可以在其中查询自定义字段或集合中各种字段：要在文档中的所有字段和子字段上创建通配符索引，请指定为索引键。创建通配符索引时，不能指定降序索引键。{ \"$**\" : 1 }，您还可以使用可选参数在索引中包括或排除特定字段及其子字段 wildcardProjection。_id默认情况下，通配符索引会忽略该字段。要将_id字段包含 在通配符索引中，必须在wildcardProjection文档中明确包含它：{ “ wildcardProjection”：{ “ _id”：1 “ ”：0 | 1 } }除了显式包含 _id字段外，您无法在wildcardProjection文档中组合包含和排除语句 。您可以在特定字段及其子路径上创建通配符索引，方法是将该字段的完整路径指定为索引键并附\"$**\"加到该路径：{ \"path.to.field.$**\" : 1 }特定于路径的通配符索引语法与该wildcardProjection选项不兼容 。您不能在指定的路径上指定其他包含或排除。通配符索引键必须使用上面列出的语法之一。例如，您不能指定 复合索引键。有关通配符索引的更完整文档（包括对其创建的限制），请参阅通配符索引限制。该featureCompatibilityVersion必须创建通配符索引。有关设置fCV的说明，请参阅 在MongoDB 4.2部署上设置功能兼容版本。mongod 4.2 options document 可选的。包含一组控制索引创建的选项的文档。有关详细信息，请参阅选项。 db.collection.createIndexes()是createIndexes命令周围的 wrapper。 要最小化 building 索引对副本_set 和分片群集的影响，请使用在副本_Set 上建立索引中所述的滚动索引 build 过程。 选项 options文档包含一组控制索引创建的选项。不同的索引类型可以具有特定于该类型的附加选项。 重要 为 db.collection.createIndexes()指定选项时，这些选项适用于所有指定的索引。对于 example，如果指定了排序规则选项，则所有创建的索引都将包含该排序规则。 如果尝试使用不兼容的选项创建索引，db.collection.createIndexes()将_return 错误。有关更多信息，请参阅选项说明。 更改了 version 3.4：添加了对整理的支持。 所有索引类型的选项 除非另有说明，否则以下选项适用于所有索引类型： 更改 version 3.0：dropDups选项不再可用。 参数 类型 描述 background boolean 可选的。在后台构建索引，以便操作不会阻止其他数据库活动。在后台指定true到 build。默认的 value 是false。 unique boolean 可选的。指定keyPatterns array 中指定的每个索引都是独特的指数。唯一索引不接受索引 key value 与索引中现有 value 匹配的文档的插入或更新。 指定true以创建唯一索引。默认的 value 是false。 该选项不适用于哈希索引。 name string 可选的。索引的 name。如果未指定，MongoDB 通过连接索引字段和 sort order 的名称来生成索引 name。 无论是用户指定还是生成 MongoDB，索引名称(包括其完整命名空间(即：database.collection))都不能超过索引名称限制。 为db.collection.createIndexes指定的选项适用于 key pattern array 中包含的所有索引规范。由于索引名称必须是唯一的，因此如果使用db.collection.createIndexes创建单个索引，则只能指定 name。 partialFilterExpression document 可选的。如果指定，则仅索引 reference 文档匹配过滤器表达式。有关更多信息，请参见部分索引。 过滤器表达式可以包括：等式表达式(i.e.field: value或使用$eq operator)， $exists：true表达式， $gt，$gte，$lt，$lte表达式， $type表达式， $and operator 仅 top-level 您可以指定所有 MongoDB 索引类型的partialFilterExpression选项。 version 3.2 中的新内容。 sparse boolean 可选的。如果是true，索引只有 reference 文件带有指定的字段。这些索引使用较少的空间，但在某些情况下(特别是排序)表现不同。默认的 value 是false。有关更多信息，请参见稀疏索引。 在 version 3.2 中更改：从 MongoDB 3.2 开始，MongoDB 提供了创建部分索引的选项。部分索引提供了稀疏索引功能的超集。如果您使用 MongoDB 3.2 或更高版本，则部分索引应优先于稀疏索引。 version 2.6 中更改：2 dsphere索引默认为稀疏，并忽略此选项。对于包含2dsphere index key(s)的复合索引以及其他类型的键，只有2dsphere索引字段确定索引是否引用文档。 2 d，geoHaystack和文本索引的行为与2 dsphere索引类似。 expireAfterSeconds integer 可选的。将 value(以秒为单位)指定为TTL，以控制 long MongoDB 如何保留此集合中的文档。有关此功能的更多信息，请参见通过设置 TTL 使集合中的数据过期。这仅适用于TTL索引。 storageEngine document 可选的。允许用户为创建的索引配置存储引擎。 storageEngine选项应采用以下形式： storageEngine: { : } 在验证 creating 索引时指定的存储引擎 configuration 选项，并在复制期间记录到OPLOG以支持具有使用不同存储引擎的成员的副本_set。 version 3.0 中的新内容。 整理选项 参数 类型 描述 collation document 可选的。指定索引的整理。 整理允许用户为 string 比较指定 language-specific 规则，例如字母和重音标记的规则。 如果已在集合 level 中指定了排序规则，则：如果在创建索引时未指定排序规则，MongoDB 将使用集合的默认排序规则创建索引。 如果在创建索引时指定了排序规则，MongoDB 将使用指定的排序规则创建索引。 排序规则选项具有以下语法：排序规则：{ locale：， caseLevel：， caseFirst：， strength：， numericOrdering：， alternate：， maxVariable：， backwards ： } 指定排序规则时，locale字段是必填字段;所有其他校对字段都是可选的。有关字段的说明，请参阅整理文件。 version 3.4 中的新内容。 以下索引仅支持简单的二进制比较，不支持整理： 文本索引， 2 d索引和 geoHaystack索引。 建议 要在具有 non-simple 归类的集合上创建text，2d或geoHaystack索引，必须在创建索引时显式指定{collation: {locale: \"simple\"} }。 整理和索引使用 如果已在集合 level 中指定了排序规则，则： 如果在创建索引时未指定排序规则，MongoDB 将使用集合的默认排序规则创建索引。 如果在创建索引时指定了排序规则，MongoDB 将使用指定的排序规则创建索引。 建议 通过指定1或2的归类strength，可以创建 case-insensitive 索引。 1的整理strength的索引是变音符号和 case-insensitive。 与其他索引选项不同，您可以使用不同的排序规则在同一 key(s) 上创建多个索引。要使用相同的 key pattern 但不同的排序规则创建索引，必须提供唯一的索引名称。 要使用索引进行 string 比较，操作还必须指定相同的排序规则。也就是说，如果操作指定了不同的排序规则，则具有排序规则的索引不能支持对索引字段执行 string 比较的操作。 对于 example，集合myColl在 string 字段category上有一个索引，其中包含整理 locale \"fr\"。 db.myColl.createIndex( { category: 1 }, { collation: { locale: \"fr\" } } ) 以下查询操作(指定与索引相同的排序规则)可以使用索引： db.myColl.find( { category: \"cafe\" } ).collation( { locale: \"fr\" } ) 但是，以下查询操作(默认情况下使用“简单”二进制文件夹)无法使用索引： db.myColl.find( { category: \"cafe\" } ) 对于索引前缀键不是 strings，数组和嵌入文档的复合索引，指定不同排序规则的操作仍然可以使用索引来支持对索引前缀键的比较。 对于 example，集合myColl在数字字段score和price以及 string 字段category上具有复合索引;使用用于 string 比较的排序规则 locale \"fr\"创建索引： db.myColl.createIndex( { score: 1, price: 1, category: 1 }, { collation: { locale: \"fr\" } } ) 以下操作(使用\"simple\"二进制排序规则进行 string 比较)可以使用索引： db.myColl.find( { score: 5 } ).sort( { price: 1 } ) db.myColl.find( { score: 5, price: { $gt: NumberDecimal( \"10\" ) } } ).sort( { price: 1 } ) 以下操作在索引的category字段上使用\"simple\"二进制排序规则进行 string 比较，可以使用索引仅满足查询的score: 5部分： db.myColl.find( { score: 5, category: \"cafe\" } ) 文本索引的选项 以下选项仅适用于文本索引： 参数 类型 描述 weights document 可选的。对于文本索引，包含字段和权重对的文档。权重是 1 到 99,999 之间的整数，并且表示该字段相对于其他索引字段在分数方面的重要性。您可以为部分或全部索引字段指定权重。请参阅使用权重控制搜索结果以调整分数。默认的 value 是1。 default_language string 可选的。对于文本索引，确定停用词列表的语言以及词干分析器和标记生成器的规则。有关可用语言，请参阅文本搜索语言;有关详细信息和示例，请参阅指定文本索引的语言。默认的 value 是english。 language_override string 可选的。对于文本索引，集合文档中字段的 name 包含文档的覆盖语言。默认的 value 是language。有关 example，请参阅使用任何字段指定文档的语言。 textIndexVersion integer 可选的。 text索引 version number。用户可以使用此选项覆盖默认的 version number。 有关可用版本，请参阅版本。 version 2.6 中的新内容。 2dsphere 索引的选项 以下选项仅适用于2 dsphere索引： 参数 类型 描述 2dsphereIndexVersion integer 可选的。 2dsphere索引 version number。用户可以使用此选项覆盖默认的 version number。 有关可用版本，请参阅版本。 version 2.6 中的新内容。 2d 索引的选项 以下选项仅适用于2 d索引： 参数 类型 描述 bits integer 可选的。对于2 d索引，存储位置数据的地理散列 value 的精度数。 bits value 的范围是 1 到 32(含)。默认的 value 是26。 min number 可选的。对于2 d索引，经度和纬度值的下包含边界。默认的 value 是-180.0 max number 可选的。对于2 d索引，经度和纬度值的上包含边界。默认的 value 是180.0。 geoHaystack 索引的选项 以下选项仅适用于geoHaystack索引： 参数 类型 描述 bucketSize number 对于geoHaystack索引，请指定要对位置值进行分组的单位数; 即：group 在同一个存储桶中的那些位置值在指定的单位数内。 value 必须大于 0。 wildcard索引的选项 以下选项仅适用于 通配符索引： 参数 类型 描述 wildcardProjection document 可选的。允许用户从通配符索引中包括或排除特定的字段路径 。仅当创建通配符索引时，此选项才有效。该wildcardProjection选项采用以下形式：wildcardProjection: { \"path.to.field.a\" : , \"path.to.field.b\" : }该可以是以下几点：1. 1或true将该字段包括在通配符索引中。2. 0或false从通配符索引中排除该字段。_id默认情况下，通配符索引会忽略该字段。要将_id字段包含 在通配符索引中，必须在wildcardProjection文档中明确包含它{ \"wildcardProjection\" : { \"_id\" : 1, \"\" : 0 | 1}}除了显式包含 _id字段外，您无法在wildcardProjection文档中组合包含和排除语句 。指定的选项db.collection.createIndexes适用于键模式数组中包括的所有索引规范。wildcardProjection仅在使用创建单个通配符索引时 指定 db.collection.createIndexes 行为 并发 在版本4.2中进行了更改。 对于featureCompatibilityVersion \"4.2\"，db.collection.createIndexes() 使用优化的构建过程，该过程在索引构建的开始和结束时获取并持有对指定集合的排他锁。集合上的所有后续操作必须等到db.collection.createIndexes()释放排他锁。db.collection.createIndexes()允许在大多数索引构建期间交错进行读写操作。 对于featureCompatibilityVersion \"4.0\"，db.collection.createIndexes()使用4.2之前的索引构建过程，默认情况下会在构建过程的整个过程中获取父数据库的互斥锁。4.2之前的构建过程将阻止对数据库及其所有集合的所有操作，直到操作完成。background索引不使用排他锁。 有关的锁定行为的更多信息db.collection.createIndexes()，请参见 填充集合的索引构建。 重塑现有的索引 如果您要求db.collection.createIndexes()一个或多个已经存在的索引，MongoDB不会重新创建现有的一个或多个索引。 指数期权 非归类选项 除排序规则选项外，如果您创建具有一组索引选项的索引，然后尝试重新创建相同的索引但具有不同的索引选项，则MongoDB不会更改选项，也不会重新创建索引。 要更改这些索引选项，请db.collection.dropIndex()在db.collection.createIndexes()使用新选项运行之前 删除现有索引 。 排序规则选项 与其他索引选项不同，您可以在具有不同排序规则的同一键上创建多个索引。要创建具有相同键模式但排序规则不同的索引，必须提供唯一的索引名称。 索引键长度限制 对于将featureCompatibilityVersion（fCV）设置为\"4.0\"或更早版本的MongoDB 2.6至MongoDB版本， 如果现有文档的索引条目超过，则MongoDB 不会在集合上创建索引。Maximum Index Key Length 通配符索引 4.2版中的新功能。 _id默认情况下，通配符索引会忽略该字段。要将_id字段包含 在通配符索引中，必须在wildcardProjection文档中明确包含它： { \"wildcardProjection\" : { \"_id\" : 1, \"\" : 0|1 } } 除了显式包含 _id字段外，您无法在wildcardProjection文档中组合包含和排除语句 。 该featureCompatibilityVersion必须创建通配符索引。有关设置fCV的说明，请参阅 在MongoDB 4.2部署上设置功能兼容版本。mongod 4.2 通配符索引不支持以下索引类型或属性： Compound TTL Text 2d (Geospatial) 2dsphere (Geospatial) Hashed Unique 注意 通配符索引与通配符文本索引不同并且不兼容 。通配符索引不能支持使用$text运算符的查询。 有关通配符索引限制的完整文档，请参见 通配符索引限制。 有关创建通配符索引的示例，请参见 创建通配符索引。有关通配符索引的完整文档，请参见通配符索引。 例子 也可以看看 db.collection.createIndex()用于各种索引规范的示例。 创建没有选项的索引 考虑包含类似于以下内容的文档的restaurants集合： { location: { type: \"Point\", coordinates: [-73.856077, 40.848447] }, name: \"Morris Park Bake Shop\", cuisine: \"Cafe\", borough: \"Bronx\", } 以下 example 在restaurants集合上创建两个索引：borough字段上的升序索引和location字段上的2 dsphere索引。 db.restaurants.createIndexes([{\"borough\": 1}, {\"location\": \"2dsphere\"}]) 使用指定的排序规则创建索引 以下 example 在products集合上创建两个索引：manufacturer字段上的升序索引和category字段上的升序索引。两个索引都使用整理指定 locale fr和比较强度2： db.products.createIndexes( [ { \"manufacturer\": 1}, { \"category\": 1 } ], { collation: { locale: \"fr\", strength: 2 } }) 对于使用相同排序规则的索引键的查询或排序操作，MongoDB 可以使用索引。有关详细信息，请参阅整理和索引使用。 创建一个通配符指数 新的4.2版：该featureCompatibilityVersion必须创建通配符索引。有关设置fCV的说明，请参阅 在MongoDB 4.2部署上设置功能兼容版本。mongod 4.2 有关通配符索引的完整文档，请参见 通配符索引。 以下列出了创建通配符索引的示例： 在单个字段路径上创建通配符索引 在所有字段路径上创建通配符索引 在多个特定字段路径上创建通配符索引 创建排除多个特定字段路径的通配符索引 在单个字段路径上创建通配符索引 考虑一个集合products_catalog，其中文档可能包含一个 product_attributes字段。该product_attributes字段可以包含任意嵌套的字段，包括嵌入式文档和数组： { \"_id\" : ObjectId(\"5c1d358bf383fbee028aea0b\"), \"product_name\" : \"Blaster Gauntlet\", \"product_attributes\" : { \"price\" : { \"cost\" : 299.99 \"currency\" : USD } ... } }, { \"_id\" : ObjectId(\"5c1d358bf383fbee028aea0c\"), \"product_name\" : \"Super Suit\", \"product_attributes\" : { \"superFlight\" : true, \"resistance\" : [ \"Bludgeoning\", \"Piercing\", \"Slashing\" ] ... }, } 以下操作在product_attributes字段上创建通配符索引 ： use inventory db.products_catalog.createIndexes( [ { \"product_attributes.$**\" : 1 } ] ) 使用此通配符索引，MongoDB索引的所有标量值 product_attributes。如果字段是嵌套的文档或数组，则通配符索引将递归到文档/数组中，并为文档/数组中的所有标量字段建立索引。 通配符索引可以支持product_attributes对其嵌套字段之一或其嵌套字段进行任意单字段查询 ： db.products_catalog.find( { \"product_attributes.superFlight\" : true } ) db.products_catalog.find( { \"product_attributes.maxSpeed\" : { $gt : 20 } } ) db.products_catalog.find( { \"product_attributes.elements\" : { $eq: \"water\" } } ) 注意 特定于路径的通配符索引语法与该wildcardProjection选项不兼容 。有关更多信息，请参见参数文档。 在所有字段路径上创建通配符索引 考虑一个集合products_catalog，其中文档可能包含一个 product_attributes字段。该product_attributes字段可以包含任意嵌套的字段，包括嵌入式文档和数组： { \"_id\" : ObjectId(\"5c1d358bf383fbee028aea0b\"), \"product_name\" : \"Blaster Gauntlet\", \"product_attributes\" : { \"price\" : { \"cost\" : 299.99 \"currency\" : USD } ... } }, { \"_id\" : ObjectId(\"5c1d358bf383fbee028aea0c\"), \"product_name\" : \"Super Suit\", \"product_attributes\" : { \"superFlight\" : true, \"resistance\" : [ \"Bludgeoning\", \"Piercing\", \"Slashing\" ] ... }, } 以下操作在所有标量字段（不包括_id字段）上创建通配符索引： use inventory db.products_catalog.createIndexes( [ { \"$**\" : 1 } ] ) 使用此通配符索引，MongoDB可以索引集合中每个文档的所有标量字段。如果给定字段是嵌套文档或数组，则通配符索引将递归到文档/数组中，并为文档/数组中的所有标量字段建立索引。 创建的索引可以支持对集合中文档中任意字段的查询： db.products_catalog.find( { \"product_price\" : { $lt : 25 } } ) db.products_catalog.find( { \"product_attributes.elements\" : { $eq: \"water\" } } ) 注意 _id默认情况下，通配符索引会忽略该字段。要将_id字段包括 在通配符索引中，必须在wildcardProjection文档中明确包含它。有关更多信息，请参见参数文档。 在多个特定字段路径上创建通配符索引 考虑一个集合products_catalog，其中文档可能包含一个 product_attributes字段。该product_attributes字段可以包含任意嵌套的字段，包括嵌入式文档和数组： { \"_id\" : ObjectId(\"5c1d358bf383fbee028aea0b\"), \"product_name\" : \"Blaster Gauntlet\", \"product_attributes\" : { \"price\" : { \"cost\" : 299.99 \"currency\" : USD } ... } }, { \"_id\" : ObjectId(\"5c1d358bf383fbee028aea0c\"), \"product_name\" : \"Super Suit\", \"product_attributes\" : { \"superFlight\" : true, \"resistance\" : [ \"Bludgeoning\", \"Piercing\", \"Slashing\" ] ... }, } 以下操作将创建一个通配符索引，并使用该wildcardProjection选项在索引中仅包含product_attributes.elements和product_attributes.resistance 字段的标量值 。 use inventory db.products_catalog.createIndexes( [ { \"$**\" : 1 } ], { \"wildcardProjection\" : { \"product_attributes.elements\" : 1, \"product_attributes.resistance\" : 1 } } ) 尽管键模式\"$**\"涵盖了文档中的所有字段，但该 wildcardProjection字段将索引限制为仅包含的字段。有关的完整文档wildcardProjection，请参阅 通配符索引的选项。 如果字段是嵌套文档或数组，则通配符索引将递归到文档/数组中，并索引文档/数组中的所有标量字段。 创建的索引可以支持对以下内容中包含的任何标量字段的查询wildcardProjection： db.products_catalog.find( { \"product_attributes.elements\" : { $eq: \"Water\" } } ) db.products_catalog.find( { \"product_attributes.resistance\" : \"Bludgeoning\" } ) 注意 通配符索引不支持在wildcardProjection文档中混合包含和排除语句，除非明确包含该_id字段。有关更多信息 wildcardProjection，请参见参数文档。 创建一个排除多个特定字段路径的通配符索引 考虑一个集合products_catalog，其中文档可能包含一个 product_attributes字段。该product_attributes字段可以包含任意嵌套的字段，包括嵌入式文档和数组： { \"_id\" : ObjectId(\"5c1d358bf383fbee028aea0b\"), \"product_name\" : \"Blaster Gauntlet\", \"product_attributes\" : { \"price\" : { \"cost\" : 299.99 \"currency\" : USD } ... } }, { \"_id\" : ObjectId(\"5c1d358bf383fbee028aea0c\"), \"product_name\" : \"Super Suit\", \"product_attributes\" : { \"superFlight\" : true, \"resistance\" : [ \"Bludgeoning\", \"Piercing\", \"Slashing\" ] ... }, } 以下操作创建一个通配符指数，并使用wildcardProjection文件索引的所有标量场的每个文档的集合中，排除了 product_attributes.elements和product_attributes.resistance 字段： use inventory db.products_catalog.createIndexes( [ { \"$**\" : 1 } ], { \"wildcardProjection\" : { \"product_attributes.elements\" : 0, \"product_attributes.resistance\" : 0 } } ) 尽管键模式\"$**\"涵盖了文档中的所有字段，但 wildcardProjection该字段从索引中排除了指定的字段。有关的完整文档wildcardProjection，请参阅 通配符索引的选项。 如果字段是嵌套文档或数组，则通配符索引将递归到文档/数组中，并索引文档/数组中的所有标量字段。 创建的索引可以支持对任何标量字段的查询，但 以下项除外wildcardProjection： db.products_catalog.find( { \"product_attributes.maxSpeed\" : { $gt: 25 } } ) db.products_catalog.find( { \"product_attributes.superStrength\" : true } ) 注意 通配符索引不支持在wildcardProjection文档中混合包含和排除语句，除非明确包含该_id字段。有关更多信息 wildcardProjection，请参见参数文档。 附加信息 有关索引的其他信息，请参阅： 本手册的索引部分用于 MongoDB 中索引和索引的完整文档。 db.collection.getIndexes()查看集合的现有索引的规范。 文字索引有关 creating text索引的详细信息。 地理空间索引和geoHaystack 索引用于地理空间查询。 TTL 指数表示数据到期。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-dataSize.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-dataSize.html","title":"db.collection.dataSize()","keywords":"","body":" db.collection.dataSize（） db.collection.dataSize() 返回： 集合的大小(以字节为单位)。 数据压缩不会影响此 value。 此方法在collStats(即：db.collection.stats())命令的尺寸输出周围提供 wrapper。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-deleteOne.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-deleteOne.html","title":"db.collection.deleteOne()","keywords":"","body":" db.collection.deleteOne（） 在本页面 定义 行为 例子 定义 db.collection. deleteOne () 从集合中删除单个文档。 db.collection.deleteOne( , { writeConcern: , collation: } ) 参数 类型 描述 filter document 使用query operators指定删除条件。 指定空文档{ }以删除集合中返回的第一个文档。 writeConcern document 可选的。表示写关注的文件。省略使用默认写入问题。 collation document 可选的。 指定要用于操作的整理。 整理允许用户为 string 比较指定 language-specific 规则，例如字母和重音标记的规则。 排序规则选项具有以下语法： 排序规则：{ locale：， caseLevel：， caseFirst：， strength：， numericOrdering：， alternate：， maxVariable：， backwards ： } 指定排序规则时，locale字段是必填字段;所有其他校对字段都是可选的。有关字段的说明，请参阅整理文件。 如果未指定排序规则但集合具有默认排序规则(请参阅db.createCollection())，则操作将使用为集合指定的排序规则。 如果没有为集合或操作指定排序规则，MongoDB 使用先前版本中用于 string 比较的简单二进制比较。 您无法为操作指定多个排序规则。对于 example，您不能为每个字段指定不同的排序规则，或者如果使用排序执行查找，则不能对查找使用一个排序规则，而对排序使用另一个排序规则。 version 3.4 中的新内容。 返回： 包含以下内容的文档： boolean acknowledged as true如果操作使用写关注或false运行，如果写入关注被禁用 deletedCount包含已删除文档的数量 行为 删除 Order deleteOne删除与过滤器匹配的第一个文档。使用属于独特的指数的字段(如_id)进行精确删除。 上限收藏 如果在上限集合上使用，deleteOne()会抛出WriteError exception。要从上限集合中删除文档，请改用db.collection.drop()。 事务 db.collection.deleteOne()可以在多文档事务中使用。 如果在事务中运行，请不要为操作明确设置写关注点。要对事务使用写关注，请参见 事务和写关注。 重要 在大多数情况下，与单文档写入相比，多文档事务产生的性能成本更高，并且多文档事务的可用性不应替代有效的架构设计。在许多情况下， 非规范化数据模型（嵌入式文档和数组）将继续是您的数据和用例的最佳选择。也就是说，在许多情况下，适当地对数据建模将最大程度地减少对多文档交易的需求。 有关其他事务使用方面的注意事项（例如运行时限制和操作日志大小限制），另请参见 生产注意事项。 例子 删除单个文档 orders集合包含具有以下结构的文档： { _id: ObjectId(\"563237a41a4d68582c2509da\"), stock: \"Brent Crude Futures\", qty: 250, type: \"buy-limit\", limit: 48.90, creationts: ISODate(\"2015-11-01T12:30:15Z\"), expiryts: ISODate(\"2015-11-01T12:35:15Z\"), client: \"Crude Traders Inc.\" } 以下操作使用_id: ObjectId(\"563237a41a4d68582c2509da\")删除 order： try { db.orders.deleteOne( { \"_id\" : ObjectId(\"563237a41a4d68582c2509da\") } ); } catch (e) { print(e); } 操作返回： { \"acknowledged\" : true, \"deletedCount\" : 1 } 以下操作删除expiryts大于ISODate(\"2015-11-01T12:40:15Z\")的第一个文档 try { db.orders.deleteOne( { \"expiryts\" : { $lt: ISODate(\"2015-11-01T12:40:15Z\") } } ); } catch (e) { print(e); } 操作返回： { \"acknowledged\" : true, \"deletedCount\" : 1 } 写作关注 deleteOne() 给定三个成员副本集，以下操作指定majority wtimeout，wtimeout 100： try { db.orders.deleteOne( { \"_id\" : ObjectId(\"563237a41a4d68582c2509da\") }, { w : \"majority\", wtimeout : 100 } ); } catch (e) { print (e); } 如果确认时间超过wtimeout限制，则抛出以下 exception： WriteConcernError({ \"code\" : 64, \"errInfo\" : { \"wtimeout\" : true }, \"errmsg\" : \"waiting for replication timed out\" }) 指定排序规则 version 3.4 中的新内容。 整理允许用户为 string 比较指定 language-specific 规则，例如字母和重音标记的规则。 集合myColl具有以下文档： { _id: 1, category: \"café\", status: \"A\" } { _id: 2, category: \"cafe\", status: \"a\" } { _id: 3, category: \"cafE\", status: \"a\" } 以下操作包括整理选项： db.myColl.deleteOne( { category: \"cafe\", status: \"A\" }, { collation: { locale: \"fr\", strength: 1 } } ) 也可以看看 要删除多个文档，请参阅db.collection.deleteMany() Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-deleteMany.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-deleteMany.html","title":"db.collection.deleteMany()","keywords":"","body":" db.collection.deleteMany（） 在本页面 定义 行为 例子 定义 db.collection. deleteMany () 从集合中删除匹配filter的所有文档。 db.collection.deleteMany( , { writeConcern: , collation: } ) 参数 类型 描述 filter document 使用query operators指定删除条件。 要删除集合中的所有文档，请传入一个空文档({ })。 writeConcern document 可选的。表示写关注的文件。省略使用默认写入问题。 collation document 可选的。 指定要用于操作的整理。 整理允许用户为 string 比较指定 language-specific 规则，例如字母和重音标记的规则。 排序规则选项具有以下语法： 排序规则：{ locale：， caseLevel：， caseFirst：， strength：， numericOrdering：， alternate：， maxVariable：， backwards ： } 指定排序规则时，locale字段是必填字段;所有其他校对字段都是可选的。有关字段的说明，请参阅整理文件。 如果未指定排序规则但集合具有默认排序规则(请参阅db.createCollection())，则操作将使用为集合指定的排序规则。 如果没有为集合或操作指定排序规则，MongoDB 使用先前版本中用于 string 比较的简单二进制比较。 您无法为操作指定多个排序规则。对于 example，您不能为每个字段指定不同的排序规则，或者如果使用排序执行查找，则不能对查找使用一个排序规则，而对排序使用另一个排序规则。 version 3.4 中的新内容。 返回： 包含以下内容的文档： boolean acknowledged as true如果操作使用写关注或false运行，如果写入关注被禁用 deletedCount包含已删除文档的数量 行为 上限集合 如果在上限集合上使用，deleteMany()会抛出WriteError exception。要从上限集合中删除所有文档，请改用db.collection.drop()。 删除单个文档 要删除单个文档，请改用db.collection.deleteOne()。 或者，使用独特的指数的一部分字段，例如_id。 事务 db.collection.deleteMany()可以在多文档事务中使用。 如果在事务中运行，请不要为操作明确设置写关注点。要对事务使用写关注，请参见 事务和写关注。 重要 在大多数情况下，与单文档写入相比，多文档事务产生的性能成本更高，并且多文档事务的可用性不应替代有效的架构设计。在许多情况下， 非规范化数据模型（嵌入式文档和数组）将继续是您的数据和用例的最佳选择。也就是说，在许多情况下，适当地对数据建模将最大程度地减少对多文档交易的需求。 有关其他事务使用方面的注意事项（例如运行时限制和操作日志大小限制），另请参见 生产注意事项。 例子 删除多个文档 orders集合包含具有以下结构的文档： { _id: ObjectId(\"563237a41a4d68582c2509da\"), stock: \"Brent Crude Futures\", qty: 250, type: \"buy-limit\", limit: 48.90, creationts: ISODate(\"2015-11-01T12:30:15Z\"), expiryts: ISODate(\"2015-11-01T12:35:15Z\"), client: \"Crude Traders Inc.\" } 以下操作将删除client : \"Crude Traders Inc.\"所有文档： try { db.orders.deleteMany( { \"client\" : \"Crude Traders Inc.\" } ); } catch (e) { print (e); } 操作返回： { \"acknowledged\" : true, \"deletedCount\" : 10 } 以下操作将删除stock : \"Brent Crude Futures\"和limit大于48.88的所有文档： try { db.orders.deleteMany( { \"stock\" : \"Brent Crude Futures\", \"limit\" : { $gt : 48.88 } } ); } catch (e) { print (e); } 操作返回： { \"acknowledged\" : true, \"deletedCount\" : 8 } 写作关注 deleteMany() 给定三个成员副本集，以下操作指定majority majority和wtimeout 100： try { db.orders.deleteMany( { \"client\" : \"Crude Traders Inc.\" }, { w : \"majority\", wtimeout : 100 } ); } catch (e) { print (e); } 如果确认时间超过wtimeout限制，则抛出以下 exception： WriteConcernError({ \"code\" : 64, \"errInfo\" : { \"wtimeout\" : true }, \"errmsg\" : \"waiting for replication timed out\" }) 指定排序规则 version 3.4 中的新内容。 整理允许用户为 string 比较指定 language-specific 规则，例如字母和重音标记的规则。 集合myColl具有以下文档： { _id: 1, category: \"café\", status: \"A\" } { _id: 2, category: \"cafe\", status: \"a\" } { _id: 3, category: \"cafE\", status: \"a\" } 以下操作包括整理选项： db.myColl.deleteMany( { category: \"cafe\", status: \"A\" }, { collation: { locale: \"fr\", strength: 1 } } ) Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-distinct.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-distinct.html","title":"db.collection.distinct()","keywords":"","body":" db.collection.distinct（） 在本页面 定义 选项 行为 例子 定义 db.collection. distinct(字段，查询，选项) 在单个集合或视图中查找指定字段的不同值，并在 array 中返回结果。 参数 类型 描述 field string 要为其返回不同值的字段。 query document 一个查询，指定从中检索不同值的文档。 options document 可选的。指定选项的文档。见选项。 db.collection.distinct()方法在不同命令周围提供 wrapper。 注意 结果不得大于最大BSON 大小。如果结果超过最大 BSON 大小，请使用聚合管道使用$group operator 检索不同的值，如使用聚合管道检索不同的值中所述。 选项 { collation: } 领域 类型 描述 collation document 可选的。指定要用于操作的整理。整理允许用户为 string 比较指定 language-specific 规则，例如字母和重音标记的规则。排序规则选项具有以下语法：collation: { locale: , caseLevel: , caseFirst: , strength: , numericOrdering: , alternate: , maxVariable: , backwards: }指定排序规则时，locale字段是必填字段;所有其他校对字段都是可选的。有关字段的说明，请参阅整理文件。 如果未指定排序规则但集合具有默认排序规则(请参阅db.createCollection())，则操作将使用为集合指定的排序规则。如果没有为集合或操作指定排序规则，MongoDB 使用先前版本中用于 string 比较的简单二进制比较。 您无法为操作指定多个排序规则。对于 example，您不能为每个字段指定不同的排序规则，或者如果使用排序执行查找，则不能对查找使用一个排序规则，而对排序使用另一个排序规则。 version 3.4 中的新内容。 行为 在分片集群中，不同命令可能返回孤立文档。 数组字段 如果指定的field的 value 是 array，则db.collection.distinct()将 array 的每个元素视为单独的 value。 例如，如果某个字段的 value 为[ 1, [1], 1 ]，则db.collection.distinct()将1，[1]和1视为单独的值。 对于 example，请参阅返回 Array 字段的不同值。 索引使用 如果可能，db.collection.distinct()操作可以使用索引。 索引也可以覆盖 db.collection.distinct()操作。有关索引涵盖的查询的详细信息，请参阅涵盖查询。 事务 在事务中执行不同的操作： 对于未分片的集合，您可以在舞台上使用 db.collection.distinct()方法/ distinct命令以及聚合管道$group。 对于分片集合，不能使用 db.collection.distinct()方法或 distinct命令。 要查找分片集合的不同值，请在$group阶段使用聚合管道。有关详细信息，请参见“ 区别操作 ”。 重要 在大多数情况下，与单文档写入相比，多文档事务产生的性能成本更高，并且多文档事务的可用性不应替代有效的架构设计。在许多情况下， 非规范化数据模型（嵌入式文档和数组）将继续是您的数据和用例的最佳选择。也就是说，在许多情况下，适当地对数据建模将最大程度地减少对多文档交易的需求。 有关其他事务使用方面的注意事项（例如运行时限制和操作日志大小限制），另请参见 生产注意事项。 客户端断开 从MongoDB 4.2开始，如果发出db.collection.distinct()断开连接的客户端在操作完成之前断开连接，则MongoDB将标记db.collection.distinct()为终止（即killOp在操作上）。 例子 这些示例使用包含以下文档的inventory集合： { \"_id\": 1, \"dept\": \"A\", \"item\": { \"sku\": \"111\", \"color\": \"red\" }, \"sizes\": [ \"S\", \"M\" ] } { \"_id\": 2, \"dept\": \"A\", \"item\": { \"sku\": \"111\", \"color\": \"blue\" }, \"sizes\": [ \"M\", \"L\" ] } { \"_id\": 3, \"dept\": \"B\", \"item\": { \"sku\": \"222\", \"color\": \"blue\" }, \"sizes\": \"S\" } { \"_id\": 4, \"dept\": \"A\", \"item\": { \"sku\": \"333\", \"color\": \"black\" }, \"sizes\": [ \"S\" ] } 返回字段的不同值 以下 example 从inventory集合中的所有文档返回字段dept的不同值： db.inventory.distinct( \"dept\" ) 该方法返回以下 array 不同的dept值： [ \"A\", \"B\" ] 返回嵌入字段的不同值 以下 example 从inventory集合中的所有文档返回嵌入在item字段中的字段sku的不同值： db.inventory.distinct( \"item.sku\" ) 该方法返回以下 array 不同的sku值： [ \"111\", \"222\", \"333\" ] 也可以看看 点符号有关访问嵌入文档中的字段的信息 返回 Array 字段的不同值 以下 example 从inventory集合中的所有文档返回字段sizes的不同值： db.inventory.distinct( \"sizes\" ) 该方法返回以下 array 不同的sizes值： [ \"M\", \"S\", \"L\" ] 有关distinct()和 array 字段的信息，请参阅行为部分。 使用 distinct 指定 Query 以下 example 从dept等于\"A\"的文档中返回嵌入在item字段中的字段sku的不同值： db.inventory.distinct( \"item.sku\", { dept: \"A\" } ) 该方法返回以下 array 不同的sku值： [ \"111\", \"333\" ] 指定排序规则 version 3.4 中的新内容。 整理允许用户为 string 比较指定 language-specific 规则，例如字母和重音标记的规则。 集合myColl具有以下文档： { _id: 1, category: \"café\", status: \"A\" } { _id: 2, category: \"cafe\", status: \"a\" } { _id: 3, category: \"cafE\", status: \"a\" } 以下聚合操作包括整理选项： db.myColl.distinct( \"category\", {}, { collation: { locale: \"fr\", strength: 1 } } ) 有关归类字段的说明，请参阅整理文件。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-drop.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-drop.html","title":"db.collection.drop()","keywords":"","body":" db.collection.drop（） 在本页面 定义 行为 例子 定义 db.collection.drop() 从数据库中删除集合或视图。该方法还会删除与已删除集合关联的所有索引。该方法在下降命令周围提供 wrapper。 db.collection.drop()的形式如下： 在版本4.0中更改：db.collection.drop()接受选项文档。 db.collection.drop() db.collection.drop()接受具有以下字段的可选文档： 字段 描述 writeConcern 可选的。表示操作的写关注点的 文档db.collection.drop()。省略使用默认的写关注。当分片群集上发出，mongos转换 写入关注的的 drop命令及其助手 db.collection.drop()来\"majority\"。版本4.0中的新功能。 返回： true成功删除集合时。 false当不存在要收集的集合时。 行为 该db.collection.drop()方法和drop命令为在删除的集合上打开的任何 变更流创建一个无效事件。 从MongoDB 4.0.2开始，删除集合将删除其关联的区域/标签范围。 资源锁定 在版本4.2中进行了更改。 db.collection.drop()在操作期间获得对指定集合的排他锁。集合上的所有后续操作都必须等到db.collection.drop()释放锁为止。 在MongoDB 4.2之前的版本中，db.collection.drop()获得了对父数据库的排他锁，阻止了对数据库及其所有集合的所有操作，直到操作完成。 例子 使用默认写入问题删除集合 以下操作将students集合拖放到当前数据库中。 db.students.drop() 使用Write Concern 删除一个集合w: \"majority\" 在版本4.0中更改：db.collection.drop()接受选项文档。 以下操作将students集合拖放到当前数据库中。该操作使用\"majority\"写关注点： db.students.drop( { writeConcern: { w: \"majority\" } } ) Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-dropIndex.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-dropIndex.html","title":"db.collection.dropIndex()","keywords":"","body":" db.collection.dropIndex（） 在本页面 定义 例子 定义 db.collection.dropIndex(索引) 从集合中删除或删除指定的索引。 db.collection.dropIndex()方法在dropIndexes命令周围提供包装。 注意 您不能删除_id字段上的默认索引。 从MongoDB 4.2开始，您不能指定 db.collection.dropIndex(\"*\")删除所有非_id索引。使用 db.collection.dropIndexes()代替。 db.collection.dropIndex()方法采用以下参数： 参数 类型 描述 index string or document 指定要删除的索引。您可以通过索引 name 或索引规范文档指定索引。 [1] 要删除文本索引，请指定索引 name。从MongoDB 4.2开始，您不能指定\"*\"删除所有非_id索引。使用 db.collection.dropIndexes()代替。 要获取db.collection.dropIndex()方法的索引 name 或索引规范文档，请使用db.collection.getIndexes()方法。 警告 此命令在受影响的数据库上获取写锁定，并将阻止其他操作，直到完成为止。 行为 从MongoDB 4.2开始，该dropIndex()操作只会终止使用正在删除的索引的查询。这可能包括将索引视为查询计划一部分的 查询。 在MongoDB 4.2之前，在集合上删除索引将杀死该集合上所有打开的查询。 资源锁定 在版本4.2中进行了更改。 db.collection.dropIndex()在操作期间获得对指定集合的排他锁。集合上的所有后续操作都必须等到db.collection.dropIndex()释放锁为止。 在MongoDB 4.2之前的版本中，db.collection.dropIndex()获得了对父数据库的排他锁，阻止了对数据库及其所有集合的所有操作，直到操作完成。 例子 考虑一个pets集合。在pets集合上调用getIndexes()方法将返回以下索引： [ { “v“ : 1, “key“ : { “_id“ : 1 }, “ns“ : “test.pets“, “name“ : “_id_“ }, { “v“ : 1, “key“ : { “cat“ : -1 }, “ns“ : “test.pets“, “name“ : “catIdx“ }, { “v“ : 1, “key“ : { “cat“ : 1, “dog“ : -1 }, “ns“ : “test.pets“, “name“ : “cat_1_dog_-1“ } ] 字段上的单个字段索引cat具有用户指定的名称catIdx [2]和索引指定文档为 。{ \"cat\" : -1 } 要删除索引catIdx，可以使用索引 name： db.pets.dropIndex( “catIdx“ ) 或者您可以使用索引规范文档{ “cat“ : -1 }： db.pets.dropIndex( { “cat“ : -1 } ) [1] (1，2)在 2.2.2 之前使用mongo shell version 时，如果在创建索引期间指定了 name，则必须使用 name 删除索引。 [2] 在创建索引期间，如果用户不**指定索引 name，则系统通过将索引 key 字段和 value 与下划线如：连接来生成 name。 cat_1。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-dropIndexes.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-dropIndexes.html","title":"db.collection.dropIndexes()","keywords":"","body":" db.collection.dropIndexes（） 在本页面 定义 行为 定义 db.collection. dropIndexes () _id从集合中删除指定的一个或多个索引（字段中的索引除外 ）。 您可以使用该方法执行以下操作： _id从集合中删除除索引之外的所有内容。 db.collection.dropIndexes() 从集合中删除指定的索引。要指定索引，可以通过以下方法之一： 索引规范文档（除非索引是 文本索引，在这种情况下，请使用索引名称删除）： db.collection.dropIndexes( { a: 1, b: 1 } ) 索引名称： db.collection.dropIndexes( \"a_1_b_1\" ) 建议 若要获取索引的名称，请使用 db.collection.getIndexes()方法。 从集合中删除指定的索引。（从MongoDB 4.2开始可用）。要指定要删除的多个索引，请向该方法传递一个索引名称数组： db.collection.dropIndexes( [ \"a_1_b_1\", \"a_1\", \"a_1__id_-1\" ] ) 如果索引名称数组包含不存在的索引，则该方法将出错，而不会删除任何指定的索引。 建议 若要获取索引的名称，请使用 db.collection.getIndexes()方法。 db.collection.dropIndexes()方法采用以下可选参数： 参数 类型 描述 indexes string 或 document 或 array of strings 可选的。指定要删除的一个或多个索引。要删除集合中除_id索引以外的所有索引，请省略参数。要删除单个索引，请指定索引名称，索引规范文档（除非索引是 文本索引）或索引名称的数组。要删除文本索引，请指定索引名称或索引名称的数组，而不是索引规范文档。要删除多个索引（从MongoDB 4.2开始可用），请指定一个索引名称数组。 db.collection.dropIndexes()是围绕着一个包装 dropIndexes命令。 行为 只kill相关查询 从MongoDB 4.2开始，该dropIndexes()操作只会终止使用正在删除的索引的查询。这可能包括将索引视为查询计划一部分的 查询。 在MongoDB 4.2之前，在集合上删除索引将杀死该集合上所有打开的查询。 资源锁定 在版本4.2中进行了更改。 db.collection.dropIndexes()在操作期间获得对指定集合的排他锁。集合上的所有后续操作都必须等到db.collection.dropIndexes()释放锁为止。 在MongoDB 4.2之前的版本中，db.collection.dropIndexes()获得了对父数据库的排他锁，阻止了对数据库及其所有集合的所有操作，直到操作完成。 索引名称 如果给该方法传递了一个包含不存在的索引的索引名数组，则该方法将出错，而不会删除任何指定的索引。 _id索引 您不能在_id字段上删除默认索引。 文本索引 要删除文本索引，请指定索引名称而不是索引规范文档。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-ensureIndex.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-ensureIndex.html","title":"db.collection.ensureIndex()","keywords":"","body":" db.collection.ensureIndex（） 在本页面 定义 附加信息 定义 db.collection. ensureIndex(键，选项) 从3.0.0版开始不推荐使用：db.collection.ensureIndex()现在是的别名 db.collection.createIndex()。 如果索引尚不存在，则在指定字段上创建索引。 附加信息 使用db.collection.createIndex()而不是db.collection.ensureIndex()来创建新索引。 本手册的索引部分用于 MongoDB 中索引和索引的完整文档。 db.collection.getIndexes()查看集合的现有索引的规范。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-explain.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-explain.html","title":"db.collection.explain()","keywords":"","body":" db.collection.explain（） 在本页面 定义 行为 例子 输出 定义 db.collection. explain () 返回有关以下方法的查询计划的信息： 从MongoDB 3.0开始 从MongoDB 3.2开始 aggregate()count() find()remove() update() distinct()findAndModify() 若要使用db.collection.explain()，请将上述方法之一附加到db.collection.explain()： db.collection.explain(). 例如， db.products.explain().remove( { category: \"apparel\" }, { justOne: true } ) 有关更多示例，请参阅例子。有关可用于db.collection.explain()的方法列表，请参阅db.collection.explain().help()。 db.collection.explain()方法具有以下参数： 参数 类型 描述 verbosity string 可选的。指定解释输出的详细模式。该模式会影响explain()的行为并确定要 return 的信息量。可能的模式是：\"queryPlanner\"，\"executionStats\"和\"allPlansExecution\"。 默认模式为\"queryPlanner\"。 为了向后兼容早期版本的cursor.explain()，MongoDB 将true解释为\"allPlansExecution\"，将false解释为\"queryPlanner\"。 有关模式的更多信息，请参阅详细模式。 行为 详细模式 db.collection.explain()的行为和返回的信息量取决于verbosity模式。 queryPlanner 模式 默认情况下，db.collection.explain()在queryPlanner详细模式下运行。 MongoDB 运行查询优化器来为 evaluation 下的操作选择获胜计划。 db.collection.explain()返回已评估方法的queryPlanner信息。 executionStats 模式 MongoDB 运行查询优化器来选择获胜计划，执行获胜计划以完成，并返回描述获胜计划执行的统计数据。 对于写入操作，db.collection.explain()返回有关将执行的更新或删除操作的信息，但不会将修改应用于数据库。 db.collection.explain()返回已评估方法的queryPlanner和executionStats信息。但是，executionStats不提供被拒绝计划的查询执行信息。 allPlansExecution 模式 MongoDB 运行查询优化器来选择获胜计划并执行获胜计划以完成。在\"allPlansExecution\"模式中，MongoDB 返回描述获胜计划执行情况的统计信息以及计划选择期间捕获的其他候选计划的统计信息。 对于写入操作，db.collection.explain()返回有关将执行的更新或删除操作的信息，但不会将修改应用于数据库。 db.collection.explain()返回已评估方法的queryPlanner和executionStats信息。 executionStats包括获胜计划的完整查询执行信息。 如果查询优化器考虑了多个计划，executionStats信息还包括在计划选择阶段期间为获胜和被拒绝的候选计划捕获的部分执行信息。 Explain and Write Operations 对于写操作，db.collection.explain()返回有关将要执行但实际上并未修改数据库的写操作的信息。 Restrictions 在MongoDB中4.2开始，你不能运行explain命令/ db.collection.explain()在executionStats模式或allPlansExecution一个模式包含阶段。相反，您可以：aggregation pipeline $out 以queryPlanner方式运行说明 在executionStats模式或allPlansExecution 模式下运行说明，但没有该$out阶段以返回该阶段之前的$out阶段的信息。 explain() Mechanics db.collection.explain()方法包装说明命令，是 run 说明的首选方法。 db.collection.explain().find()类似于db.collection.find().explain()，以下 key 差异： db.collection.explain().find()结构允许额外链接查询修饰符。有关查询修饰符的列表，请参见db.collection.explain().find().help()。 db.collection.explain().find()返回一个游标，它需要调用.next()或其别名.finish()来_return explain()结果。如果在mongo shell 中以交互方式 run，mongo shell 会自动 calls .finish()来_return 结果。但是，对于脚本，必须显式调用.next()或.finish()来_return 结果。有关 cursor-related 方法的列表，请参阅db.collection.explain().find().help()。 db.collection.explain().aggregate()相当于将说明选项传递给db.collection.aggregate()方法。 help() 要查看db.collection.explain()，run 支持的操作列表： db.collection.explain().help() db.collection.explain().find()返回一个游标，允许链接查询修饰符。要查看db.collection.explain().find()以及 cursor-related 方法支持的查询修饰符列表，润： db.collection.explain().find().help() 您可以将多个修改器链接到db.collection.explain().find()。对于 example，请参阅用修饰符解释 find()。 例子 queryPlanner 模式 默认情况下，db.collection.explain()在\"queryPlanner\"详细模式下运行。 以下 example 在“queryPlanner” 详细模式下运行db.collection.explain()以返回指定count()操作的查询计划信息： db.products.explain().count( { quantity: { $gt: 50 } } ) executionStats 模式 以下 example 在“executionStats” verbosity 模式下运行db.collection.explain()以_return 指定find()操作的查询计划和执行信息： db.products.explain(\"executionStats\").find( { quantity: { $gt: 50 }, category: \"apparel\" } ) allPlansExecution 模式 以下 example 在“allPlansExecution” verbosity 模式下运行db.collection.explain()。对于指定的update()操作，db.collection.explain()为所有考虑的计划返回queryPlanner和executionStats： 注意 执行此解释不会修改数据，而是运行更新操作的查询谓词。对于候选计划，MongoDB 返回计划选择阶段期间捕获的执行信息。 db.products.explain(\"allPlansExecution\").update( { quantity: { $lt: 1000}, category: \"apparel\" }, { $set: { reorder: true } } ) 用修饰符解释 find() db.collection.explain().find() construct 允许链接查询修饰符。对于 example，以下操作使用sort()和hint()查询修饰符提供有关find()方法的信息。 db.products.explain(\"executionStats\").find( { quantity: { $gt: 50 }, category: \"apparel\" } ).sort( { quantity: -1 } ).hint( { category: 1, quantity: -1 } ) 有关可用的查询修饰符列表，shell 中的 run： db.collection.explain().find().help() 迭代 explain().find() Return 游标 db.collection.explain().find()将光标返回到解释结果。如果在mongo shell 中以交互方式 run，mongo shell 将使用.next()方法自动迭代游标。但是，对于脚本，必须显式调用.next()(或其别名.finish())来_return 结果： var explainResult = db.products.explain().find( { category: \"apparel\" } ).next(); 输出 db.collection.explain()操作可以 return 以下信息： queryPlanner，详细说明查询优化器选择的计划，列出被拒绝的计划; executionStats，详细说明获胜计划的执行情况和被拒绝的计划;和 serverInfo，提供有关 MongoDB 实例的信息。 详细程度模式(即：queryPlanner，executionStats，allPlansExecution)确定结果是否包含executionStats以及executionStats是否包含计划选择期间捕获的数据。 有关输出的详细信息，请参阅解释结果。 对于具有 version 3.0 mongos和至少一个 2.6 mongod分片的混合 version 分片 cluster，当您在 version 3.0 mongo shell 中 run db.collection.explain()时，db.collection.explain()将使用$explain operator 重试_ret以 2.6 格式返回结果。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-find.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-find.html","title":"db.collection.find()","keywords":"","body":" db.collection.find（） 在本页面 定义 行为 例子 定义 db.collection. find(查询，投影) 选择集合或视图中的文档，并将光标返回到所选文档。 参数 类型 描述 query document 可选的。使用query operators指定选择过滤器。要 return 集合中的所有文档，请省略此参数或传递空文档({})。 projection document 可选的。指定_retch 查询过滤器的文档中的 return 字段。要_retret 匹配文档中的所有字段，请省略此参数。有关详细信息，请参阅投影。 返回： 与匹配query标准的文档。当find()方法“返回文档”时，该方法实际上是将光标返回到文档。 行为 投影 projection参数确定匹配文档中返回的字段。 projection参数采用以下形式的文档： { field1: , field2: ... } 可以是以下任何一种： 1或true在 return 文档中包含该字段。 0或false排除该字段。 表达式使用投影操作员。 find()视图操作不支持以下投影 operators： $ $elemMatch $slice $meta 注意 对于_id字段，您不必明确指定_id: 1来_return _id字段。除非指定_id: 0以禁止字段，否则find()方法始终返回_id字段。 除了排除_id字段外，projection不能同时包含 include 和 exclude 规范。在明确包含字段的投影中，_id字段是您可以显式排除的唯一字段。 游标处理 在mongo shell 中执行db.collection.find()会自动迭代光标以显示前 20 个文档。键入it以继续迭代。 要使用驱动程序访问返回的文档，请使用适当的司机语言光标处理机制。 也可以看看 迭代返回的游标 修改光标行为 可用的mongo Shell游标方法 阅读关注 要为db.collection.find()指定阅读关注，请使用cursor.readConcern()方法。 包装类型 MongoDB 将某些数据类型视为等效用于比较目的。例如，数字类型在比较之前进行转换。但是，对于大多数数据类型，比较 operators仅对目标字段的BSON 类型与查询操作数的类型匹配的文档执行比较。考虑以下集合： { \"_id\": \"apples\", \"qty\": 5 } { \"_id\": \"bananas\", \"qty\": 7 } { \"_id\": \"oranges\", \"qty\": { \"in stock\": 8, \"ordered\": 12 } } { \"_id\": \"avocados\", \"qty\": \"fourteen\" } 以下查询使用$gt来 return qty的 value 大于4的文档。 db.collection.find( { qty: { $gt: 4 } } ) 该查询返回以下文档： { \"_id\": \"apples\", \"qty\": 5 } { \"_id\": \"bananas\", \"qty\": 7 } 不返回_id等于\"avocados\"的文档，因为qty value 的类型为string而$gt操作数的类型为integer。 不返回_id等于\"oranges\"的文档，因为其qty value 的类型为object。 注意 要在集合中强制执行数据类型，请使用Schema 验证。 会话 版本4.0中的新功能。 对于在会话内创建的游标，不能getMore在会话外调用 。 同样，对于在会话外部创建的游标，不能getMore在会话内部调用 。 会话空闲超时 从MongoDB 3.6开始，MongoDB驱动程序和mongoshell程序将所有操作与服务器会话相关联，但未确认的写操作除外。对于未与会话明确关联的操作（即使用Mongo.startSession()），MongoDB驱动程序和mongo外壳程序会创建一个隐式会话并将其与该操作相关联。 如果会话空闲时间超过30分钟，则MongoDB服务器会将会话标记为已过期，并可以随时关闭它。当MongoDB服务器关闭会话时，它还会终止所有正在进行的操作并打开与该会话关联的游标。这包括配置了30分钟noCursorTimeout或maxTimeMS30分钟以上的光标。 对于可能闲置超过30分钟的操作，请使用将该操作与显式会话相关联， Session.startSession()并使用该refreshSessions命令定期刷新该会话。请参阅以获取更多信息。Session Idle Timeout 交易 db.collection.find()可以在多文档交易中使用。 对于在事务外部创建的游标，不能getMore在事务内部调用 。 对于在事务中创建的游标，不能getMore在事务外部调用 。 重要 在大多数情况下，与单文档写入相比，多文档事务产生的性能成本更高，并且多文档事务的可用性不应替代有效的架构设计。在许多情况下， 非规范化数据模型（嵌入式文档和数组）将继续是您的数据和用例的最佳选择。也就是说，在许多情况下，适当地对数据建模将最大程度地减少对多文档交易的需求。 有关其他事务使用方面的注意事项（例如运行时限制和操作日志大小限制），另请参见 生产注意事项。 客户端断开 从MongoDB 4.2开始，如果发出db.collection.find() 断开连接的客户端在操作完成之前断开连接，则MongoDB将标记db.collection.find()为终止（即killOp在操作上）。 例子 本节中的示例使用bios 集合中的文档，其中文档通常具有以下形式： { \"_id\" : , \"name\" : { \"first\" : , \"last\" : }, // embedded document \"birth\" : , \"death\" : , \"contribs\" : [ , ... ], // Array of Strings \"awards\" : [ { \"award\" : , year: , by: } // Array of embedded documents ... ] } 要创建和填充bios集合，请参阅bios Example Collection。 查找集合中的所有文档 没有参数的find()方法返回集合中的所有文档，并返回文档的所有字段。对于 example，以下操作返回bios 系列中的所有文档： db.bios.find() 查找 Match 查询条件的文档 查询平等 以下操作返回bios 系列中_id等于5的文档： db.bios.find( { _id: 5 } ) 以下操作返回bios 系列中的文档，其中name嵌入文档中的字段last等于\"Hopper\"： db.bios.find( { \"name.last\": \"Hopper\" } ) 注意 要访问嵌入文档中的字段，请使用点符号(\".\")。 使用 Operators 进行查询 要查找匹配一组选择条件的文档，请使用参数调用find()。 MongoDB 提供各种query operators来指定标准。 以下操作使用$in operator return bios 系列中的文档，其中_id等于5或ObjectId(\"507c35dd8fada716c89d0013\")： db.bios.find( { _id: { $in: [ 5, ObjectId(\"507c35dd8fada716c89d0013\") ] } } ) 以下操作使用$gt operator 返回bios集合中birth大于new Date('1950-01-01')的所有文档： db.bios.find( { birth: { $gt: new Date('1950-01-01') } } ) 以下操作使用$regex operator return bios 系列中的文档，其中name.last字段以字母N(或\"LIKE N%\")开头 db.bios.find( { \"name.last\": { $regex: /^N/ } } ) 有关查询 operators 的列表，请参阅查询 Selectors。 查询范围 组合比较 operators 以指定字段的范围。以下操作从bios 系列文档返回，其中birth介于new Date('1940-01-01')和new Date('1960-01-01')之间(独占)： db.bios.find( { birth: { $gt: new Date('1940-01-01'), $lt: new Date('1960-01-01') } } ) 有关查询 operators 的列表，请参阅查询 Selectors。 查询多个条件 以下操作返回bios 系列中的所有文档，其中birth字段为比...更棒 new Date('1950-01-01')且death字段不存在： db.bios.find( { birth: { $gt: new Date('1920-01-01') }, death: { $exists: false } } ) 有关查询 operators 的列表，请参阅查询 Selectors。 查询嵌入式文档 以下示例查询bios 系列中的name嵌入字段。 查询嵌入式文档的精确匹配 以下操作返回bios 系列中的文档，其中嵌入的文档name正好是{ first: \"Yukihiro\", last: \"Matsumoto\" }，包括 order： db.bios.find( { name: { first: \"Yukihiro\", last: \"Matsumoto\" } } ) name字段必须完全匹配嵌入文档。查询将使文档与具有name以下任一值的字段进行匹配： { first: \"Yukihiro\", aka: \"Matz\", last: \"Matsumoto\" } { last: \"Matsumoto\", first: \"Yukihiro\" } 查询嵌入文档的字段 以下操作返回bios 系列中的文档，其中嵌入文档name包含带有 value \"Yukihiro\"的字段first和带有 value \"Matsumoto\"的字段last。该查询使用点符号访问嵌入文档中的字段： db.bios.find( { \"name.first\": \"Yukihiro\", \"name.last\": \"Matsumoto\" } ) 该查询匹配name字段包含嵌入文档的文档，其中first字段包含 value \"Yukihiro\"，字段last包含 value \"Matsumoto\"。例如，查询将使用包含以下任一值的name字段匹配文档： { first: \"Yukihiro\", aka: \"Matz\", last: \"Matsumoto\" } { last: \"Matsumoto\", first: \"Yukihiro\" } 有关更多信息和示例，另请参阅查询 Embedded/Nested 文档。 查询数组 查询 Array 元素 以下示例查询bios 系列中的contribs array。 以下操作返回bios 系列中的文档，其中 array 字段contribs包含元素\"UNIX\"： db.bios.find( { contribs: \"UNIX\" } ) 以下操作返回bios 系列中的文档，其中 array 字段contribs包含元素\"ALGOL\"或\"Lisp\"： db.bios.find( { contribs: { $in: [ \"ALGOL\", \"Lisp\" ]} } ) 以下操作使用$all query operator return bios 系列中的文档，其中 array 字段contribs包含元素\"ALGOL\"和\"Lisp\"： db.bios.find( { contribs: { $all: [ \"ALGOL\", \"Lisp\" ] } } ) 有关更多示例，请参阅$all。另见$elemMatch。 以下操作使用$size operator return bios 系列中contribs的 array 大小为 4 的文档：db.bios.find( { contribs: { $size: 4 } } ) 有关查询 array 的更多信息和示例，请参阅： 查询 Array 查询嵌入式文档的 Array 有关 array 特定查询 operators 的列表，请参阅Array。 查询 Array of Documents 以下示例查询bios 系列中的awards array。 以下操作返回bios 系列中的文档，其中awards array 包含award字段等于\"Turing的元素： db.bios.find( { \"awards.award\": \"Turing Award\" } ) 以下操作返回bios 系列中的文档，其中awards array 包含至少一个元素，其中award字段等于\"Turing Award\"且year字段大于 1980： db.bios.find( { awards: { $elemMatch: { award: \"Turing Award\", year: { $gt: 1980 } } } } ) 使用$elemMatch operator 在 array 元素上指定多个条件。 有关查询 array 的更多信息和示例，请参阅： 查询 Array 查询嵌入式文档的 Array 有关 array 特定查询 operators 的列表，请参阅Array。 预测 projection参数指定 return 的哪些字段。除非排除属于_id字段，否则该参数包含 include 或 exclude 规范，而不是两者。 注意 除非在投影文档_id: 0中明确排除_id字段，否则返回_id字段。 指定 Return 的字段 以下操作查找bios 系列中的所有文档，并仅返回name字段，contribs字段和_id字段： db.bios.find( { }, { name: 1, contribs: 1 } ) 注意 除非在投影文档_id: 0中明确排除_id字段，否则返回_id字段。 明确排除的字段 以下操作查询bios 系列并返回除name嵌入文档和birth字段中的first字段之外的所有字段： db.bios.find( { contribs: 'OOP' }, { 'name.first': 0, birth: 0 } ) 明确排除_id 字段 注意 除非在投影文档_id: 0中明确排除_id字段，否则返回_id字段。 以下操作在bios 系列中查找文档，并仅返回name字段和contribs字段： db.bios.find( { }, { name: 1, contribs: 1, _id: 0 } ) 关于数组和嵌入式文档 以下操作查询bios 系列并返回name嵌入文档中的last字段和contribs array 中的前两个元素： db.bios.find( { }, { _id: 0, 'name.last': 1, contribs: { $slice: 2 } } ) 也可以看看 将项目字段设置为来自查询 迭代返回的光标 find()方法返回光标到结果。 在mongo shell 中，如果未使用var关键字将返回的游标分配给变量，则会自动迭代游标以访问最匹配查询的前 20 个文档。您可以设置DBQuery.shellBatchSize变量以更改自动迭代文档的数量。 要手动迭代结果，请将返回的光标分配给带有var关键字的变量，如以下部分所示。 使用 Variable Name 以下 example 使用变量myCursor迭代游标并打印匹配的文档： var myCursor = db.bios.find( ); myCursor 使用 next()方法 以下 example 使用游标方法next()来访问文档： var myCursor = db.bios.find( ); var myDocument = myCursor.hasNext() ? myCursor.next() : null; if (myDocument) { var myName = myDocument.name; print (tojson(myName)); } 要打印，您还可以使用printjson()方法而不是print(tojson())： if (myDocument) { var myName = myDocument.name; printjson(myName); } 使用 forEach()方法 以下 example 使用游标方法forEach()来迭代游标并访问文档： var myCursor = db.bios.find( ); myCursor.forEach(printjson); 修改游标行为 mongo shell 和司机提供了几个游标方法，这些方法调用find()方法返回的游标来修改其行为。 Order 结果集中的文档 sort()方法对结果集中的文档进行排序。以下操作返回name中按name字段按升序排序的文档中的文档： db.bios.find().sort( { name: 1 } ) sort()对应于 SQL 中的ORDER BY语句。 将文档数限制为 Return limit()方法限制结果集中的文档数。以下操作最多返回bios 系列中的5个文档： db.bios.find().limit( 5 ) limit()对应于 SQL 中的LIMIT语句。 设置结果集的起始点 skip()方法控制结果集的起始点。以下操作会跳过bios 系列中的第一个5文档并返回所有剩余文档： db.bios.find().skip( 5 ) 指定排序规则 整理允许用户为 string 比较指定 language-specific 规则，例如字母和重音标记的规则。 collation()方法为db.collection.find()操作指定整理。 db.bios.find( { \"name.last\": \"hopper\" } ).collation( { locale: \"en_US\", strength: 1 } ) 结合光标方法 以下 statements 链游标方法limit()和sort()： db.bios.find().sort( { name: 1 } ).limit( 5 ) db.bios.find().limit( 5 ).sort( { name: 1 } ) 这两个语句是等价的; 即：你链接limit()和sort()方法的 order 并不重要。两个 statements return 前五个文档，由'name'上的升序排序 order 确定。 可用的mongoShell游标方法 cursor.allowDiskUse() cursor.allowPartialResults() cursor.batchSize() cursor.close() cursor.isClosed() cursor.collation() cursor.comment() cursor.count() cursor.explain() cursor.forEach() cursor.hasNext() cursor.hint() cursor.isExhausted() cursor.itcount() cursor.limit() cursor.map() cursor.max() cursor.maxTimeMS() cursor.min() cursor.next() cursor.noCursorTimeout() cursor.objsLeftInBatch() cursor.pretty() cursor.readConcern() cursor.readPref() cursor.returnKey() cursor.showRecordId() cursor.size() cursor.skip() cursor.sort() cursor.tailable() cursor.toArray() Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-findAndModify.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-findAndModify.html","title":"db.collection.findAndModify()","keywords":"","body":" db.collection.findAndModify（） 在本页面 定义 Return 数据 行为 例子 定义 db.collection. findAndModify(文件) 修改并返回单个文档。默认情况下，返回的文档不包括对更新所做的修改。要通过对更新进行的修改来回显文档，请使用new选项。 findAndModify()方法是findAndModify命令周围的 shell 助手。 findAndModify()方法具有以下形式： 更改了 version 3.6. db.collection.findAndModify({ query: , sort: , remove: , update: , new: , fields: , upsert: , bypassDocumentValidation: , writeConcern: , collation: , arrayFilters: [ , ... ] }); db.collection.findAndModify()方法采用带有以下嵌入文档字段的文档参数： 参数 类型 描述 query document 可选的。修改的选择标准。 query字段使用与db.collection.find()方法中使用的query selectors相同的query selectors。虽然查询可能匹配多个文档，但findAndModify() 只会选择一个文档来修改。 如果未指定，则默认为空文档。 从 MongoDB 3.6.14(和 3.4.23)开始，如果查询参数不是文档，则操作错误。 sort document 可选的。如果查询选择多个文档，则确定操作修改的文档。 findAndModify()修改此参数指定的 sort order 中的第一个文档。 从 MongoDB 3.6.14(和 3.4.23)开始，如果 sort 参数不是文档，则操作错误。 remove boolean 必须指定remove或update字段。删除query字段中指定的文档。将其设置为true以删除所选文档。默认值为false。 update document 必须指定remove或update字段。执行所选文档的更新。 update字段使用相同的更新 operators或field: value规范来修改所选文档。 new boolean 可选的。当true时，返回修改后的文档而不是原始文档。 findAndModify()方法忽略remove操作的new选项。默认值为false。 fields document 可选的。 return 的字段子集。 fields文档指定包含1的字段，如：fields: { : 1, : 1, ... }。见投影。 从 MongoDB 3.6.14(和 3.4.23)开始，如果 fields 参数不是文档，则操作错误。 upsert boolean 可选的。与update字段结合使用。 当true，findAndModify()时：如果没有文件匹配query，则创建一个新文档。有关详细信息，请参阅upsert 行为。 更新与query匹配的单个文档。 要避免多次 upsert，请确保query字段为唯一索引。 默认为false。 bypassDocumentValidation boolean 可选的。允许db.collection.findAndModify在操作期间绕过文档验证。这使您可以更新不符合验证要求的文档。 version 3.2 中的新内容。 writeConcern document 可选的。表示写关注的文件。省略使用默认写入问题。 version 3.2 中的新内容。 maxTimeMS integer 可选的。指定处理操作的 time 限制(以毫秒为单位)。 collation document 可选的。 指定要用于操作的整理。 整理允许用户为 string 比较指定 language-specific 规则，例如字母和重音标记的规则。 排序规则选项具有以下语法：排序规则：{ locale：， caseLevel：， caseFirst：， strength：， numericOrdering：， alternate：， maxVariable：， backwards ： } 指定排序规则时，locale字段是必填字段;所有其他校对字段都是可选的。有关字段的说明，请参阅整理文件。 如果未指定排序规则但集合具有默认排序规则(请参阅db.createCollection())，则操作将使用为集合指定的排序规则。 如果没有为集合或操作指定排序规则，MongoDB 使用先前版本中用于 string 比较的简单二进制比较。 您无法为操作指定多个排序规则。对于 example，您不能为每个字段指定不同的排序规则，或者如果使用排序执行查找，则不能对查找使用一个排序规则，而对排序使用另一个排序规则。 version 3.4 中的新内容。 arrayFilters array 可选的。过滤器文档的 array，用于确定要在 array 字段上为更新操作修改哪些 array 元素。 在更新文档中，使用$ []过滤后的位置 operator 来定义标识符，然后在 array 过滤器文档中进行 reference。如果标识符未包含在更新文档中，则不能为标识符提供 array 过滤器文档。 注意 必须以小写字母开头，并且只包含字母数字字符。 您可以在更新文档中多次包含相同的标识符;但是，对于更新文档中的每个不同标识符($[identifier])，您必须指定恰好一个对应的 array 过滤器文档。也就是说，您不能为同一标识符指定多个 array 过滤器文档。对于 example，如果 update 语句包含标识符x(可能多次)，则不能为arrayFilters指定以下内容，其中包含 2 个单独的x过滤器文档：[ { \"x.a\": { $gt: 85 } }, { \"x.b\": { $gt: 80 } } ] 但是，您可以在同一标识符上指定复合条件单个过滤器文档，例如以下示例：// Example 1 [ { $or: [{\"x.a\": {$gt: 85}}, {\"x.b\": {$gt: 80}}] } ] // Example 2 [ { $and: [{\"x.a\": {$gt: 85}}, {\"x.b\": {$gt: 80}}] } ] // Example 3 [ { \"x.a\": { $gt: 85 }, \"x.b\": { $gt: 80 } } ]例如，请参阅为 Array Update Operations 指定 arrayFilters。 version 3.6 中的新内容。 Return 数据 对于删除操作，如果查询与文档匹配，findAndModify()将返回已删除的文档。如果查询未匹配要删除的文档，findAndModify()将返回null。 对于更新操作，findAndModify()返回以下之一： 如果未设置new参数或false： 如果查询与文档匹配，则为 pre-modification 文档; 否则，null。 如果new是true： 修改后的文档，如果查询返回 match; 插入的文档，如果upsert: true，没有文档与查询匹配; 否则，null。 更改 version 3.0：在以前的版本中，如果更新，sort已指定，upsert: true，new选项未设置或new: false，db.collection.findAndModify()将返回空文档{}而不是null。 行为 Upsert 和 Unique Index 当findAndModify()包含upsert: true选项并且查询 field(s)没有唯一索引时，该方法可以在某些情况下多次插入文档。 在下面的示例中，不存在 name Andy的文档，并且多个 clients 发出以下命令： db.people.findAndModify({ query: { name: \"Andy\" }, sort: { rating: 1 }, update: { $inc: { score: 1 } }, upsert: true }) 然后，如果这些 clients 的findAndModify()方法在任何命令启动modify阶段之前完成query阶段，和在name字段上没有唯一索引，则命令可以全部执行 upsert，创建多个重复文档。 要防止使用相同的 name 创建多个重复文档，请在name字段上创建独特的指数。有了这个唯一索引，多个方法将表现出以下行为之一： 正好一个findAndModify()成功插入一个新文档。 零个或多个findAndModify()方法更新新插入的文档。 零个或多个findAndModify()方法在尝试 Insert 具有相同 name 的文档时失败。如果由于name字段上的唯一索引约束违规而导致方法失败，则可以重试该方法。如果没有删除文档，则重试不应失败。 Sharded Collections 在分片环境中使用findAndModify时，query 必须包含针对分片集合的分片 cluster 的所有操作的碎片 key。 findAndModify针对非分片集合的mongos实例发出的操作正常运行。 从MongoDB 4.2开始，您可以更新文档的分片键值，除非分片键字段是不可变_id字段。有关更新分片键的详细信息，请参见更改文档的分片键值。 在MongoDB 4.2之前，文档的分片键字段值是不可变的。 文件验证 db.collection.findAndModify()方法添加了对bypassDocumentValidation选项的支持，该选项允许您在使用验证规则插入或更新集合中的文档时绕过文件验证。 与update方法的比较 更新文档时，findAndModify()和update()方法的操作方式不同： 默认情况下，两个操作都会修改单个文档。但是，带有multi选项的update()方法可以修改多个文档。 如果多个文档匹配更新条件，对于findAndModify()，您可以指定sort以提供对要更新的文档的某种控制措施。 使用update()方法的默认行为，您无法在多个文档 match 时指定要更新的单个文档。 默认情况下，findAndModify()返回文档的 pre-modified version。要获取更新的文档，请使用new选项。 update()方法返回包含操作状态的写结果 object。要 return 更新的文档，请使用find()方法。但是，其他更新可能已在您的更新和文档检索之间修改了文档。此外，如果更新仅修改了单个文档但匹配了多个文档，则需要使用其他逻辑来标识更新的文档。 修改单个文档时，findAndModify()和update()方法都会自动更新文档。有关这些方法的操作的交互和顺序的更多详细信息，请参阅原子性和 Transactions。 事务 db.collection.findAndModify()可以在多文档交易中使用。 重要 在大多数情况下，与单文档写入相比，多文档事务产生的性能成本更高，并且多文档事务的可用性不应替代有效的架构设计。在许多情况下， 非规范化数据模型（嵌入式文档和数组）将继续是您的数据和用例的最佳选择。也就是说，在许多情况下，适当地对数据建模将最大程度地减少对多文档交易的需求。 有关其他事务使用方面的注意事项（例如运行时限制和操作日志大小限制），另请参见 生产注意事项。 现有的收藏和交易 在事务内部，您可以指定对现有集合的读/写操作。如果db.collection.findAndModify()导致upsert，则该集合必须已经存在。 写的担忧和事务 如果在事务中运行，请不要为操作明确设置写关注点。要对事务使用写关注，请参见 事务和写关注。 例子 更新和 Return 以下方法更新并返回文档与查询条件匹配的人员集合中的现有文档： db.people.findAndModify({ query: { name: \"Tom\", state: \"active\", rating: { $gt: 10 } }, sort: { rating: 1 }, update: { $inc: { score: 1 } } }) 此方法执行以下操作： query在people集合中查找name字段具有 value Tom，state字段具有 value active且rating字段具有 value greater than 10 的文档。 sort以升序 order 命令查询结果。如果多个文档符合query条件，则该方法将选择修改此sort所订购的第一个文档。 更新increments score字段的 value 为 1。 该方法返回为此更新选择的原始(i.e.pre-modification)文档： { \"_id\" : ObjectId(\"50f1e2c99beb36a0f45c6453\"), \"name\" : \"Tom\", \"state\" : \"active\", \"rating\" : 100, \"score\" : 5 } 要 return 修改的文档，请将new:true选项添加到方法中。 如果没有文档与query条件匹配，则该方法返回null。 UPSERT 以下方法包括update选项的upsert: true选项，用于更新匹配的文档;如果不存在匹配的文档，则创建新文档： db.people.findAndModify({ query: { name: \"Gus\", state: \"active\", rating: 100 }, sort: { rating: 1 }, update: { $inc: { score: 1 } }, upsert: true }) 如果方法找到匹配的文档，则该方法执行更新。 如果方法不找到匹配的文档，则该方法创建一个新文档。因为该方法包含sort选项，所以它返回一个空文档{ }作为原始(pre-modification)文档： { } 如果方法确实**不包含sort选项，则该方法返回null。 null 返回新文档 以下方法包括upsert: true选项和new:true选项。该方法更新匹配的文档并返回更新的文档，或者，如果不存在匹配的文档，则插入文档并在value字段中返回新插入的文档。 在以下 example 中，people集合中的任何文档都不匹配query条件： db.people.findAndModify({ query: { name: \"Pascal\", state: \"active\", rating: 25 }, sort: { rating: 1 }, update: { $inc: { score: 1 } }, upsert: true, new: true }) 该方法返回新插入的文档： { \"_id\" : ObjectId(\"50f49ad6444c11ac2448a5d6\"), \"name\" : \"Pascal\", \"rating\" : 25, \"score\" : 1, \"state\" : \"active\" } 排序和删除 通过在rating字段上包含sort规范，以下 example 将从people集合中删除state value 为active且匹配文档中最低rating的单个文档： db.people.findAndModify( { query: { state: \"active\" }, sort: { rating: 1 }, remove: true } ) 该方法返回已删除的文档： { \"_id\" : ObjectId(\"52fba867ab5fdca1299674ad\"), \"name\" : \"XYZ123\", \"score\" : 1, \"state\" : \"active\", \"rating\" : 3 } 指定排序规则 version 3.4 中的新内容。 整理允许用户为 string 比较指定 language-specific 规则，例如字母和重音标记的规则。 集合myColl具有以下文档： { _id: 1, category: \"café\", status: \"A\" } { _id: 2, category: \"cafe\", status: \"a\" } { _id: 3, category: \"cafE\", status: \"a\" } 以下操作包括整理选项： db.myColl.findAndModify({ query: { category: \"cafe\", status: \"a\" }, sort: { category: 1 }, update: { $set: { status: \"Updated\" } }, collation: { locale: \"fr\", strength: 1 } }); 该操作返回以下文档： { \"_id\" : 1, \"category\" : \"café\", \"status\" : \"A\" } 为 Array Update Operations 指定 arrayFilters 注意 arrayFilters 不适用于使用聚合管道的更新。 version 3.6 中的新内容。 从 MongoDB 3.6 开始，在更新 array 字段时，您可以指定arrayFilters来确定要更新的 array 元素。 更新元素 Match arrayFilters Criteria 使用以下文档创建集合students： db.students.insert([ { \"_id\" : 1, \"grades\" : [ 95, 92, 90 ] }, { \"_id\" : 2, \"grades\" : [ 98, 100, 102 ] }, { \"_id\" : 3, \"grades\" : [ 95, 110, 100 ] } ]) 要修改grades array 中大于或等于100的所有元素，请使用过滤后的位置 operator $ [ ]和db.collection.findAndModify方法中的arrayFilters选项： db.students.findAndModify({ query: { grades: { $gte: 100 } }, update: { $set: { \"grades.$[element]\" : 100 } }, arrayFilters: [ { \"element\": { $gte: 100 } } ] }) 该操作更新单个文档的grades字段，在操作之后，该集合具有以下文档： { \"_id\" : 1, \"grades\" : [ 95, 92, 90 ] } { \"_id\" : 2, \"grades\" : [ 98, 100, 100 ] } { \"_id\" : 3, \"grades\" : [ 95, 110, 100 ] } 更新 Array 文档的特定元素 使用以下文档创建集合students2： db.students2.insert([ { \"_id\" : 1, \"grades\" : [ { \"grade\" : 80, \"mean\" : 75, \"std\" : 6 }, { \"grade\" : 85, \"mean\" : 90, \"std\" : 4 }, { \"grade\" : 85, \"mean\" : 85, \"std\" : 6 } ] }, { \"_id\" : 2, \"grades\" : [ { \"grade\" : 90, \"mean\" : 75, \"std\" : 6 }, { \"grade\" : 87, \"mean\" : 90, \"std\" : 3 }, { \"grade\" : 85, \"mean\" : 85, \"std\" : 4 } ] } ]) 要修改grades array 中等级大于或等于85的所有元素的mean字段的 value，请使用过滤后的位置 operator $ [ ]和db.collection.findAndModify方法中的arrayFilters： db.students2.findAndModify({ query: { }, update: { $set: { \"grades.$[elem].mean\" : 100 } }, arrayFilters: [ { \"elem.grade\": { $gte: 85 } } ] }) 该操作更新单个文档的grades字段，在操作之后，该集合具有以下文档： { \"_id\" : 1, \"grades\" : [ { \"grade\" : 80, \"mean\" : 75, \"std\" : 6 }, { \"grade\" : 85, \"mean\" : 100, \"std\" : 4 }, { \"grade\" : 85, \"mean\" : 100, \"std\" : 6 } ] } { \"_id\" : 2, \"grades\" : [ { \"grade\" : 90, \"mean\" : 75, \"std\" : 6 }, { \"grade\" : 87, \"mean\" : 90, \"std\" : 3 }, { \"grade\" : 85, \"mean\" : 85, \"std\" : 4 } ] } 使用聚合管道进行更新 从MongoDB 4.2开始，db.collection.findAndModify()可以接受聚合管道进行更新。管道可以包括以下阶段： $addFields及其别名 $set $project及其别名 $unset $replaceRoot及其别名$replaceWith。 使用聚合管道可以实现更具表达力的更新语句，例如根据当前字段值表达条件更新，或使用另一个字段的值更新一个字段。 例如，students2使用以下文档创建一个集合： db.students2.insert([ { \"_id\" : 1, \"grades\" : [ { \"grade\" : 80, \"mean\" : 75, \"std\" : 6 }, { \"grade\" : 85, \"mean\" : 90, \"std\" : 4 }, { \"grade\" : 85, \"mean\" : 85, \"std\" : 6 } ] }, { \"_id\" : 2, \"grades\" : [ { \"grade\" : 90, \"mean\" : 75, \"std\" : 6 }, { \"grade\" : 87, \"mean\" : 90, \"std\" : 3 }, { \"grade\" : 85, \"mean\" : 85, \"std\" : 4 } ] } ]) 以下操作将查找一个_id字段等于 的文档，1并使用聚合管道total从该grades字段中计算一个新 字段： db.students2.findAndModify( { query: { \"_id\" : 1 }, update: [ { $set: { \"total\" : { $sum: \"$grades.grade\" } } } ], // The $set stage is an alias for ``$addFields`` stage new: true } ) 注意 该$set管道中的使用是指聚集阶段 $set，而不是更新操作$set。 该操作返回更新的文档： { \"_id\" : 1, \"grades\" : [ { \"grade\" : 80, \"mean\" : 75, \"std\" : 6 }, { \"grade\" : 85, \"mean\" : 90, \"std\" : 4 }, { \"grade\" : 85, \"mean\" : 85, \"std\" : 6 } ], \"total\" : 250 } 也可以看看 可线性化通过 findAndModify 读取 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-findOne.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-findOne.html","title":"db.collection.findOne()","keywords":"","body":" db.collection.findOne（） 在本页面 定义 行为 例子 定义 db.collection. findOne(查询，投影) 返回一个满足集合或视图上指定查询条件的文档。如果多个文档满足查询，则此方法根据自然订单返回第一个文档，该文档反映磁盘上文档的 order。在上限集合中，natural order 与 insert order 相同。如果没有文档满足查询，则该方法返回 null。 参数 类型 描述 query document 可选的。使用query operators指定查询选择条件。 projection document 可选的。使用投影操作员指定要 return 的字段。省略此参数以 return 匹配文档中的所有字段。 projection参数采用以下形式的文档： { field1: , field2: ... } 可以是以下包含或排除值之一： 1或true包括。即使未在投影参数中明确指定字段，findOne()方法也始终包含_id字段。 0或false排除。 projection 参数不能混合 include 和 exclude 规则，而 exception 则排除_id字段。 返回： 一个文档满足指定为此方法的第一个参数的条件。如果指定projection参数，findOne()将返回仅包含projection字段的文档。除非您明确排除，否则始终包含_id字段。 虽然类似于find()方法，findOne()方法返回文档而不是游标。 行为 客户端断开 从MongoDB 4.2开始，如果发出db.collection.findOne()断开连接的客户端在操作完成之前断开连接，则MongoDB将标记db.collection.findOne()为终止（即killOp在操作上）。 例子 使用空查询规范 以下操作从bios 系列返回单个文档： db.bios.findOne() 使用查询规范 以下操作返回bios 系列中的第一个匹配文档，其中嵌入文档name中的字段first以字母G 开头，或字段birth小于new Date('01/01/1945')： db.bios.findOne( { $or: [ { 'name.first' : /^G/ }, { birth: { $lt: new Date('01/01/1945') } } ] } ) 用投影 projection参数指定 return 的哪些字段。除非排除属于_id字段，否则该参数包含 include 或 exclude 规范，而不是两者。 指定 Return 的字段 以下操作在bios 系列中查找文档，并仅返回name，contribs和_id字段： db.bios.findOne( { }, { name: 1, contribs: 1 } ) 除了排除的字段外返回所有内容 以下操作返回bios 系列中的文档，其中contribs字段包含元素OOP，并返回除_id字段，name嵌入文档中的first字段和birth字段之外的所有字段： db.bios.findOne( { contribs: 'OOP' }, { _id: 0, 'name.first': 0, birth: 0 } ) findOne 结果文档 您不能将游标方法应用于findOne()的结果，因为返回单个文档。您可以直接访问该文档： var myDocument = db.bios.findOne(); if (myDocument) { var myName = myDocument.name; print (tojson(myName)); } Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-findOneAndDelete.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-findOneAndDelete.html","title":"db.collection.findOneAndDelete()","keywords":"","body":" db.collection.findOneAndDelete（） 在本页面 定义 行为 定义 db.collection. findOneAndDelete(过滤器，选项) version 3.2 中的新内容。 根据filter和sort条件删除单个文档，返回已删除的文档。 findOneAndDelete()方法具有以下形式： db.collection.findOneAndDelete( , { projection: , sort: , maxTimeMS: , collation: } ) findOneAndDelete()方法采用以下参数： 参数 类型 描述 filter document 更新的选择标准。可以使用与find()方法相同的query selectors。 指定空文档{ }以删除集合中返回的第一个文档。 如果未指定，则默认为空文档。 从 MongoDB 3.6.14(和 3.4.23)开始，如果查询参数不是文档，则操作错误。 projection document 可选的。 return 的字段子集。 要_返回返回文档中的所有字段，请省略此参数。 从 MongoDB 3.6.14(和 3.4.23)开始，如果投影参数不是文档，则操作错误。 sort document 可选的。为filter匹配的文档指定排序 order。 从 MongoDB 3.6.14(和 3.4.23)开始，如果 sort 参数不是文档，则操作错误。 见cursor.sort()。 maxTimeMS number 可选的。指定操作必须在其中完成的 time 限制(以毫秒为单位)。如果超出限制则引发错误。 collation document 可选的。 指定要用于操作的整理。 整理允许用户为 string 比较指定 language-specific 规则，例如字母和重音标记的规则。 排序规则选项具有以下语法：排序规则：{ locale：， caseLevel：， caseFirst：， strength：， numericOrdering：， alternate：， maxVariable：， backwards ： } 指定排序规则时，locale字段是必填字段;所有其他校对字段都是可选的。有关字段的说明，请参阅整理文件。 如果未指定排序规则但集合具有默认排序规则(请参阅db.createCollection())，则操作将使用为集合指定的排序规则。 如果没有为集合或操作指定排序规则，MongoDB 使用先前版本中用于 string 比较的简单二进制比较。 您无法为操作指定多个排序规则。对于 example，您不能为每个字段指定不同的排序规则，或者如果使用排序执行查找，则不能对查找使用一个排序规则，而对排序使用另一个排序规则。 version 3.4 中的新内容。 返回： 返回已删除的文档。 行为 findOneAndDelete()删除集合中与filter匹配的第一个匹配文档。 sort参数可用于影响更新的文档。 投影 projection参数采用以下形式的文档： { field1 : , field2 : ... } value 可以是以下任何一种： 1或true包括该字段。即使未在投影参数中明确说明，该方法也会返回_id字段。 0或false排除该字段。这可以在任何字段上使用，包括_id。 事务 db.collection.findOneAndDelete()可以在多文档交易中使用。 如果在事务中运行，请不要为操作明确设置写关注点。要对事务使用写关注，请参见 事务和写关注。 重要 在大多数情况下，与单文档写入相比，多文档事务产生的性能成本更高，并且多文档事务的可用性不应替代有效的架构设计。在许多情况下， 非规范化数据模型（嵌入式文档和数组）将继续是您的数据和用例的最佳选择。也就是说，在许多情况下，适当地对数据建模将最大程度地减少对多文档交易的需求。 有关其他事务使用方面的注意事项（例如运行时限制和操作日志大小限制），另请参见 生产注意事项。 例子 删除文档 grades集合包含类似于以下内容的文档： { _id: 6305, name : \"A. MacDyver\", \"assignment\" : 5, \"points\" : 24 }, { _id: 6308, name : \"B. Batlock\", \"assignment\" : 3, \"points\" : 22 }, { _id: 6312, name : \"M. Tagnum\", \"assignment\" : 5, \"points\" : 30 }, { _id: 6319, name : \"R. Stiles\", \"assignment\" : 2, \"points\" : 12 }, { _id: 6322, name : \"A. MacDyver\", \"assignment\" : 2, \"points\" : 14 }, { _id: 6234, name : \"R. Stiles\", \"assignment\" : 1, \"points\" : 10 } 以下操作查找name : M. Tagnum并删除它的第一个文档： db.scores.findOneAndDelete( { \"name\" : \"M. Tagnum\" } ) 该操作返回已删除的原始文档： { _id: 6312, name: \"M. Tagnum\", \"assignment\" : 5, \"points\" : 30 } 排序和删除文档 grades集合包含类似于以下内容的文档： { _id: 6305, name : \"A. MacDyver\", \"assignment\" : 5, \"points\" : 24 }, { _id: 6308, name : \"B. Batlock\", \"assignment\" : 3, \"points\" : 22 }, { _id: 6312, name : \"M. Tagnum\", \"assignment\" : 5, \"points\" : 30 }, { _id: 6319, name : \"R. Stiles\", \"assignment\" : 2, \"points\" : 12 }, { _id: 6322, name : \"A. MacDyver\", \"assignment\" : 2, \"points\" : 14 }, { _id: 6234, name : \"R. Stiles\", \"assignment\" : 1, \"points\" : 10 } 以下操作首先查找name : \"A. MacDyver\"所有文档。然后在删除具有最低点 value 的文档之前按points升序排序： db.scores.findOneAndDelete( { \"name\" : \"A. MacDyver\" }, { sort : { \"points\" : 1 } } ) 该操作返回已删除的原始文档： { _id: 6322, name: \"A. MacDyver\", \"assignment\" : 2, \"points\" : 14 } 投影已删除的文档 以下操作使用 projection 仅返回返回文档中的_id和assignment字段： db.scores.findOneAndDelete( { \"name\" : \"A. MacDyver\" }, { sort : { \"points\" : 1 }, projection: { \"assignment\" : 1 } } ) 该操作返回包含assignment和_id字段的原始文档： { _id: 6322, \"assignment\" : 2 } 使用 Time 限制更新文档 以下操作设置 5ms time 限制以完成删除： try { db.scores.findOneAndDelete( { \"name\" : \"A. MacDyver\" }, { sort : { \"points\" : 1 }, maxTimeMS : 5 }; ); } catch(e){ print(e); } 如果操作超过 time 限制，则返回： Error: findAndModifyFailed failed: { \"ok\" : 0, \"errmsg\" : \"operation exceeded time limit\", \"code\" : 50 } 指定排序规则 version 3.4 中的新内容。 整理允许用户为 string 比较指定 language-specific 规则，例如字母和重音标记的规则。 集合myColl具有以下文档： { _id: 1, category: \"café\", status: \"A\" } { _id: 2, category: \"cafe\", status: \"a\" } { _id: 3, category: \"cafE\", status: \"a\" } 以下操作包括整理选项： db.myColl.findOneAndDelete( { category: \"cafe\", status: \"a\" }, { collation: { locale: \"fr\", strength: 1 } } ); 该操作返回以下文档： { \"_id\" : 1, \"category\" : \"café\", \"status\" : \"A\" } Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-findOneAndReplace.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-findOneAndReplace.html","title":"db.collection.findOneAndReplace()","keywords":"","body":" db.collection.findOneAndReplace（） 在本页面 定义 行为 例子 定义 db.collection. findOneAndReplace(过滤，替换，选项) version 3.2 中的新内容。 根据filter和sort条件修改和替换单个文档。 findOneAndReplace()方法具有以下形式： db.collection.findOneAndReplace( , , { projection: , sort: , maxTimeMS: , upsert: , returnNewDocument: , collation: } ) findOneAndReplace()方法采用以下参数： 参数 类型 描述 filter document 更新的选择标准。可以使用与find()方法相同的query selectors。 指定一个空文档{ }以替换集合中返回的第一个文档。 如果未指定，则默认为空文档。 从 MongoDB 3.6.14(和 3.4.23)开始，如果查询参数不是文档，则操作错误。 replacement document 替换文件。 不能包含更新 operators。 文档无法指定与替换文档不同的_id value。 projection document 可选的。 return 的字段子集。 要_return 匹配文档中的所有字段，请省略此参数。 从 MongoDB 3.6.14(和 3.4.23)开始，如果投影参数不是文档，则操作错误。 sort document 可选的。为filter匹配的文档指定排序 order。 从 MongoDB 3.6.14(和 3.4.23)开始，如果 sort 参数不是文档，则操作错误。 见cursor.sort()。 maxTimeMS number 可选的。指定操作必须在其中完成的 time 限制(以毫秒为单位)。如果超出限制则引发错误。 upsert boolean 可选的。当true，findOneAndReplace()时：如果没有文档与filter匹配，则从replacement参数插入文档。插入新文档后返回null，除非returnNewDocument是true。 用replacement文档替换与filter匹配的文档。 MongoDB 将_id字段添加到替换文档中，如果未在filter或replacement文档中指定。如果两者都存在_id，则值必须相等。 要避免多次 upsert，请确保query字段为唯一索引。 默认为false。 returnNewDocument boolean 可选的。当true时，返回替换文档而不是原始文档。 默认为false。 collation document 可选的。 指定要用于操作的整理。 整理允许用户为 string 比较指定 language-specific 规则，例如字母和重音标记的规则。 排序规则选项具有以下语法：排序规则：{ locale：， caseLevel：， caseFirst：， strength：， numericOrdering：， alternate：， maxVariable：， backwards ： } 指定排序规则时，locale字段是必填字段;所有其他校对字段都是可选的。有关字段的说明，请参阅整理文件。 如果未指定排序规则但集合具有默认排序规则(请参阅db.createCollection())，则操作将使用为集合指定的排序规则。 如果没有为集合或操作指定排序规则，MongoDB 使用先前版本中用于 string 比较的简单二进制比较。 您无法为操作指定多个排序规则。对于 example，您不能为每个字段指定不同的排序规则，或者如果使用排序执行查找，则不能对查找使用一个排序规则，而对排序使用另一个排序规则。 version 3.4 中的新内容。 返回： 返回原始文档，如果是returnNewDocument: true，则返回替换文档。 行为 findOneAndReplace()替换集合中与filter匹配的第一个匹配文档。 sort参数可用于影响修改哪个文档。 投影 projection参数采用以下形式的文档： { field1 : , field2 : ... } value 可以是以下任何一种： 1或true包括该字段。即使未在投影参数中明确说明，该方法也会返回_id字段。 0或false排除该字段。这可以在任何字段上使用，包括_id。 分片集合 要db.collection.findOneAndReplace()在分片集合上使用，查询过滤器必须在分片键上包含相等条件。 碎片键修改 从MongoDB 4.2开始，您可以更新文档的分片键值，除非分片键字段是不可变_id字段。有关更新分片键的详细信息，请参见更改文档的分片键值。 在MongoDB 4.2之前，文档的分片键字段值是不可变的。 事务 db.collection.findOneAndReplace()可以在多文档交易中使用。 如果该操作导致upsert，则该集合必须已经存在。 如果在事务中运行，请不要为操作明确设置写关注点。要对事务使用写关注，请参见 事务和写关注。 重要 在大多数情况下，与单文档写入相比，多文档事务产生的性能成本更高，并且多文档事务的可用性不应替代有效的架构设计。在许多情况下， 非规范化数据模型（嵌入式文档和数组）将继续是您的数据和用例的最佳选择。也就是说，在许多情况下，适当地对数据建模将最大程度地减少对多文档交易的需求。 有关其他事务使用方面的注意事项（例如运行时限制和操作日志大小限制），另请参见 生产注意事项。 例子 替换文档 scores集合包含类似于以下内容的文档： { \"_id\" : 1521, \"team\" : \"Fearful Mallards\", \"score\" : 25000 }, { \"_id\" : 2231, \"team\" : \"Tactful Mooses\", \"score\" : 23500 }, { \"_id\" : 4511, \"team\" : \"Aquatic Ponies\", \"score\" : 19250 }, { \"_id\" : 5331, \"team\" : \"Cuddly Zebras\", \"score\" : 15235 }, { \"_id\" : 3412, \"team\" : \"Garrulous Bears\", \"score\" : 22300 } 以下操作查找score小于20000的第一个文档并替换它： db.scores.findOneAndReplace( { \"score\" : { $lt : 20000 } }, { \"team\" : \"Observant Badgers\", \"score\" : 20000 } ) 该操作返回已替换的原始文档： { \"_id\" : 2512, \"team\" : \"Aquatic Ponies\", \"score\" : 19250 } 如果returnNewDocument是 true，则操作将_return 替换文档。 排序和替换文档 scores集合包含类似于以下内容的文档： { \"_id\" : 1521, \"team\" : \"Fearful Mallards\", \"score\" : 25000 }, { \"_id\" : 2231, \"team\" : \"Tactful Mooses\", \"score\" : 23500 }, { \"_id\" : 4511, \"team\" : \"Aquatic Ponies\", \"score\" : 19250 }, { \"_id\" : 5331, \"team\" : \"Cuddly Zebras\", \"score\" : 15235 }, { \"_id\" : 3412, \"team\" : \"Garrulous Bears\", \"score\" : 22300 } 按score排序会更改操作的结果。以下操作按score升序对filter的结果进行排序，并替换最低得分文档： db.scores.findOneAndReplace( { \"score\" : { $lt : 20000 } }, { \"team\" : \"Observant Badgers\", \"score\" : 20000 }, { sort: { \"score\" : 1 } } ) 该操作返回已替换的原始文档： { \"_id\" : 5112, \"team\" : \"Cuddly Zebras\", \"score\" : 15235 } 有关此命令的 non-sorted 结果，请参见替换文档。 投射退回文件 scores集合包含类似于以下内容的文档： { \"_id\" : 1521, \"team\" : \"Fearful Mallards\", \"score\" : 25000 }, { \"_id\" : 2231, \"team\" : \"Tactful Mooses\", \"score\" : 23500 }, { \"_id\" : 4511, \"team\" : \"Aquatic Ponies\", \"score\" : 19250 }, { \"_id\" : 5331, \"team\" : \"Cuddly Zebras\", \"score\" : 15235 }, { \"_id\" : 3412, \"team\" : \"Garrulous Bears\", \"score\" : 22300 } 以下操作使用 projection 仅显示返回文档中的team字段： db.scores.findOneAndReplace( { \"score\" : { $lt : 22250 } }, { \"team\" : \"Therapeutic Hamsters\", \"score\" : 22250 }, { sort : { \"score\" : 1 }, project: { \"_id\" : 0, \"team\" : 1 } } ) 该操作返回仅包含team字段的原始文档： { \"team\" : \"Aquatic Ponies\"} 用 Time Limit 替换 Document 以下操作设置完成的 5ms time 限制： try { db.scores.findOneAndReplace( { \"score\" : { $gt : 25000 } }, { \"team\" : \"Emphatic Rhinos\", \"score\" : 25010 }, { maxTimeMS: 5 } ); } catch(e){ print(e); } 如果操作超过 time 限制，则返回： Error: findAndModifyFailed failed: { \"ok\" : 0, \"errmsg\" : \"operation exceeded time limit\", \"code\" : 50 } 用 Upsert 替换文档 如果没有匹配的filter，则以下操作使用upsert字段来插入替换文档： try { db.scores.findOneAndReplace( { \"team\" : \"Fortified Lobsters\" }, { \"_id\" : 6019, \"team\" : \"Fortified Lobsters\" , \"score\" : 32000}, { upsert : true, returnNewDocument: true } ); } catch (e){ print(e); } 该操作返回以下内容： { \"_id\" : 6019, \"team\" : \"Fortified Lobsters\", \"score\" : 32000 } 如果returnNewDocument是 false，则操作将返回null，因为 return 没有原始文档。 指定排序规则 version 3.4 中的新内容。 整理允许用户为 string 比较指定 language-specific 规则，例如字母和重音标记的规则。 集合myColl具有以下文档： { _id: 1, category: \"café\", status: \"A\" } { _id: 2, category: \"cafe\", status: \"a\" } { _id: 3, category: \"cafE\", status: \"a\" } 以下操作包括整理选项： db.myColl.findOneAndReplace( { category: \"cafe\", status: \"a\" }, { category: \"cafÉ\", status: \"Replaced\" }, { collation: { locale: \"fr\", strength: 1 } } ); 该操作返回以下文档： { \"_id\" : 1, \"category\" : \"café\", \"status\" : \"A\" } Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-findOneAndUpdate.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-findOneAndUpdate.html","title":"db.collection.findOneAndUpdate()","keywords":"","body":" db.collection.findOneAndUpdate（） 在本页面 定义 行为 例子 定义 db.collection. findOneAndUpdate(过滤，更新，选项) version 3.2 中的新内容。 根据filter和sort条件更新单个文档。 findOneAndUpdate()方法具有以下形式： 更改了 version 3.6. db.collection.findOneAndUpdate( , , { projection: , sort: , maxTimeMS: , upsert: , returnNewDocument: , collation: , arrayFilters: [ , ... ] } ) findOneAndUpdate()方法采用以下参数： 参数 类型 描述 filter document 更新的选择标准。可以使用与find()方法相同的query selectors。 指定一个空文档{ }以更新集合中返回的第一个文档。 如果未指定，则默认为空文档。 从 MongoDB 3.6.14(和 3.4.23)开始，如果查询参数不是文档，则操作错误。 update document 更新文件。 必须仅包含更新 operators。 projection document 可选的。 return 的字段子集。 要_返回返回文档中的所有字段，请省略此参数。 从 MongoDB 3.6.14(和 3.4.23)开始，如果投影参数不是文档，则操作错误。 sort document 可选的。为filter匹配的文档指定排序 order。 从 MongoDB 3.6.14(和 3.4.23)开始，如果 sort 参数不是文档，则操作错误。 见cursor.sort()。 maxTimeMS number 可选的。指定操作必须在其中完成的 time 限制(以毫秒为单位)。如果超出限制则引发错误。 upsert boolean 可选的。当true，findOneAndUpdate()时：如果没有文件匹配filter，则创建一个新文档。有关详细信息，请参阅upsert 行为。插入新文档后返回null，除非returnNewDocument是true。 更新与filter匹配的单个文档。 要避免多次 upsert，请确保filter字段为唯一索引。 默认为false。 returnNewDocument boolean 可选的。当true时，返回更新的文档而不是原始文档。 默认为false。 collation document 可选的。 指定要用于操作的整理。 整理允许用户为 string 比较指定 language-specific 规则，例如字母和重音标记的规则。 排序规则选项具有以下语法：排序规则：{ locale：， caseLevel：， caseFirst：， strength：， numericOrdering：， alternate：， maxVariable：， backwards ： } 指定排序规则时，locale字段是必填字段;所有其他校对字段都是可选的。有关字段的说明，请参阅整理文件。 如果未指定排序规则但集合具有默认排序规则(请参阅db.createCollection())，则操作将使用为集合指定的排序规则。 如果没有为集合或操作指定排序规则，MongoDB 使用先前版本中用于 string 比较的简单二进制比较。 您无法为操作指定多个排序规则。对于 example，您不能为每个字段指定不同的排序规则，或者如果使用排序执行查找，则不能对查找使用一个排序规则，而对排序使用另一个排序规则。 version 3.4 中的新内容。 arrayFilters array 可选的。过滤器文档的 array，用于确定要在 array 字段上为更新操作修改哪些 array 元素。 在更新文档中，使用$ []过滤后的位置 operator 来定义标识符，然后在 array 过滤器文档中进行 reference。如果标识符未包含在更新文档中，则不能为标识符提供 array 过滤器文档。 注意 必须以小写字母开头，并且只包含字母数字字符。 您可以在更新文档中多次包含相同的标识符;但是，对于更新文档中的每个不同标识符($[identifier])，您必须指定恰好一个对应的 array 过滤器文档。也就是说，您不能为同一标识符指定多个 array 过滤器文档。对于 example，如果 update 语句包含标识符x(可能多次)，则不能为arrayFilters指定以下内容，其中包含 2 个单独的x过滤器文档： // INVALID [ { \"x.a\": { $gt: 85 } }, { \"x.b\": { $gt: 80 } } ] 但是，您可以在同一标识符上指定复合条件单个过滤器文档，例如以下示例： // Example 1 [ { $or: [{\"x.a\": {$gt: 85}}, {\"x.b\": {$gt: 80}}] } ] // Example 2 [ { $and: [{\"x.a\": {$gt: 85}}, {\"x.b\": {$gt: 80}}] } ] // Example 3 [ { \"x.a\": { $gt: 85 }, \"x.b\": { $gt: 80 } } ]例如，请参阅为 Array Update Operations 指定 arrayFilters。 version 3.6 中的新内容。 返回： 返回原始文档，如果是returnNewDocument: true，则返回更新的文档。 行为 findOneAndUpdate()更新集合中与filter匹配的第一个匹配文档。 sort参数可用于影响更新的文档。 投影 projection参数采用以下形式的文档： { field1 : , field2 : ... } value 可以是以下任何一种： 1或true包括该字段。即使未在投影参数中明确说明，该方法也会返回_id字段。 0或false排除该字段。这可以在任何字段上使用，包括_id。 分片集合 要db.collection.findOneAndUpdate()在分片集合上使用，查询过滤器必须在分片键上包含相等条件。 碎片键修改 从MongoDB 4.2开始，您可以更新文档的分片键值，除非分片键字段是不可变_id字段。有关更新分片键的详细信息，请参见更改文档的分片键值。 在MongoDB 4.2之前，文档的分片键字段值是不可变的。 要用于 db.collection.findOneAndUpdate()更新分片键： 您必须在运行mongos无论是在 事务或作为重试写。千万不能直接在碎片颁发运行。 您必须在查询过滤器的完整分片键上包含相等条件。例如，如果一个集合messages 使用的片键，更新为一个文件的碎片关键，你必须包括在查询过滤器。您可以根据需要在查询中包括其他字段。{ country : 1, userid : 1 }``country: , userid: 事务 db.collection.findOneAndUpdate()可以在多文档交易中使用。 重要 在大多数情况下，与单文档写入相比，多文档事务产生的性能成本更高，并且多文档事务的可用性不应替代有效的架构设计。在许多情况下， 非规范化数据模型（嵌入式文档和数组）将继续是您的数据和用例的最佳选择。也就是说，在许多情况下，适当地对数据建模将最大程度地减少对多文档交易的需求。 有关其他事务使用方面的注意事项（例如运行时限制和操作日志大小限制），另请参见 生产注意事项。 现有的收藏和交易 在事务内部，您可以指定对现有集合的读/写操作。如果db.collection.findOneAndUpdate()导致upsert，则该集合必须已经存在。 如果该操作导致upsert，则该集合必须已经存在。 写的担忧和事务 如果在事务中运行，请不要为操作明确设置写关注点。要对事务使用写关注，请参见 事务和写关注。 例子 更新文档 grades集合包含类似于以下内容的文档： { _id: 6305, name : \"A. MacDyver\", \"assignment\" : 5, \"points\" : 24 }, { _id: 6308, name : \"B. Batlock\", \"assignment\" : 3, \"points\" : 22 }, { _id: 6312, name : \"M. Tagnum\", \"assignment\" : 5, \"points\" : 30 }, { _id: 6319, name : \"R. Stiles\", \"assignment\" : 2, \"points\" : 12 }, { _id: 6322, name : \"A. MacDyver\", \"assignment\" : 2, \"points\" : 14 }, { _id: 6234, name : \"R. Stiles\", \"assignment\" : 1, \"points\" : 10 } 以下操作查找name : R. Stiles的第一个文档，并按5递增得分： db.grades.findOneAndUpdate( { \"name\" : \"R. Stiles\" }, { $inc: { \"points\" : 5 } } ) 该操作在更新之前返回原始文档： { _id: 6319, name: \"R. Stiles\", \"assignment\" : 2, \"points\" : 12 } 如果returnNewDocument是 true，则操作将_return 更新文档。 排序和更新文档 grades集合包含类似于以下内容的文档： { _id: 6305, name : \"A. MacDyver\", \"assignment\" : 5, \"points\" : 24 }, { _id: 6308, name : \"B. Batlock\", \"assignment\" : 3, \"points\" : 22 }, { _id: 6312, name : \"M. Tagnum\", \"assignment\" : 5, \"points\" : 30 }, { _id: 6319, name : \"R. Stiles\", \"assignment\" : 2, \"points\" : 12 }, { _id: 6322, name : \"A. MacDyver\", \"assignment\" : 2, \"points\" : 14 }, { _id: 6234, name : \"R. Stiles\", \"assignment\" : 1, \"points\" : 10 } 以下操作更新name : \"A. MacDyver\"的文档。操作通过points升序对匹配文档进行排序，以更新具有最少点的匹配文档。 db.grades.findOneAndUpdate( { \"name\" : \"A. MacDyver\" }, { $inc : { \"points\" : 5 } }, { sort : { \"points\" : 1 } } ) 该操作在更新之前返回原始文档： { _id: 6322, name: \"A. MacDyver\", \"assignment\" : 2, \"points\" : 14 } 投射退回文件 以下操作使用 projection 仅显示返回文档中的_id，points和assignment字段： db.grades.findOneAndUpdate( { \"name\" : \"A. MacDyver\" }, { $inc : { \"points\" : 5 } }, { sort : { \"points\" : 1 }, projection: { \"assignment\" : 1, \"points\" : 1 } } ) 该操作仅返回原始文档，其中仅包含projection文档和_id字段中指定的字段，因为它未在投影文件中明确禁止(_id: 0)。 { \"_id\" : 6322, \"assignment\" : 2, \"points\" : 14 } 使用 Time 限制更新文档 以下操作设置 5ms time 限制以完成更新： try { db.grades.findOneAndUpdate( { \"name\" : \"A. MacDyver\" }, { $inc : { \"points\" : 5 } }, { sort: { \"points\" : 1 }, maxTimeMS : 5 }; ); } catch(e){ print(e); } 如果操作超过 time 限制，则返回： Error: findAndModifyFailed failed: { \"ok\" : 0, \"errmsg\" : \"operation exceeded time limit\", \"code\" : 50 } 使用 Upsert 更新文档 如果没有匹配filter，则以下操作使用upsert字段来插入更新文档： try { db.grades.findOneAndUpdate( { \"name\" : \"A.B. Abracus\" }, { $set: { \"name\" : \"A.B. Abracus\", \"assignment\" : 5}, $inc : { \"points\" : 5 } }, { sort: { \"points\" : 1 }, upsert:true, returnNewDocument : true } ); } catch (e){ print(e); } 该操作返回以下内容： { \"_id\" : ObjectId(\"5789249f1c49e39a8adc479a\"), \"name\" : \"A.B. Abracus\", \"assignment\" : 5, \"points\" : 5 } 如果returnNewDocument是 false，则操作将返回null，因为 return 没有原始文档。 指定排序规则 version 3.4 中的新内容。 整理允许用户为 string 比较指定 language-specific 规则，例如字母和重音标记的规则。 集合myColl具有以下文档： { _id: 1, category: \"café\", status: \"A\" } { _id: 2, category: \"cafe\", status: \"a\" } { _id: 3, category: \"cafE\", status: \"a\" } 以下操作包括整理选项： db.myColl.findOneAndUpdate( { category: \"cafe\" }, { $set: { status: \"Updated\" } }, { collation: { locale: \"fr\", strength: 1 } } ); 该操作返回以下文档： { \"_id\" : 1, \"category\" : \"café\", \"status\" : \"A\" } 为 Array Update Operations 指定 arrayFilters version 3.6 中的新内容。 从 MongoDB 3.6 开始，在更新 array 字段时，您可以指定arrayFilters来确定要更新的 array 元素。 更新元素 Match arrayFilters Criteria 使用以下文档创建集合students： db.students.insert([ { \"_id\" : 1, \"grades\" : [ 95, 92, 90 ] }, { \"_id\" : 2, \"grades\" : [ 98, 100, 102 ] }, { \"_id\" : 3, \"grades\" : [ 95, 110, 100 ] } ]) 要修改grades array 中大于或等于100的所有元素，请使用过滤后的位置 operator $ []和db.collection.findOneAndUpdate方法中的arrayFilters选项： db.students.findOneAndUpdate( { grades: { $gte: 100 } }, { $set: { \"grades.$[element]\" : 100 } }, { arrayFilters: [ { \"element\": { $gte: 100 } } ] } ) 该操作更新单个文档的grades字段，在操作之后，该集合具有以下文档： { \"_id\" : 1, \"grades\" : [ 95, 92, 90 ] } { \"_id\" : 2, \"grades\" : [ 98, 100, 100 ] } { \"_id\" : 3, \"grades\" : [ 95, 110, 100 ] } 更新 Array 文档的特定元素 使用以下文档创建集合students2： db.students2.insert([ { \"_id\" : 1, \"grades\" : [ { \"grade\" : 80, \"mean\" : 75, \"std\" : 6 }, { \"grade\" : 85, \"mean\" : 90, \"std\" : 4 }, { \"grade\" : 85, \"mean\" : 85, \"std\" : 6 } ] }, { \"_id\" : 2, \"grades\" : [ { \"grade\" : 90, \"mean\" : 75, \"std\" : 6 }, { \"grade\" : 87, \"mean\" : 90, \"std\" : 3 }, { \"grade\" : 85, \"mean\" : 85, \"std\" : 4 } ] } ]) 要修改grades array 中等级大于或等于85的所有元素的mean字段的 value，请使用过滤后的位置 operator $ []和db.collection.findOneAndUpdate方法中的arrayFilters： db.students2.findOneAndUpdate( { }, { $set: { \"grades.$[elem].mean\" : 100 } }, { arrayFilters: [ { \"elem.grade\": { $gte: 85 } } ] } ) 该操作更新单个文档的grades字段，在操作之后，该集合具有以下文档： { \"_id\" : 1, \"grades\" : [ { \"grade\" : 80, \"mean\" : 75, \"std\" : 6 }, { \"grade\" : 85, \"mean\" : 100, \"std\" : 4 }, { \"grade\" : 85, \"mean\" : 100, \"std\" : 6 } ] } { \"_id\" : 2, \"grades\" : [ { \"grade\" : 90, \"mean\" : 75, \"std\" : 6 }, { \"grade\" : 87, \"mean\" : 90, \"std\" : 3 }, { \"grade\" : 85, \"mean\" : 85, \"std\" : 4 } ] } 使用聚合管道进行更新 从MongoDB 4.2开始，db.collection.findOneAndUpdate()可以接受聚合管道进行更新。管道可以包括以下阶段： $addFields及其别名 $set $project及其别名 $unset $replaceRoot及其别名$replaceWith。 使用聚合管道可以实现更具表达力的更新语句，例如根据当前字段值表达条件更新，或使用另一个字段的值更新一个字段。 例如，students2使用以下文档创建一个集合： db.students2.insert([ { \"_id\" : 1, \"grades\" : [ { \"grade\" : 80, \"mean\" : 75, \"std\" : 6 }, { \"grade\" : 85, \"mean\" : 90, \"std\" : 4 }, { \"grade\" : 85, \"mean\" : 85, \"std\" : 6 } ] }, { \"_id\" : 2, \"grades\" : [ { \"grade\" : 90, \"mean\" : 75, \"std\" : 6 }, { \"grade\" : 87, \"mean\" : 90, \"std\" : 3 }, { \"grade\" : 85, \"mean\" : 85, \"std\" : 4 } ] } ]) 以下操作将查找一个_id字段等于 的文档，1并使用聚合管道total从该grades字段中计算一个新 字段： db.students2.findOneAndUpdate( { _id : 1 }, [ { $set: { \"total\" : { $sum: \"$grades.grade\" } } } ], // The $set stage is an alias for ``$addFields`` stage { returnNewDocument: true } ) 注意 该$set管道中的使用是指聚集阶段 $set，而不是更新操作$set。 该操作返回更新的文档： { \"_id\" : 1, \"grades\" : [ { \"grade\" : 80, \"mean\" : 75, \"std\" : 6 }, { \"grade\" : 85, \"mean\" : 90, \"std\" : 4 }, { \"grade\" : 85, \"mean\" :85, \"std\" : 6 } ], \"total\" : 250 } Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-getIndexes.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-getIndexes.html","title":"db.collection.getIndexes()","keywords":"","body":" db.collection.getIndexes（） 在本页面 定义 行为 必需的访问权 输出 定义 db.collection. getIndexes () 返回一个 array，其中包含用于标识和描述集合上现有索引的文档列表。您必须在集合上调用db.collection.getIndexes()。例如： db.collection.getIndexes() 将collection更改为要为其返回索引信息的集合的 name。 行为 从MongoDB 4.2开始，如果发出db.collection.getIndexes()断开连接的客户端在操作完成之前断开连接，则MongoDB将标记db.collection.getIndexes()为终止（即killOp在操作上）。 必需的访问权 要db.collection.getIndexes()在强制执行访问控制时运行，使用者必须listIndexes对该集合具有访问权限。 内置角色read提供了db.collection.getIndexes()为数据库中的集合运行所需的特权。 输出 db.collection.getIndexes()返回包含集合索引信息的 array 文档。索引信息包括用于创建索引的键和选项。有关键和索引选项的信息，请参阅db.collection.createIndex()。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-getShardDistribution.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-getShardDistribution.html","title":"db.collection.getShardDistribution()","keywords":"","body":" db.collection.getShardDistribution（） 在本页面 定义 输出 定义 db.collection. getShardDistribution () 打印分片集合的数据分布统计信息。 建议 在运行方法之前，使用flushRouterConfig命令刷新缓存的路由 table，以避免返回集合的陈旧分发信息。刷新后，run db.collection.getShardDistribution()为您希望 build 索引的集合。 例如： db.adminCommand( { flushRouterConfig: \"test.myShardedCollection\" } ); db.getSiblingDB(\"test\").myShardedCollection.getShardDistribution(); 也可以看看 分片 输出 Sample 输出 以下是分片集合分布的 sample 输出： Shard shard-a at shard-a/MyMachine.local:30000,MyMachine.local:30001,MyMachine.local:30002 data : 38.14Mb docs : 1000003 chunks : 2 estimated data per chunk : 19.07Mb estimated docs per chunk : 500001 Shard shard-b at shard-b/MyMachine.local:30100,MyMachine.local:30101,MyMachine.local:30102 data : 38.14Mb docs : 999999 chunks : 3 estimated data per chunk : 12.71Mb estimated docs per chunk : 333333 Totals data : 76.29Mb docs : 2000002 chunks : 5 Shard shard-a contains 50% data, 50% docs in cluster, avg obj size on shard : 40b Shard shard-b contains 49.99% data, 49.99% docs in cluster, avg obj size on shard : 40b 输出字段 Shard at data : docs : chunks : estimated data per chunk : / estimated docs per chunk : / Shard at data : docs : chunks : estimated data per chunk : / estimated docs per chunk : / Totals data : docs : chunks : Shard contains % data, % docs in cluster, avg obj size on shard : stats.shards[ ].avgObjSize Shard contains % data, % docs in cluster, avg obj size on shard : stats.shards[ ].avgObjSize 输出信息显示： 是一个包含分片 name 的 string。 是一个包含 host name(s 的 string。 是一个包含数据大小的数字，包括度量单位(如： b，Mb)。 是一个报告分片中文档数量的数字。 是一个报告分片中块数的数字。 /是计算的 value，它反映了分片的每个块的估计数据大小，包括度量单位(如： b，Mb)。 /是计算出的 value，它反映了碎片每个块的估计文档数。 是一个 value，用于报告分片集合中数据的总大小，包括度量单位。 是一个 value，用于报告分片集合中的文档总数。 是一个计算出的数字，用于报告所有分片的块数，例如： = + 是一个计算的 value，对于每个分片，数据大小反映为集合总数据大小的百分比，对于 example： = / 是一个计算的 value，对于每个分片，它反映了文档的数量，作为集合的文档总数的百分比，对于 example： = / stats.shards[ ].avgObjSize是反映分片的平均 object 大小(包括度量单位)的数字。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-getShardVersion.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-getShardVersion.html","title":"db.collection.getShardVersion()","keywords":"","body":" db.collection.getShardVersion（） db.collection. getShardVersion () 此方法返回有关分片集群中数据的 state 的信息，该信息在诊断分片 cluster 的基础问题时很有用。 仅供内部和诊断使用。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-insert.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-insert.html","title":"db.collection.insert()","keywords":"","body":" db.collection.insert（） 在本页面 定义 行为 例子 写结果 BulkWriteResult 定义 db.collection. insert () 将一个或多个文档插入集合中。 insert()方法具有以下语法： db.collection.insert( , { writeConcern: , ordered: } ) 参数 类型 描述 document 文件或 array 要插入集合的文档或 array 文档。 writeConcern writeConcern 可选的。表示写关注的文件。省略使用默认写入问题。见写关注。 version 2.6 中的新内容。 ordered boolean 可选的。如果true，则在 array 中执行文档的有序插入，如果其中一个文档发生错误，MongoDB 将 return 而不处理 array 中的其余文档。 如果false，执行无序的 insert，如果其中一个文档发生错误，继续处理 array 中的其余文档。 默认为true。 更改 version 2.6：insert()返回包含操作状态的 object。 返回： 单个插入的写结果 object。 ABulkWriteResult object 用于批量插入。 行为 写关注 insert()方法使用插入命令，该命令使用默认的写关注。要指定其他写入问题，请在 options 参数中包含写入关注点。 创建集合 如果集合不存在，则insert()方法将创建集合。 _id 字段 如果文档未指定_id字段，则 MongoDB 将添加_id字段，并在插入之前为文档指定唯一的ObjectId。大多数驱动程序创建一个 ObjectId 并插入_id字段，但如果驱动程序或 application 没有，则mongod将创建并填充_id。 如果文档包含_id字段，则_id value 在集合中必须是唯一的，以避免重复的 key 错误。 事务 db.collection.insert()可以在多文档交易中使用。 集合必须已经存在。事务中不允许执行会导致创建新集合的插入操作。 如果在事务中运行，请不要为操作明确设置写关注点。要对事务使用写关注，请参见 事务和写关注。 重要 在大多数情况下，与单文档写入相比，多文档事务产生的性能成本更高，并且多文档事务的可用性不应替代有效的架构设计。在许多情况下， 非规范化数据模型（嵌入式文档和数组）将继续是您的数据和用例的最佳选择。也就是说，在许多情况下，适当地对数据建模将最大程度地减少对多文档交易的需求。 有关其他事务使用方面的注意事项（例如运行时限制和操作日志大小限制），另请参见 生产注意事项。 例子 以下示例将文档插入products集合。如果集合不存在，insert()方法将创建集合。 插入文档而不指定_id 字段 在以下 example 中，传递给insert()方法的文档不包含_id字段： db.products.insert( { item: \"card\", qty: 15 } ) 在 insert 期间，mongod将创建_id字段并为其分配唯一的ObjectId value，由插入的文档验证： { \"_id\" : ObjectId(\"5063114bd386d8fadbd6b004\"), \"item\" : \"card\", \"qty\" : 15 } 当操作为 run 时，ObjectId值特定于机器和 time。因此，您的值可能与 example 中的值不同。 插入指定_id 字段的文档 在下面的示例中，传递给insert()方法的文档包含_id字段。 _id的 value 在集合中必须是唯一的，以避免重复的 key 错误。 db.products.insert( { _id: 10, item: \"box\", qty: 20 } ) 该操作在products集合中插入以下文档： { \"_id\" : 10, \"item\" : \"box\", \"qty\" : 20 } 插入多个文档 以下 example 通过将 array 文档传递给insert()方法来执行三个文档的批量插入。默认情况下，MongoDB 执行有序的 insert。对于有序插入，如果在其中一个文档的 insert 期间发生错误，MongoDB 将返回错误而不处理 array 中的其余文档。 array 中的文档不需要具有相同的字段。例如，array 中的第一个文档有一个_id字段和一个type字段。由于第二个和第三个文档不包含_id字段，mongod将在 insert 期间为第二个和第三个文档创建_id字段： db.products.insert( [ { _id: 11, item: \"pencil\", qty: 50, type: \"no.2\" }, { item: \"pen\", qty: 20 }, { item: \"eraser\", qty: 25 } ] ) 该操作插入了以下三个文件： { \"_id\" : 11, \"item\" : \"pencil\", \"qty\" : 50, \"type\" : \"no.2\" } { \"_id\" : ObjectId(\"51e0373c6f35bd826f47e9a0\"), \"item\" : \"pen\", \"qty\" : 20 } { \"_id\" : ObjectId(\"51e0373c6f35bd826f47e9a1\"), \"item\" : \"eraser\", \"qty\" : 25 } 执行无序 Insert 以下 example 执行三个文档的无序插入。对于无序插入，如果在其中一个文档的 insert 期间发生错误，MongoDB 将继续插入 array 中的其余文档。 db.products.insert( [ { _id: 20, item: \"lamp\", qty: 50, type: \"desk\" }, { _id: 21, item: \"lamp\", qty: 20, type: \"floor\" }, { _id: 22, item: \"bulk\", qty: 100 } ], { ordered: false } ) 覆盖默认写入关注 对副本集的以下操作指定\"w: majority\"的\"w: majority\"，其wtimeout为 5000 毫秒，以便该方法在写入传播到大多数表决副本集成员后返回，或者该方法在 5 秒后超时。 在 version 3.0 中更改：在以前的版本中，majority指的是副本集的大多数成员而不是大多数投票成员。 db.products.insert( { item: \"envelopes\", qty : 100, type: \"Clasp\" }, { writeConcern: { w: \"majority\", wtimeout: 5000 } } ) 写结果 传递单个文档时，insert()返回WriteResult object。 成功的结果 insert()返回包含操作状态的写结果 object。成功后，写结果 object 包含有关插入文档数量的信息： WriteResult({ \"nInserted\" : 1 }) 写关注错误 如果insert()方法遇到写入关注错误，则结果包括WriteResult.writeConcernError字段： WriteResult({ \"nInserted\" : 1, \"writeConcernError\" : { \"code\" : 64, \"errmsg\" : \"waiting for replication timed out at shard-a\" } }) 与写关注无关的错误 如果insert()方法遇到 non-write 关注错误，则结果包括WriteResult.writeError字段： WriteResult({ \"nInserted\" : 0, \"writeError\" : { \"code\" : 11000, \"errmsg\" : \"insertDocument :: caused by :: 11000 E11000 duplicate key error index: test.foo.$_id_ dup key: { : 1.0 }\" } }) BulkWriteResult 传递 array 文档时，insert()返回BulkWriteResult() object。有关详细信息，请参阅BulkWriteResult()。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-insertOne.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-insertOne.html","title":"db.collection.insertOne()","keywords":"","body":" db.collection.insertOne（） 在本页面 定义 行为 例子 定义 db.collection. insertOne () version 3.2 中的新内容。 将文档插入集合中。 insertOne()方法具有以下语法： db.collection.insertOne( , { writeConcern: } ) 参数 类型 描述 document document 要插入集合的文档。 writeConcern document 可选的。表示写关注的文件。省略使用默认写入问题。如果在事务中运行，请不要为操作明确设置写关注点。要对事务使用写关注，请参见 事务和写关注。 返回： 包含以下内容的文档：一个布尔值acknowledged，true好像该操作在运行时带有 写关注点，或者false禁用了写关注点。insertedId具有_id插入文档的值的字段。 行为 集合创建 如果集合不存在，则insertOne()方法将创建集合。 _id 字段 如果文档未指定_id字段，则mongod将添加_id字段，并在插入之前为文档指定唯一的ObjectId。大多数驱动程序创建一个 ObjectId 并插入_id字段，但如果驱动程序或 application 没有，mongod将创建并填充_id。 如果文档包含_id字段，则_id value 在集合中必须是唯一的，以避免重复的 key 错误。 Explainability insertOne()与db.collection.explain()不兼容。 请改用insert()。 错误处理 出错时，insertOne()抛出writeError或writeConcernError exception。 事务 db.collection.insertOne()可以在多文档交易中使用。 集合必须已经存在。事务中不允许执行会导致创建新集合的插入操作。 如果在事务中运行，请不要为操作明确设置写关注点。要对事务使用写关注，请参见 事务和写关注。 重要 在大多数情况下，与单文档写入相比，多文档事务产生的性能成本更高，并且多文档事务的可用性不应替代有效的架构设计。在许多情况下， 非规范化数据模型（嵌入式文档和数组）将继续是您的数据和用例的最佳选择。也就是说，在许多情况下，适当地对数据建模将最大程度地减少对多文档交易的需求。 有关其他事务使用方面的注意事项（例如运行时限制和操作日志大小限制），另请参见 生产注意事项。 例子 插入文档而不指定_id 字段 在以下 example 中，传递给insertOne()方法的文档不包含_id字段： try { db.products.insertOne( { item: \"card\", qty: 15 } ); } catch (e) { print (e); }; 该操作返回以下文档： { \"acknowledged\" : true, \"insertedId\" : ObjectId(\"56fc40f9d735c28df206d078\") } 由于文档不包含_id，mongod创建并添加_id字段并为其分配唯一的ObjectId value。 当操作为 run 时，ObjectId值特定于机器和 time。因此，您的值可能与 example 中的值不同。 插入指定_id 字段的文档 在下面的示例中，传递给insertOne()方法的文档包含_id字段。 _id的 value 在集合中必须是唯一的，以避免重复的 key 错误。 try { db.products.insertOne( { _id: 10, item: \"box\", qty: 20 } ); } catch (e) { print (e); } 该操作返回以下内容： { \"acknowledged\" : true, \"insertedId\" : 10 } 为的任何 key 插入重复的 value，例如_id，会抛出 exception。以下尝试使用已存在的_id value 插入文档： try { db.products.insertOne( { _id: 10, \"item\" : \"packing peanuts\", \"qty\" : 200 } ); } catch (e) { print (e); } 由于_id: 10已存在，因此抛出以下 exception： WriteError({ \"index\" : 0, \"code\" : 11000, \"errmsg\" : \"E11000 duplicate key error collection: inventory.products index: _id_ dup key: { : 10.0 }\", \"op\" : { \"_id\" : 10, \"item\" : \"packing peanuts\", \"qty\" : 200 } }) 增加写作关注 给定三个成员副本集，以下操作指定majority wtimeout，wtimeout 100： try { db.products.insertOne( { \"item\": \"envelopes\", \"qty\": 100, type: \"Self-Sealing\" }, { writeConcern: { w : \"majority\", wtimeout : 100 } } ); } catch (e) { print (e); } 如果确认时间超过wtimeout限制，则抛出以下 exception： WriteConcernError({ \"code\" : 64, \"errInfo\" : { \"wtimeout\" : true }, \"errmsg\" : \"waiting for replication timed out\" }) 也可以看看 要插入多个文档，请参阅db.collection.insertMany() Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-insertMany.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-insertMany.html","title":"db.collection.insertMany()","keywords":"","body":" db.collection.insertMany（） 在本页面 定义 行为 例子 定义 db.collection. insertMany () version 3.2 中的新内容。 将多个文档插入集合中。 insertMany()方法具有以下语法： db.collection.insertMany( [ , , ... ], { writeConcern: , ordered: } ) 参数 类型 描述 document document 要插入集合的 array 文档。 writeConcern document 可选的。表示写关注的文件。省略使用默认写入问题。如果在事务中运行，请不要为操作明确设置写关注点。要对事务使用写关注，请参见 事务和写关注。 ordered boolean 可选的。一个 boolean，指定mongod实例是否应该执行有序或无序的 insert。默认为true。 返回： 一个文档包含： boolean acknowledged as true如果操作使用写关注或false运行如果写入关注被禁用 为_id每个成功插入的文档 行为 给定 array 文档，insertMany()将 array 中的每个文档插入到集合中。 执行操作 默认情况下，文档插入 order。 如果ordered设置为 false，则文档以无序格式插入，并且可以通过mongod重新排序以增加 performance。如果使用无序insertMany()，Applications 不应该依赖于插入的排序。 每个 group 中的操作数不能超过数据库maxWriteBatchSize的 value。从 MongoDB 3.6 开始，这个 value 是100,000。此值显示在isMaster.maxWriteBatchSize字段中。 此限制可防止出现超大错误消息的问题。如果 group 超过此limit，则 client 驱动程序将 group 分成较小的组，其计数小于或等于限制的 value。例如，对于100,000的maxWriteBatchSize value，如果队列包含200,000操作，则驱动程序将创建 2 个组，每个组具有100,000个操作。 注意 使用 high-level API 时，驱动程序仅将 group 分为较小的组。如果直接使用db.runCommand()(对于 example，在编写驱动程序时)，MongoDB 在尝试执行超出限制的写入批处理时会抛出错误。 从 MongoDB 3.6 开始，一旦单个批处理的错误报告变得太大，MongoDB 会将所有剩余的错误消息截断为空的 string。目前，一旦至少有 2 个错误消息，总大小大于1MB，则开始。 尺寸和分组机制是内部性能细节，在将来的版本中可能会有所变化。 在分片集合上执行有序操作列表通常比执行无序列表慢，因为对于有序列表，每个操作必须等待上一个操作完成。 集合创建 如果集合不存在，则insertMany()在成功写入时创建集合。 _id 字段 如果文档未指定_id字段，则mongod添加_id字段并为文档指定唯一的ObjectId。大多数驱动程序创建一个 ObjectId 并插入_id字段，但如果驱动程序或 application 没有创建，mongod将创建并填充_id。 如果文档包含_id字段，则_id value 在集合中必须是唯一的，以避免重复的 key 错误。 Explainability insertMany()与db.collection.explain()不兼容。 请改用insert()。 错误处理 插入抛出BulkWriteError exception。 排除写关注错误，有序操作在发生错误后停止，而无序操作继续处理队列中任何剩余的写操作。 写入关注错误显示在writeConcernErrors字段中，而所有其他错误显示在writeErrors字段中。如果遇到错误，则显示成功写入操作的数量，而不是插入的_id 列表。有序操作显示遇到的单个错误，而无序操作显示 array 中的每个错误。 事务 db.collection.insertMany()可以在多文档交易中使用。 集合必须已经存在。事务中不允许执行会导致创建新集合的插入操作。 如果在事务中运行，请不要为操作明确设置写关注点。要对事务使用写关注，请参见 事务和写关注。 重要 在大多数情况下，与单文档写入相比，多文档事务产生的性能成本更高，并且多文档事务的可用性不应替代有效的架构设计。在许多情况下， 非规范化数据模型（嵌入式文档和数组）将继续是您的数据和用例的最佳选择。也就是说，在许多情况下，适当地对数据建模将最大程度地减少对多文档交易的需求。 有关其他事务使用方面的注意事项（例如运行时限制和操作日志大小限制），另请参见 生产注意事项。 例子 以下示例将文档插入products集合。 插入多个文档而不指定_id 字段 以下 example 使用db.collection.insertMany()来插入不包含_id字段的文档： try { db.products.insertMany( [ { item: \"card\", qty: 15 }, { item: \"envelope\", qty: 20 }, { item: \"stamps\" , qty: 30 } ] ); } catch (e) { print (e); } 该操作返回以下文档： { \"acknowledged\" : true, \"insertedIds\" : [ ObjectId(\"562a94d381cb9f1cd6eb0e1a\"), ObjectId(\"562a94d381cb9f1cd6eb0e1b\"), ObjectId(\"562a94d381cb9f1cd6eb0e1c\") ] } 由于文档不包含_id，mongod为每个文档创建并添加_id字段，并为其分配唯一的ObjectId value。 当操作为 run 时，ObjectId值特定于机器和 time。因此，您的值可能与 example 中的值不同。 Insert 若干文档指定_id 字段 以下 example/operation 使用insertMany()来插入包含_id字段的文档。 _id的 value 在集合中必须是唯一的，以避免重复的 key 错误。 try { db.products.insertMany( [ { _id: 10, item: \"large box\", qty: 20 }, { _id: 11, item: \"small box\", qty: 55 }, { _id: 12, item: \"medium box\", qty: 30 } ] ); } catch (e) { print (e); } 该操作返回以下文档： { \"acknowledged\" : true, \"insertedIds\" : [ 10, 11, 12 ] } 为的任何 key(例如_id)插入重复的 value 会抛出 exception。以下尝试使用已存在的_id value 插入文档： try { db.products.insertMany( [ { _id: 13, item: \"envelopes\", qty: 60 }, { _id: 13, item: \"stamps\", qty: 110 }, { _id: 14, item: \"packing tape\", qty: 38 } ] ); } catch (e) { print (e); } 由于_id: 13已存在，因此抛出以下 exception： BulkWriteError({ \"writeErrors\" : [ { \"index\" : 0, \"code\" : 11000, \"errmsg\" : \"E11000 duplicate key error collection: inventory.products index: _id_ dup key: { : 13.0 }\", \"op\" : { \"_id\" : 13, \"item\" : \"stamps\", \"qty\" : 110 } } ], \"writeConcernErrors\" : [ ], \"nInserted\" : 1, \"nUpserted\" : 0, \"nMatched\" : 0, \"nModified\" : 0, \"nRemoved\" : 0, \"upserted\" : [ ] }) 请注意，插入了一个文档：_id: 13的第一个文档将成功插入，但第二个 insert 将失败。这也将阻止插入队列中剩余的其他文档。 使用ordered到false时，insert 操作将继续使用任何剩余文档。 无序插入 以下尝试使用_id字段和ordered: false插入多个文档。 array 文档包含两个具有重复_id字段的文档。 try { db.products.insertMany( [ { _id: 10, item: \"large box\", qty: 20 }, { _id: 11, item: \"small box\", qty: 55 }, { _id: 11, item: \"medium box\", qty: 30 }, { _id: 12, item: \"envelope\", qty: 100}, { _id: 13, item: \"stamps\", qty: 125 }, { _id: 13, item: \"tape\", qty: 20}, { _id: 14, item: \"bubble wrap\", qty: 30} ], { ordered: false } ); } catch (e) { print (e); } 该操作抛出以下 exception： BulkWriteError({ \"writeErrors\" : [ { \"index\" : 2, \"code\" : 11000, \"errmsg\" : \"E11000 duplicate key error collection: inventory.products index: _id_ dup key: { : 11.0 }\", \"op\" : { \"_id\" : 11, \"item\" : \"medium box\", \"qty\" : 30 } }, { \"index\" : 5, \"code\" : 11000, \"errmsg\" : \"E11000 duplicate key error collection: inventory.products index: _id_ dup key: { : 13.0 }\", \"op\" : { \"_id\" : 13, \"item\" : \"tape\", \"qty\" : 20 } } ], \"writeConcernErrors\" : [ ], \"nInserted\" : 5, \"nUpserted\" : 0, \"nMatched\" : 0, \"nModified\" : 0, \"nRemoved\" : 0, \"upserted\" : [ ] }) 由于重复的_id值，item: \"medium box\"和item: \"tape\"的文档无法插入nInserted表示插入了剩余的 5 个文档。 使用写关注 给定三个成员副本集，以下操作指定majority majority和wtimeout 100： try { db.products.insertMany( [ { _id: 10, item: \"large box\", qty: 20 }, { _id: 11, item: \"small box\", qty: 55 }, { _id: 12, item: \"medium box\", qty: 30 } ], { w: \"majority\", wtimeout: 100 } ); } catch (e) { print (e); } 如果主要和至少一个辅助设备在 100 毫秒内确认每个写入操作，则返回： { \"acknowledged\" : true, \"insertedIds\" : [ ObjectId(\"562a94d381cb9f1cd6eb0e1a\"), ObjectId(\"562a94d381cb9f1cd6eb0e1b\"), ObjectId(\"562a94d381cb9f1cd6eb0e1c\") ] } 如果副本集中所有必需节点确认写入操作所需的总 time 大于wtimeout，则在wtimeout期间过后将显示以下writeConcernError。 此操作返回： WriteConcernError({ \"code\" : 64, \"errInfo\" : { \"wtimeout\" : true }, \"errmsg\" : \"waiting for replication timed out\" }) Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-isCapped.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-isCapped.html","title":"db.collection.isCapped()","keywords":"","body":" db.collection.isCapped（） db.collection. isCapped () 返回： 如果集合是上限集合则返回true，否则返回false。 也可以看看 上限集合 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-latencyStats.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-latencyStats.html","title":"db.collection.latencyStats()","keywords":"","body":" db.collection.latencyStats（） 在本页面 定义 输出 例子 定义 db.collection. latencyStats(选项) db.collection.latencyStats()返回给定集合的延迟统计信息。它是一个包装 $collStats。 此方法具有以下形式： db.collection.latencyStats( { histograms: } ) histograms参数是可选的 boolean。如果histograms: true则latencyStats()将延迟直方图添加到 return 文档。 也可以看看 $collStats 输出 latencyStats()返回包含字段latencyStats的文档，其中包含以下字段： 字段 描述 reads 读取请求的延迟统计信息。 writes 写请求的延迟统计信息。 commands 数据库命令的延迟统计信息。 每个字段都包含一个包含以下字段的嵌入式文档： 字段 描述 latency 一个64位整数，以毫秒为单位给出总的组合延迟。 ops 一个64位整数，给出自启动以来对集合执行的操作总数。 histogram 嵌入式文档的 array，每个都代表一个延迟范围。每个文档涵盖以前文档范围的两倍。对于介于 2048 微秒和大约 1 秒之间的上限值，直方图包括 half-steps。 此字段仅在latencyStats: { histograms: true }选项的情况下存在。输出中省略了具有零count的空范围。 每个文档都包含以下字段：字段 :描述 micros :一个64位整数，以毫秒为单位给出当前等待时间范围的上限时间。该文档的范围介于上一个文档的 micros值（不包括此值）和该文档的 值（包括不包括在内）之间。 count :一个64位整数，给出延迟小于或等于的操作数micros。 例如，如果collStats返回以下直方图：histogram: [ { micros: NumberLong(1), count: NumberLong(10) }, { micros: NumberLong(2), count: NumberLong(1) }, { micros: NumberLong(4096), count: NumberLong(1) }, { micros: NumberLong(16384), count: NumberLong(1000) }, { micros: NumberLong(49152), count: NumberLong(100) } ] 这表示： 10 次操作占用 1 微秒或更少， 1 操作范围(1,2)微秒， 1 操作范围内的范围(3072,4096)微秒， 1000 次操作(12288,16384)和范围内的 100 次操作(32768,49152)。 例子 您可以在mongo shell 中运行latencyStats()，如下所示： db.data.latencyStats( { histograms: true } ).pretty() latencyStats()返回如下文档： { \"ns\" : \"test.data\", \"localTime\" : ISODate(\"2016-11-01T21:56:28.962Z\"), \"latencyStats\" : { \"reads\" : { \"histogram\" : [ { \"micros\" : NumberLong(16), \"count\" : NumberLong(6) }, { \"micros\" : NumberLong(512), \"count\" : NumberLong(1) } ], \"latency\" : NumberLong(747), \"ops\" : NumberLong(7) }, \"writes\" : { \"histogram\" : [ { \"micros\" : NumberLong(64), \"count\" : NumberLong(1) }, { \"micros\" : NumberLong(24576), \"count\" : NumberLong(1) } ], \"latency\" : NumberLong(26845), \"ops\" : NumberLong(2) }, \"commands\" : { \"histogram\" : [ ], \"latency\" : NumberLong(0), \"ops\" : NumberLong(0) } } } Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-mapReduce.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-mapReduce.html","title":"db.collection.mapReduce()","keywords":"","body":" db.collection.mapReduce（） 在本页面 map功能要求 reduce功能要求 选项 finalize功能要求 Map-Reduce 例子 输出 附加信息 db.collection. mapReduce( map，reduce，{，，，，，，，}) 注意 从4.2版开始，MongoDB弃用： 地图-reduce选项来创建一个新的分片集合以及使用的分片供选择的map-reduce。要输出到分片集合，请首先创建分片集合。MongoDB 4.2还不建议替换现有分片集合。 nonAtomic：false选项的显式规范。 db.collection.mapReduce()方法为MapReduce命令提供了包装。 注意 视图不支持 map-reduce 操作。 db.collection.mapReduce()具有以下语法： db.collection.mapReduce( , , { out: , query: , sort: , limit: , finalize: , scope: , jsMode: , verbose: , bypassDocumentValidation: } ) db.collection.mapReduce()采用以下参数： 参数 类型 描述 map function 一个 JavaScript function 将与key关联或“maps”并发出key和 value pair。 有关详细信息，请参阅map Function 的要求。 reduce function 一个 JavaScript function，它“减少”到一个 object 所有与特定key关联的values。 有关详细信息，请参阅reduce Function 的要求。 options document 为db.collection.mapReduce()指定其他参数的文档。 bypassDocumentValidation boolean 可选的。允许MapReduce在操作期间绕过文档验证。这使您可以插入不符合验证要求的文档。 version 3.2 中的新内容。 下表描述了db.collection.mapReduce()可以接受的其他参数。 领域 类型 描述 out string or document 指定 map-reduce 操作结果的位置。您可以输出到集合，输出到具有操作的集合，或输出内联。在对集合的主要成员执行 map-reduce 操作时，您可以输出到集合;在次要成员上，您只能使用inline输出。 有关详细信息，请参阅选项。 query document 使用query operators指定选择条件，以确定输入到map function 的文档。 sort document 对输入文档进行排序。此选项对优化很有用。对于 example，请将 sort key 指定为与 emit key 相同，以便减少 reduce 操作。 sort key 必须位于此集合的现有索引中。 limit number 指定输入map function 的最大文档数。 finalize function 可选的。遵循reduce方法并修改输出。 有关详细信息，请参阅finalize Function 的要求。 scope document 指定map，reduce和finalize函数中可访问的 global 变量。 jsMode boolean 指定是否在执行map和reduce函数之间将中间数据转换为 BSON 格式。 默认为false。 如果false：1. 在内部，MongoDB 将map function 发出的 JavaScript objects 转换为 BSON objects。然后在调用reduce function 时将这些 BSON objects 转换回 JavaScript objects。 2. map-reduce 操作将中间 BSON object 放置在临时的 on-disk 存储中。这允许 map-reduce 操作在任意大的数据集上执行。 如果true：1. 在内部，map function 期间发出的 JavaScript objects 仍然是 JavaScript objects。无需为reduce function 转换 objects，这可以加快执行速度。 2. 您只能将jsMode用于映射器emit() function 中少于 500,000 个不同key arguments 的结果_set。 verbose boolean 指定是否在结果信息中包含timing信息。将verbose设置为true以包含timing信息。 默认为false。 collation document 可选的。 指定要用于操作的排序规则。 整理允许用户为 string 比较指定 language-specific 规则，例如字母和重音标记的规则。 排序规则选项具有以下语法：排序规则：{ locale：， caseLevel：， caseFirst：， strength：， numericOrdering：， alternate：， maxVariable：， backwards ： } 指定排序规则时，locale字段是必填字段;所有其他校对字段都是可选的。有关字段的说明，请参阅整理文件。 如果未指定排序规则但集合具有默认排序规则(请参阅db.createCollection())，则操作将使用为集合指定的排序规则。 如果没有为集合或操作指定排序规则，MongoDB 使用先前版本中用于 string 比较的简单二进制比较。 您无法为操作指定多个排序规则。对于 example，您不能为每个字段指定不同的排序规则，或者如果使用排序执行查找，则不能对查找使用一个排序规则，而对排序使用另一个排序规则。 version 3.4 中的新内容。 注意 map-reduce operations， group 命令和$where 运算表达式无法访问 mongo shell 中可用的某些 global 函数或 properties，例如 db。 可用的 PropertiesAvailable 函数 以下JavaScript函数和属性可用于 和 运算符表达式：map-reduce operations、$where 可用属性 可用功能 argsMaxKeyMinKey assert()BinData()DBPointer()DBRef()doassert()emit()gc()HexData()hex_md5()isNumber()isObject()ISODate()isString()Map()MD5()NumberInt()NumberLong()ObjectId()print()printjson()printjsononeline()sleep()Timestamp()tojson()tojsononeline()tojsonObject()UUID()version() map功能要求 map function 负责将每个输入文档转换为零个或多个文档。它可以访问scope参数中定义的变量，并具有以下原型： function() { ... emit(key, value); } map function 具有以下要求： 在map function 中，在 function 中将当前文档作为this引用。 map function 不应出于任何原因访问数据库。 map function 应该是纯的，或者在 function 之外没有影响(即：side effects.) 单个发射只能容纳 MongoDB 的最大 BSON 文件大小的一半。 map function 可以选择多次调用emit(key,value)来创建一个将key与value相关联的输出文档。 从版本4.2.1开始，MongoDB在该功能的作用域（即BSON类型15）中弃用JavaScript map。要确定变量的范围，请改用scope参数。 以下map function 将调用emit(key,value) 0 或 1 次，具体取决于输入文档的status字段的 value： function() { if (this.status == 'A') emit(this.cust_id, 1); } 以下map function 可能会多次调用emit(key,value)，具体取决于输入文档的items字段中的元素数： function() { this.items.forEach(function(item){ emit(item.sku, 1); }); } reduce功能要求 reduce function 具有以下原型： function(key, values) { ... return result; } reduce function 表现出以下行为： reduce function 不应该访问数据库，甚至不应该执行读操作。 reduce function 不应影响外部系统。 MongoDB 不会为只有一个 value 的 key 调用reduce function。 values参数是一个 array，其元素是value objects，它们被“映射”到key。 MongoDB 可以为同一个 key 多次调用reduce function。在这种情况下，该 key 的reduce function 的前一个输出将成为该 key 的下一个reduce function 调用的输入值之一。 reduce function 可以访问scope参数中定义的变量。 reduce的输入不得大于 MongoDB 的最大 BSON 文件大小的一半。返回大型文档然后在后续的reduce步骤中将其连接在一起时，可能会违反此要求。 从版本4.2.1开始，MongoDB在该功能的作用域（即BSON类型15）中弃用JavaScript reduce。要确定变量的范围，请改用scope 参数。 因为可以为同一个 key 多次调用reduce function，所以以下 properties 需要 true： return object 的类型必须与map function 发出的value的类型相同。 reduce function 必须是关联的。以下语句必须是 true： reduce(key, [ C, reduce(key, [ A, B ]) ] ) == reduce( key, [ C, A, B ] ) reduce function 必须是幂等的。确保以下语句是 true： reduce( key, [ reduce(key, valuesArray) ] ) == reduce( key, valuesArray ) reduce function 应该是可交换的：也就是说，valuesArray中元素的 order 不应该影响reduce function 的输出，因此以下语句是 true： reduce( key, [ A, B ] ) == reduce( key, [ B, A ] ) 选项 您可以为out参数指定以下选项： 输出到集合 此选项输出到新集合，并且在副本集的辅助成员上不可用。 out: 输出到带有 Action 的 Collection 注意 从4.2版开始，MongoDB弃用： 地图-reduce选项来创建一个新的分片集合以及使用的分片供选择的map-reduce。要输出到分片集合，请首先创建分片集合。MongoDB 4.2还不建议替换现有分片集合。 nonAtomic：false选项的显式规范。 此选项仅在将已存在的集合传递给out时可用。它不适用于副本集 的辅助成员。 out: { : [, db: ] [, sharded: ] [, nonAtomic: ] } 当您输出带有操作的集合时，out具有以下参数： ：指定以下操作之一： replace 如果具有的集合存在，则替换的内容。 merge 如果输出集合已存在，则将新结果与现有结果合并。如果现有文档与新结果具有相同的 key，则覆盖该现有文档。 reduce 如果输出集合已存在，则将新结果与现有结果合并。如果现有文档与新结果具有相同的 key，则将reduce function 应用于新文档和现有文档，并使用结果覆盖现有文档。 db : 可选的。您希望 map-reduce 操作写入其输出的数据库的 name。默认情况下，这将是与输入集合相同的数据库。 sharded : 可选的。如果true并且您已在输出数据库上启用了分片，则 map-reduce 操作将使用_id字段分割输出集合作为分片 key。 如果true和collectionName是现有的未整数集合，map-reduce 将失败。 nonAtomic : 注意 开始在MongoDB中4.2，明确设置nonAtomic到false已被弃用。 可选的。将输出操作指定为 non-atomic。这仅对merge和reduce输出模式应用，这可能需要几分钟才能执行。 默认情况下nonAtomic是false，map-reduce 操作在 post-processing 期间锁定数据库。 如果nonAtomic是true，则 post-processing step 会阻止 MongoDB 锁定数据库：在此 time 期间，其他 clients 将能够读取输出集合的中间状态。 输出内联 在 memory 中执行 map-reduce 操作并 return 结果。此选项是副本集的辅助成员上out的唯一可用选项。 out: { inline: 1 } 结果必须符合BSON 文档的最大大小。 finalize功能要求 finalize function 具有以下原型： function(key, reducedValue) { ... return modifiedObject; } finalize function 接收value 作为其 arguments 和reduce function 的reducedValue。意识到： finalize function 不应出于任何原因访问数据库。 finalize function 应该是纯的，或者在 function 之外没有影响(即：side effects.) finalize function 可以访问scope参数中定义的变量。 从版本4.2.1开始，MongoDB在该功能的作用域（即BSON类型15）中弃用JavaScript finalize。要确定变量的范围，请改用scope 参数。 Map-Reduce 例子 聚合管道作为替代 聚合管道比map-reduce提供更好的性能和更一致的接口。 各种map-reduce表达式可以使用被重写聚合管道运算符，诸如$group， $merge等 下面的示例包括聚合管道备选方案。 orders使用以下文档创建样本集合： db.orders.insertMany([ { _id: 1, cust_id: \"Ant O. Knee\", ord_date: new Date(\"2020-03-01\"), price: 25, items: [ { sku: \"oranges\", qty: 5, price: 2.5 }, { sku: \"apples\", qty: 5, price: 2.5 } ], status: \"A\" }, { _id: 2, cust_id: \"Ant O. Knee\", ord_date: new Date(\"2020-03-08\"), price: 70, items: [ { sku: \"oranges\", qty: 8, price: 2.5 }, { sku: \"chocolates\", qty: 5, price: 10 } ], status: \"A\" }, { _id: 3, cust_id: \"Busby Bee\", ord_date: new Date(\"2020-03-08\"), price: 50, items: [ { sku: \"oranges\", qty: 10, price: 2.5 }, { sku: \"pears\", qty: 10, price: 2.5 } ], status: \"A\" }, { _id: 4, cust_id: \"Busby Bee\", ord_date: new Date(\"2020-03-18\"), price: 25, items: [ { sku: \"oranges\", qty: 10, price: 2.5 } ], status: \"A\" }, { _id: 5, cust_id: \"Busby Bee\", ord_date: new Date(\"2020-03-19\"), price: 50, items: [ { sku: \"chocolates\", qty: 5, price: 10 } ], status: \"A\"}, { _id: 6, cust_id: \"Cam Elot\", ord_date: new Date(\"2020-03-19\"), price: 35, items: [ { sku: \"carrots\", qty: 10, price: 1.0 }, { sku: \"apples\", qty: 10, price: 2.5 } ], status: \"A\" }, { _id: 7, cust_id: \"Cam Elot\", ord_date: new Date(\"2020-03-20\"), price: 25, items: [ { sku: \"oranges\", qty: 10, price: 2.5 } ], status: \"A\" }, { _id: 8, cust_id: \"Don Quis\", ord_date: new Date(\"2020-03-20\"), price: 75, items: [ { sku: \"chocolates\", qty: 5, price: 10 }, { sku: \"apples\", qty: 10, price: 2.5 } ], status: \"A\" }, { _id: 9, cust_id: \"Don Quis\", ord_date: new Date(\"2020-03-20\"), price: 55, items: [ { sku: \"carrots\", qty: 5, price: 1.0 }, { sku: \"apples\", qty: 10, price: 2.5 }, { sku: \"oranges\", qty: 10, price: 2.5 } ], status: \"A\" }, { _id: 10, cust_id: \"Don Quis\", ord_date: new Date(\"2020-03-23\"), price: 25, items: [ { sku: \"oranges\", qty: 10, price: 2.5 } ], status: \"A\" } ]) 返回每位客户的总价格 通过cust_id对orders集合执行 map-reduce 操作到 group，并为每个cust_id计算price的总和： 定义map功能来处理每个输入文档： 在 function 中，this指的是 map-reduce 操作正在处理的文档。 function maps 为每个文档的cust_id并发出cust_id和price键值对。 var mapFunction1 = function() { emit(this.cust_id, this.price); }; 使用两个参数 keyCustId和valuesPrices定义相应的 reduce function： valuesPrices是一个数组，其元素是 map function 发出的price值，并按keyCustId分组。 function 将valuesPrice array 缩减为其元素的总和。 var reduceFunction1 = function(keyCustId, valuesPrices) { return Array.sum(valuesPrices); }; 使用mapFunction1 map function 和reduceFunction1 reduce function 对orders集合中的所有文档执行 map-reduce。 db.orders.mapReduce( mapFunction1, reduceFunction1, { out: \"map_reduce_example\" } ) 此操作将结果输出到名为map_reduce_example的集合。如果map_reduce_example集合已存在，则操作将使用此 map-reduce 操作的结果替换内容。 查询map_reduce_example集合以验证结果： db.map_reduce_example.find().sort( { _id: 1 } ) 该操作返回以下文档： { \"_id\" : \"Ant O. Knee\", \"value\" : 95 } { \"_id\" : \"Busby Bee\", \"value\" : 125 } { \"_id\" : \"Cam Elot\", \"value\" : 60 } { \"_id\" : \"Don Quis\", \"value\" : 155 } 聚合替代 使用可用的聚合管道运算符，您可以重写map-reduce操作，而无需定义自定义函数： db.orders.aggregate([ { $group: { _id: \"$cust_id\", value: { $sum: \"$price\" } } }, { $out: \"agg_alternative_1\" } ]) $group由平台组cust_id并计算value字段（参见$sum）。该 value字段包含price每个的总计cust_id。 该阶段将以下文档输出到下一阶段： { \"_id\" : \"Don Quis\", \"value\" : 155 } { \"_id\" : \"Ant O. Knee\", \"value\" : 95 } { \"_id\" : \"Cam Elot\", \"value\" : 60 } { \"_id\" : \"Busby Bee\", \"value\" : 125 } 然后，$out将输出写入collection agg_alternative_1。或者，您可以使用 $merge代替$out。 查询agg_alternative_1集合以验证结果： db.agg_alternative_1.find().sort( { _id: 1 } ) 该操作返回以下文档： { \"_id\" : \"Ant O. Knee\", \"value\" : 95 } { \"_id\" : \"Busby Bee\", \"value\" : 125 } { \"_id\" : \"Cam Elot\", \"value\" : 60 } { \"_id\" : \"Don Quis\", \"value\" : 155 } 使用 Item 的平均数量计算 Order 和总数量 在此事例中，您将对orders集合执行 map-reduce 操作，以处理ord_date value 大于01/01/2012的所有文档。操作按item.sku字段分组，并计算每个sku的订单数量和订购总数量。然后，该操作将为每个值计算每个订单的平均数量，并将结果合并到输出集合中。合并结果时，如果现有文档的密钥与新结果相同，则该操作将覆盖现有文档。如果不存在具有相同密钥的文档，则该操作将插入该文档。 定义map功能来处理每个输入文档： 在 function 中，this指的是 map-reduce 操作正在处理的文档。 对于每个 item，函数将sku与一个新的 object value相关联，该对象 value包含订单的count和_ite用于 order 并发出sku和value对。 var mapFunction2 = function() { for (var idx = 0; idx 使用两个 arguments keySKU和countObjVals定义相应的 reduce function： countObjVals是一个 array，其元素是映射到 map function 传递给 reducer function 的分组keySKU值的 objects。 function 将countObjVals array 缩减为包含count和qty字段的单个 object reducedValue。 在reducedVal中，count字段包含来自各个 array 元素的count字段的总和，qty字段包含来自各个 array 元素的qty字段的总和。 var reduceFunction2 = function(keySKU, countObjVals) { reducedVal = { count: 0, qty: 0 }; for (var idx = 0; idx 使用两个 arguments key和reducedVal定义 finalize function。 function 修改reducedVal object 以添加名为avg的计算字段并返回修改后的 object： var finalizeFunction2 = function (key, reducedVal) { reducedVal.avg = reducedVal.qty/reducedVal.count; return reducedVal; }; 使用mapFunction2，reduceFunction2和finalizeFunction2函数对orders集合执行 map-reduce 操作。 db.orders.mapReduce( mapFunction2, reduceFunction2, { out: { merge: \"map_reduce_example\" }, query: { ord_date: { $gt: new Date('01/01/2012') } }, finalize: finalizeFunction2 } ) 此操作使用query字段仅选择ord_date大于new Date(01/01/2012)的文档。然后它将结果输出到集合map_reduce_example。如果map_reduce_example集合已存在，则操作将现有内容与此 map-reduce 操作的结果合并。也就是说，如果现有文档具有与新结果相同的密钥，则该操作将覆盖现有文档。如果不存在具有相同密钥的文档，则该操作将插入该文档。 查询map_reduce_example2集合以验证结果： db.map_reduce_example2.find().sort( { _id: 1 } ) 该操作返回以下文档： { \"_id\" : \"apples\", \"value\" : { \"count\" : 3, \"qty\" : 30, \"avg\" : 10 } } { \"_id\" : \"carrots\", \"value\" : { \"count\" : 2, \"qty\" : 15, \"avg\" : 7.5 } } { \"_id\" : \"chocolates\", \"value\" : { \"count\" : 3, \"qty\" : 15, \"avg\" : 5 } } { \"_id\" : \"oranges\", \"value\" : { \"count\" : 6, \"qty\" : 58, \"avg\" : 9.666666666666666 } } { \"_id\" : \"pears\", \"value\" : { \"count\" : 1, \"qty\" : 10, \"avg\" : 10 } } 聚合替代 使用可用的聚合管道运算符，您可以重写map-reduce操作，而无需定义自定义函数： db.orders.aggregate( [ { $match: { ord_date: { $gte: new Date(\"2020-03-01\") } } }, { $unwind: \"$items\" }, { $group: { _id: \"$items.sku\", qty: { $sum: \"$items.qty\" }, orders_ids: { $addToSet: \"$_id\" } } }, { $project: { value: { count: { $size: \"$orders_ids\" }, qty: \"$qty\", avg: { $divide: [ \"$qty\", { $size: \"$orders_ids\" } ] } } } }, { $merge: { into: \"agg_alternative_3\", on: \"_id\", whenMatched: \"replace\", whenNotMatched: \"insert\" } } ] ) 该$match阶段仅选择ord_date大于或等于的那些文档。new Date(\"2020-03-01\") 该$unwinds阶段按items数组字段细分文档，以输出每个数组元素的文档。例如： { \"_id\" : 1, \"cust_id\" : \"Ant O. Knee\", \"ord_date\" : ISODate(\"2020-03-01T00:00:00Z\"), \"price\" : 25, \"items\" : { \"sku\" : \"oranges\", \"qty\" : 5, \"price\" : 2.5 }, \"status\" : \"A\" } { \"_id\" : 1, \"cust_id\" : \"Ant O. Knee\", \"ord_date\" : ISODate(\"2020-03-01T00:00:00Z\"), \"price\" : 25, \"items\" : { \"sku\" : \"apples\", \"qty\" : 5, \"price\" : 2.5 }, \"status\" : \"A\" } { \"_id\" : 2, \"cust_id\" : \"Ant O. Knee\", \"ord_date\" : ISODate(\"2020-03-08T00:00:00Z\"), \"price\" : 70, \"items\" : { \"sku\" : \"oranges\", \"qty\" : 8, \"price\" : 2.5 }, \"status\" : \"A\" } { \"_id\" : 2, \"cust_id\" : \"Ant O. Knee\", \"ord_date\" : ISODate(\"2020-03-08T00:00:00Z\"), \"price\" : 70, \"items\" : { \"sku\" : \"chocolates\", \"qty\" : 5, \"price\" : 10 }, \"status\" : \"A\" } { \"_id\" : 3, \"cust_id\" : \"Busby Bee\", \"ord_date\" : ISODate(\"2020-03-08T00:00:00Z\"), \"price\" : 50, \"items\" : { \"sku\" : \"oranges\", \"qty\" : 10, \"price\" : 2.5 }, \"status\" : \"A\" } { \"_id\" : 3, \"cust_id\" : \"Busby Bee\", \"ord_date\" : ISODate(\"2020-03-08T00:00:00Z\"), \"price\" : 50, \"items\" : { \"sku\" : \"pears\", \"qty\" : 10, \"price\" : 2.5 }, \"status\" : \"A\" } { \"_id\" : 4, \"cust_id\" : \"Busby Bee\", \"ord_date\" : ISODate(\"2020-03-18T00:00:00Z\"), \"price\" : 25, \"items\" : { \"sku\" : \"oranges\", \"qty\" : 10, \"price\" : 2.5 }, \"status\" : \"A\" } { \"_id\" : 5, \"cust_id\" : \"Busby Bee\", \"ord_date\" : ISODate(\"2020-03-19T00:00:00Z\"), \"price\" : 50, \"items\" : { \"sku\" : \"chocolates\", \"qty\" : 5, \"price\" : 10 }, \"status\" : \"A\" } ... $group由平台组items.sku，计算每个SKU： qty字段。该qty字段包含qty每个订单的总数items.sku（请参阅参考资料$sum）。 orders_ids阵列。该orders_ids字段包含不同顺序的阵列_id的对items.sku（参见 $addToSet）。 { \"_id\" : \"chocolates\", \"qty\" : 15, \"orders_ids\" : [ 2, 5, 8 ] } { \"_id\" : \"oranges\", \"qty\" : 63, \"orders_ids\" : [ 4, 7, 3, 2, 9, 1, 10 ] } { \"_id\" : \"carrots\", \"qty\" : 15, \"orders_ids\" : [ 6, 9 ] } { \"_id\" : \"apples\", \"qty\" : 35, \"orders_ids\" : [ 9, 8, 1, 6 ] } { \"_id\" : \"pears\", \"qty\" : 10, \"orders_ids\" : [ 3 ] } $project阶段调整输出文档的形状以反映map-reduce的输出，该输出具有两个字段_id和 value。该$projectsets： value.count的尺寸在orders_ids数组中。（请参阅$size。） value.qty在qty输入文档的字段。 value.avg每订购数量的平均数目。（请参阅$divide和$size。） { \"_id\" : \"apples\", \"value\" : { \"count\" : 4, \"qty\" : 35, \"avg\" : 8.75 } } { \"_id\" : \"pears\", \"value\" : { \"count\" : 1, \"qty\" : 10, \"avg\" : 10 } } { \"_id\" : \"chocolates\", \"value\" : { \"count\" : 3, \"qty\" : 15, \"avg\" : 5 } } { \"_id\" : \"oranges\", \"value\" : { \"count\" : 7, \"qty\" : 63, \"avg\" : 9 } } { \"_id\" : \"carrots\", \"value\" : { \"count\" : 2, \"qty\" : 15, \"avg\" : 7.5 } } 最后，$merge将输出写入collection agg_alternative_3。如果现有文档的密钥_id与新结果相同，则该操作将覆盖现有文档。如果不存在具有相同密钥的文档，则该操作将插入该文档。 查询agg_alternative_3集合以验证结果： db.agg_alternative_3.find().sort( { _id: 1 } ) 该操作返回以下文档： { \"_id\" : \"apples\", \"value\" : { \"count\" : 4, \"qty\" : 35, \"avg\" : 8.75 } } { \"_id\" : \"carrots\", \"value\" : { \"count\" : 2, \"qty\" : 15, \"avg\" : 7.5 } } { \"_id\" : \"chocolates\", \"value\" : { \"count\" : 3, \"qty\" : 15, \"avg\" : 5 } } { \"_id\" : \"oranges\", \"value\" : { \"count\" : 7, \"qty\" : 63, \"avg\" : 9 } } { \"_id\" : \"pears\", \"value\" : { \"count\" : 1, \"qty\" : 10, \"avg\" : 10 } } 输出 db.collection.mapReduce()方法的输出与MapReduce命令的输出相同。有关db.collection.mapReduce()输出的信息，请参阅MapReduce命令的产量部分。 限制 MongoDB驱动程序会自动将afterClusterTime设置为与因果一致的会话相关联的操作。从MongoDB 4.2开始， db.collection.mapReduce()不再支持 afterClusterTime。因此， db.collection.mapReduce()不能与因果一致的会话相关联 。 附加信息 对 Map Function 进行故障排除 排除 Reduce Function 问题 MapReduce命令 聚合 Map-Reduce 执行增量 Map-Reduce Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-reIndex.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-reIndex.html","title":"db.collection.reIndex()","keywords":"","body":" db.collection.reIndex（） 在本页面 行为 db.collection. reIndex () db.collection.reIndex()删除集合上的所有索引并重新创建它们。对于具有大量数据 and/or 大量索引的集合，此操作可能很费时。 警告 对于大多数用户，不需要db.collection.reIndex()操作。 避免对副本集中的集合 running db.collection.reIndex()。 不要对分片 cluster 中的集合运行db.collection.reIndex()。 在版本4.2中进行了更改： MongoDB不允许db.collection.reIndex()在上运行mongos，对分片db.collection.reIndex()群集中的集合实施了更严格的限制 。 行为 注意 对于副本_set，db.collection.reIndex()不会从主节点传播到从节点。 db.collection.reIndex()只会影响单个mongod实例。 重要 由于多索引构建中描述的逻辑，db.collection.reIndex()始终在前台构建索引。 对于将featureCompatibilityVersion（fCV）设置为\"4.0\" 或更早版本的MongoDB 2.6至MongoDB版本， 如果现有文档的索引条目超过，则MongoDB 不会在集合上创建索引。Maximum Index Key Length 资源锁定 在版本4.2.2中更改。 对于MongoDB 4.2.2及更高版本，请db.collection.reIndex()在集合上获得排他（W）锁，并阻止对该集合进行其他操作，直到完成。 对于MongoDB 4.0.0到4.2.1，db.collection.reIndex() 获得全局排他（W）锁并在上阻止其他操作， mongod直到完成。 对于MongoDB 3.6及更早版本，这些操作 db.collection.reIndex()在数据库上获得排他（W）锁，并阻塞数据库上的其他操作，直到完成。 有关锁定MongoDB的更多信息，请参阅FAQ：并发。 也可以看看 索引 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-remove.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-remove.html","title":"db.collection.remove()","keywords":"","body":" db.collection.remove（） 在本页面 定义 行为 例子 写结果 定义 db.collection. remove () 从集合中删除文档。 db.collection.remove()方法可以具有两种语法之一。 remove()方法可以采用查询文档和可选的justOne boolean： db.collection.remove( , ) 或者该方法可以采用查询文档和可选的删除选项文档： version 2.6 中的新内容。 db.collection.remove( , { justOne: , writeConcern: , collation: } ) 参数 类型 描述 query document 使用query operators指定删除条件。要删除集合中的所有文档，请传递空文档({})。 justOne boolean 可选的。要将删除限制为仅一个文档，请设置为true。省略使用false的默认 value 并删除符合删除条件的所有文档。 writeConcern document 可选的。表示写关注的文件。省略使用默认写入问题。见写关注。 如果在事务中运行，请不要为操作明确设置写关注点。要对事务使用写关注，请参见 事务和写关注。 collation document 可选的。 指定要用于操作的排序规则。 排序规则允许用户为 string 比较指定 language-specific 规则，例如字母和重音标记的规则。 排序规则选项具有以下语法：collation：{ locale：， caseLevel：， caseFirst：， strength：， numericOrdering：， alternate：， maxVariable：， backwards ： } 指定排序规则时，locale字段是必填字段;所有其他校对字段都是可选的。有关字段的说明，请参阅整理文件。 如果未指定排序规则但集合具有默认排序规则(请参阅db.createCollection())，则操作将使用为集合指定的排序规则。 如果没有为集合或操作指定排序规则，MongoDB 使用先前版本中用于 string 比较的简单二进制比较。 您无法为操作指定多个排序规则。对于 example，您不能为每个字段指定不同的排序规则，或者如果使用排序执行查找，则不能对查找使用一个排序规则，而对排序使用另一个排序规则。 version 3.4 中的新内容。 remove()返回包含操作状态的 object。 返回： 包含操作状态的写结果 object。 行为 写关注 remove()方法使用删除命令，该命令使用默认的写关注。要指定其他写入问题，请在 options 参数中包含写入关注点。 查询注意事项 默认情况下，remove()删除 match query表达式的所有文档。指定justOne选项以限制删除单个文档的操作。要删除按指定 order 排序的单个文档，请使用findAndModify()方法。 删除多个文档时，删除操作可能与对集合的其他读 and/or 写操作交错。 上限集合 您不能将remove()方法与上限集合一起使用。 分片集合 指定justOne选项的分片集合的所有remove()操作必须包含查询规范中的碎片 key或_id字段。 remove()操作在分片集合中指定justOne，不包含碎片 key或_id字段返回错误。 事务 db.collection.remove()可以在多文档事务中使用。 如果在事务中运行，请不要为操作明确设置写关注点。要对事务使用写关注，请参见 事务和写关注。 重要 在大多数情况下，与单文档写入相比，多文档事务产生的性能成本更高，并且多文档事务的可用性不应替代有效的架构设计。在许多情况下， 非规范化数据模型（嵌入式文档和数组）将继续是您的数据和用例的最佳选择。也就是说，在许多情况下，适当地对数据建模将最大程度地减少对多文档交易的需求。 有关其他事务使用方面的注意事项（例如运行时限制和操作日志大小限制），另请参见 生产注意事项。 例子 以下是remove()方法的示例。 从集合中删除所有文档 要删除集合中的所有文档，请使用空查询文档{}调用去掉方法。以下操作将删除bios 系列中的所有文档： db.bios.remove( { } ) 此操作不等同于drop()方法。 要从集合中删除所有文档，使用drop()方法删除整个集合(包括索引)，然后重新创建集合并重建索引可能更有效。 删除符合的所有文档 要删除匹配删除条件的文档，请使用参数调用remove()方法： 以下操作将从集合products中删除qty大于20的所有文档： db.products.remove( { qty: { $gt: 20 } } ) 覆盖默认写入关注 对副本集的以下操作将删除集合products中qty大于20的所有文档，并指定\"w: majority\"的\"w: majority\"，其wtimeout为 5000 毫秒，以便该方法在写入传播到大多数表决副本集后返回成员或方法在 5 秒后超时。 db.products.remove( { qty: { $gt: 20 } }, { writeConcern: { w: \"majority\", wtimeout: 5000 } } ) 删除匹配条件的单个文档 要删除匹配删除条件的第一个文档，请使用query条件调用去掉方法，并将justOne参数设置为true或1。 以下操作从集合products中删除第一个文档，其中qty大于20： db.products.remove( { qty: { $gt: 20 } }, true ) 指定排序规则 version 3.4 中的新内容。 整理允许用户为 string 比较指定 language-specific 规则，例如字母和重音标记的规则。 集合myColl具有以下文档： { _id: 1, category: \"cafe\", status: \"A\" } { _id: 2, category: \"cafe\", status: \"a\" } { _id: 3, category: \"cafE\", status: \"a\" } 以下操作包括整理选项： db.myColl.remove( { category: \"cafe\", status: \"A\" }, { collation: { locale: \"fr\", strength: 1 } } ) 写结果 更改了 version 2.6. 成功的结果 remove()返回包含操作状态的写结果 object。成功后，写结果 object 包含有关删除的文档数量的信息： WriteResult({ \"nRemoved\" : 4 }) 也可以看看 WriteResult.nRemoved 写下关注错误 如果remove()方法遇到写入关注错误，则结果包括WriteResult.writeConcernError字段： WriteResult({ \"nRemoved\" : 21, \"writeConcernError\" : { \"code\" : 64, \"errInfo\" : { \"wtimeout\" : true }, \"errmsg\" : \"waiting for replication timed out\" } }) 也可以看看 WriteResult.hasWriteConcernError() 与写关注无关的错误 如果remove()方法遇到 non-write 关注错误，则结果包括WriteResult.writeError字段： WriteResult({ \"nRemoved\" : 0, \"writeError\" : { \"code\" : 2, \"errmsg\" : \"unknown top level operator: $invalidFieldName\" } }) 也可以看看 WriteResult.hasWriteError() Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-renameCollection.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-renameCollection.html","title":"db.collection.renameCollection()","keywords":"","body":" db.collection.renameCollection（） 在本页面 定义 行为 例子 定义 db.collection. renameCollection(target，dropTarget) 重命名集合。为renameCollection 数据库命令提供包装。 参数 类型 描述 target string 集合的新 name。将 string 括在引号中。 dropTarget boolean 可选的。如果true，mongod在重命名集合之前删除了renameCollection的目标。默认的 value 是false。 行为 db.collection.renameCollection()方法通过更改与给定集合关联的元数据在集合中运行。 有关其他警告和消息，请参阅文档renameCollection。 警告 db.collection.renameCollection()方法和renameCollection命令将使打开的游标无效，这会中断当前返回数据的查询。 对于Change Streams，该 db.collection.renameCollection()方法和 renameCollection命令为在源或目标集合上打开的任何现有 Change Streams创建一个 无效事件。 该方法具有以下限制： db.collection.renameCollection()无法在数据库之间移动集合。使用renameCollection进行这些重命名操作。 分片集合不支持db.collection.renameCollection()。 您无法重命名意见。 资源锁定 在版本4.2中进行了更改。 renameCollection()在操作期间获得对源集合和目标集合的排他锁。集合上的所有后续操作都必须等到 renameCollection()完成。在MongoDB 4.2之前的版本中，renameCollection需要获得独占数据库锁才能重命名同一数据库内的集合 。 与mongodump交互 一mongodump开始 --oplog，如果客户的问题未能 db.collection.renameCollection()在转储过程。请参阅 以获取更多信息。mongodump --oplog 例子 在集合 object 上调用db.collection.renameCollection()方法。例如： db.rrecord.renameCollection(\"record\") 此操作会将rrecord集合重命名为record。如果目标 name(i.e.record)是现有集合的 name，则操作将失败。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-replaceOne.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-replaceOne.html","title":"db.collection.replaceOne()","keywords":"","body":" db.collection.replaceOne（） 在本页面 定义 行为 例子 定义 db.collection. replaceOne(过滤，替换，选项) version 3.2 中的新内容。 根据过滤器替换集合中的单个文档。 replaceOne()方法具有以下形式： db.collection.replaceOne( , , { upsert: , writeConcern: , collation: } ) replaceOne()方法采用以下参数： 参数 类型 描述 filter document 更新的选择标准。可以使用与find()方法相同的query selectors。 指定一个空文档{ }以替换集合中返回的第一个文档。 replacement document 替换文件。 不能包含更新 operators。 upsert boolean 可选的。当true，replaceOne()时：如果没有文档与filter匹配，则从replacement参数插入文档。 将与filter匹配的文档替换为replacement文档。如果未在filter或replacement文档中指定_id如果filter或replacement文档中未指定。 MongoDB，则会将_id字段添加到替换文档中。如果两者都存在_id，则值必须相等。 要避免多次 upsert，请确保query字段为唯一索引。 默认为false。 writeConcern document 可选的。表示写关注的文件。省略使用默认写入问题。如果在事务中运行，请不要为操作明确设置写关注点。要对事务使用写关注，请参见 事务和写关注。 collation document 可选的。 指定要用于操作的排序规则。 排序规则允许用户为 string 比较指定 language-specific 规则，例如字母和重音标记的规则。 排序规则选项具有以下语法：collation：{ locale：， caseLevel：， caseFirst：， strength：， numericOrdering：， alternate：， maxVariable：， backwards ： } 指定排序规则时，locale字段是必填字段;所有其他校对字段都是可选的。有关字段的说明，请参阅整理文件。 如果未指定排序规则但集合具有默认排序规则(请参阅db.createCollection())，则操作将使用为集合指定的排序规则。 如果没有为集合或操作指定排序规则，MongoDB 使用先前版本中用于 string 比较的简单二进制比较。 您无法为操作指定多个排序规则。对于 example，您不能为每个字段指定不同的排序规则，或者如果使用排序执行查找，则不能对查找使用一个排序规则，而对排序使用另一个排序规则。 version 3.4 中的新内容。 hint document 可选的。指定用于支持过滤器的索引的文档或字符串。该选项可以采用索引规范文档或索引名称字符串。如果指定的索引不存在，则操作错误。有关示例，请参阅为replaceOne指定提示。4.2.1版中的新功能。 返回： 包含以下内容的文档：一个布尔值acknowledged，就true好像该操作在运行时带有 写关注关系或false是否禁用了写关注关系 matchedCount包含匹配文档数 modifiedCount包含已修改文档数 upsertedId包含_id for upserted 文档 行为 replaceOne()使用replacement文档替换集合中与filter匹配的第一个匹配文档。 upsert 如果upsert: true和filter没有文档匹配，则 db.collection.replaceOne()根据replacement文档创建一个新文档。 如果在分片集合上指定upsert: true，则必须在filter 中包含完整的分片键。有关分片集合的其他 db.collection.replaceOne()行为，请参见分片集合。 请参阅用Upsert替换。 上限收藏 如果替换操作更改了文档大小，则操作将失败。 分片集合 从MongoDB 4.2开始，首先db.collection.replaceOne()尝试使用查询过滤器定位单个分片。如果该操作无法通过查询过滤器定位到单个分片，则它将尝试以替换文档定位。 在早期版本中，该操作尝试使用替换文档作为目标。 如果替换分片集合中的文档，则替换文档必须包含分片键。附加要求适用于分片集合和分片 密钥修改上的更新。 upsert在分片集合上 从MongoDB 4.2开始，对于db.collection.replaceOne() 包含upsert: true分片集合并在分片集合上的操作，您必须在filter中包含完整的分片键。 碎片键修改 从MongoDB 4.2开始，您可以更新文档的分片键值，除非分片键字段是不可变_id字段。有关更新分片键的详细信息，请参见更改文档的分片键值。 在MongoDB 4.2之前，文档的分片键字段值是不可变的。 要用于db.collection.replaceOne()更新分片键： 您必须在运行mongos无论是在 事务或作为重试写。千万不能直接在碎片颁发运行。 您必须在查询过滤器的完整分片键上包含相等条件。例如，如果一个集合messages 使用{ country : 1, userid : 1 }的片键，更新为一个文件的碎片关键，你必须包括country: , userid: 在查询过滤器。您可以根据需要在查询中包括其他字段。 事务 db.collection.replaceOne()可以在多文档交易中使用。 如果该操作导致upsert，则该集合必须已经存在。 如果在事务中运行，请不要为操作明确设置写关注点。要对事务使用写关注，请参见 事务和写关注。 重要 在大多数情况下，与单文档写入相比，多文档事务产生的性能成本更高，并且多文档事务的可用性不应替代有效的架构设计。在许多情况下， 非规范化数据模型（嵌入式文档和数组）将继续是您的数据和用例的最佳选择。也就是说，在许多情况下，适当地对数据建模将最大程度地减少对多文档交易的需求。 有关其他事务使用方面的注意事项（例如运行时限制和操作日志大小限制），另请参见 生产注意事项。 例子 替换 restaurant集合包含以下文档： { \"_id\" : 1, \"name\" : \"Central Perk Cafe\", \"Borough\" : \"Manhattan\" }, { \"_id\" : 2, \"name\" : \"Rock A Feller Bar and Grill\", \"Borough\" : \"Queens\", \"violations\" : 2 }, { \"_id\" : 3, \"name\" : \"Empire State Pub\", \"Borough\" : \"Brooklyn\", \"violations\" : 0 } 以下操作替换name: \"Central Perk Cafe\"所在的单个文档： try { db.restaurant.replaceOne( { \"name\" : \"Central Perk Cafe\" }, { \"name\" : \"Central Pork Cafe\", \"Borough\" : \"Manhattan\" } ); } catch (e){ print(e); } 操作返回： { \"acknowledged\" : true, \"matchedCount\" : 1, \"modifiedCount\" : 1 } 如果未找到匹配项，则操作将返回： { \"acknowledged\" : true, \"matchedCount\" : 0, \"modifiedCount\" : 0 } 如果未找到 match，则设置upsert: true将插入文档。见替换为 Upsert 替换为 Upsert restaurant集合包含以下文档： { \"_id\" : 1, \"name\" : \"Central Perk Cafe\", \"Borough\" : \"Manhattan\", \"violations\" : 3 }, { \"_id\" : 2, \"name\" : \"Rock A Feller Bar and Grill\", \"Borough\" : \"Queens\", \"violations\" : 2 }, { \"_id\" : 3, \"name\" : \"Empire State Pub\", \"Borough\" : \"Brooklyn\", \"violations\" : 0 } 以下操作尝试使用upsert : true替换文档，使用upsert : true： try { db.restaurant.replaceOne( { \"name\" : \"Pizza Rat's Pizzaria\" }, { \"_id\": 4, \"name\" : \"Pizza Rat's Pizzaria\", \"Borough\" : \"Manhattan\", \"violations\" : 8 }, { upsert: true } ); } catch (e){ print(e); } 从upsert : true开始，文档是根据replacement文档插入的。操作返回： { \"acknowledged\" : true, \"matchedCount\" : 0, \"modifiedCount\" : 0, \"upsertedId\" : 4 } 该集合现在包含以下文档： { \"_id\" : 1, \"name\" : \"Central Perk Cafe\", \"Borough\" : \"Manhattan\", \"violations\" : 3 }, { \"_id\" : 2, \"name\" : \"Rock A Feller Bar and Grill\", \"Borough\" : \"Queens\", \"violations\" : 2 }, { \"_id\" : 3, \"name\" : \"Empire State Pub\", \"Borough\" : \"Brooklyn\", \"violations\" : 0 }, { \"_id\" : 4, \"name\" : \"Pizza Rat's Pizzaria\", \"Borough\" : \"Manhattan\", \"violations\" : 8 } 替换为写关注 给定三个成员副本集，以下操作指定majority majority和wtimeout 100： try { db.restaurant.replaceOne( { \"name\" : \"Pizza Rat's Pizzaria\" }, { \"name\" : \"Pizza Rat's Pub\", \"Borough\" : \"Manhattan\", \"violations\" : 3 }, { w: \"majority\", wtimeout: 100 } ); } catch (e) { print(e); } 如果确认时间超过wtimeout限制，则抛出以下 exception： WriteConcernError({ \"code\" : 64, \"errInfo\" : { \"wtimeout\" : true }, \"errmsg\" : \"waiting for replication timed out\" }) 指定排序规则 version 3.4 中的新内容。 整理允许用户为 string 比较指定 language-specific 规则，例如字母和重音标记的规则。 集合myColl具有以下文档： { _id: 1, category: \"café\", status: \"A\" } { _id: 2, category: \"cafe\", status: \"a\" } { _id: 3, category: \"cafE\", status: \"a\" } 以下操作包括整理选项： db.myColl.replaceOne( { category: \"cafe\", status: \"a\" }, { category: \"cafÉ\", status: \"Replaced\" }, { collation: { locale: \"fr\", strength: 1 } } ); 指定hint用于replaceOne 4.2.1版中的新功能。 members使用以下文档创建样本集合： db.members.insertMany([ { \"_id\" : 1, \"member\" : \"abc123\", \"status\" : \"P\", \"points\" : 0, \"misc1\" : null, \"misc2\" : null }, { \"_id\" : 2, \"member\" : \"xyz123\", \"status\" : \"A\", \"points\" : 60, \"misc1\" : \"reminder: ping me at 100pts\", \"misc2\" : \"Some random comment\" }, { \"_id\" : 3, \"member\" : \"lmn123\", \"status\" : \"P\", \"points\" : 0, \"misc1\" : null, \"misc2\" : null }, { \"_id\" : 4, \"member\" : \"pqr123\", \"status\" : \"D\", \"points\" : 20, \"misc1\" : \"Deactivated\", \"misc2\" : null }, { \"_id\" : 5, \"member\" : \"ijk123\", \"status\" : \"P\", \"points\" : 0, \"misc1\" : null, \"misc2\" : null }, { \"_id\" : 6, \"member\" : \"cde123\", \"status\" : \"A\", \"points\" : 86, \"misc1\" : \"reminder: ping me at 100pts\", \"misc2\" : \"Some random comment\" } ]) 在集合上创建以下索引： db.members.createIndex( { status: 1 } ) db.members.createIndex( { points: 1 } ) 以下更新操作明确暗示要使用索引：{ status: 1 } 注意 如果指定的索引不存在，则操作错误。 db.members.replaceOne( { \"points\": { $lte: 20 }, \"status\": \"P\" }, { \"misc1\": \"using index on status\", status: \"P\", member: \"replacement\", points: \"20\"}, { hint: { status: 1 } } ) 该操作返回以下内容： { \"acknowledged\" : true, \"matchedCount\" : 1, \"modifiedCount\" : 1 } 要查看使用的索引，可以使用$indexStats管道： db.members.aggregate( [ { $indexStats: { } }, { $sort: { name: 1 } } ] ) Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-save.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-save.html","title":"db.collection.save()","keywords":"","body":" db.collection.save（） 在本页面 定义 行为 例子 写结果 定义 db.collection. save () 更新现有的文献或插入新文档，具体取决于其document参数。 注意 MongoDB弃用该db.collection.save()方法。而是使用db.collection.insertOne()或 db.collection.replaceOne()代替。 save()方法具有以下形式： db.collection.save( , { writeConcern: } ) 参数 类型 描述 document document 要保存到集合的文档。 writeConcern document 可选的。表示写关注的文件。省略使用默认写入问题。见写关注。 如果在事务中运行，请不要为操作明确设置写关注点。要对事务使用写关注，请参见 事务和写关注。 该save()返回包含操作的状态的对象。 返回： 包含操作状态的写结果 object。 行为 写关注 save()方法使用插入或更新命令，它使用默认的写关注。要指定其他写关注点，请在 options 参数中包含写入关注点。 插入 如果文档不包含_id字段，则save()方法 calls insert()方法。在操作期间，mongo shell 将创建ObjectId并将其分配给_id字段。 注意 大多数 MongoDB 驱动程序 clients 将包含_id字段并在将 insert 操作发送到 MongoDB 之前生成ObjectId;但是，如果 client 发送没有_id字段的文档，则mongod将添加_id字段并生成ObjectId。 更新 如果文档包含_id字段，则save()方法等效于upsert 选项设置为true且_id字段上的查询谓词的更新。 事务 db.collection.save()可以在多文档交易中使用。 如果该操作导致插入，则该集合必须已经存在。 如果在事务中运行，请不要为操作明确设置写关注点。要对事务使用写关注，请参见 事务和写关注。 重要 在大多数情况下，与单文档写入相比，多文档事务产生的性能成本更高，并且多文档事务的可用性不应替代有效的架构设计。在许多情况下， 非规范化数据模型（嵌入式文档和数组）将继续是您的数据和用例的最佳选择。也就是说，在许多情况下，适当地对数据建模将最大程度地减少对多文档交易的需求。 有关其他事务使用方面的注意事项（例如运行时限制和操作日志大小限制），另请参见 生产注意事项。 例子 保存新文档而不指定_id 字段 在下面的示例中，save()方法执行 insert，因为传递给该方法的文档不包含_id字段： db.products.save( { item: \"book\", qty: 40 } ) 在 insert 期间，shell 将创建具有唯一ObjectId value 的_id字段，由插入的文档验证： { \"_id\" : ObjectId(\"50691737d386d8fadbd6b01d\"), \"item\" : \"book\", \"qty\" : 40 } 当操作为 run 时，ObjectId值特定于机器和 time。因此，您的值可能与 example 中的值不同。 保存新文档指定_id 字段 在下面的示例中，save()使用upsert:true执行更新，因为文档包含_id字段： db.products.save( { _id: 100, item: \"water\", qty: 30 } ) 由于_id字段包含集合中不存在的 value，因此更新操作会导致插入文档。这些操作的结果与带有 upsert 选项的 update()方法设置为true相同。 该操作导致products集合中的以下新文档： { \"_id\" : 100, \"item\" : \"water\", \"qty\" : 30 } 替换现有文档 products集合包含以下文档： { \"_id\" : 100, \"item\" : \"water\", \"qty\" : 30 } save()方法使用upsert:true执行更新，因为文档包含_id字段： db.products.save( { _id : 100, item : \"juice\" } ) 由于_id字段包含集合中存在的 value，因此操作会执行更新以替换文档并生成以下文档： { \"_id\" : 100, \"item\" : \"juice\" } 覆盖默认写入关注 对副本集的以下操作指定\"w: majority\"的\"w: majority\"，其wtimeout为 5000 毫秒，以便该方法在写入传播到大多数表决副本集成员后返回，或者该方法在 5 秒后超时。 db.products.save( { item: \"envelopes\", qty : 100, type: \"Clasp\" }, { writeConcern: { w: \"majority\", wtimeout: 5000 } } ) 写结果 将save()返回一个WriteResult包含插入或更新操作的状态对象。有关详细信息，请参见WriteResult以获得插入信息，并 参见 WriteResult以获得更新信息。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-stats.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-stats.html","title":"db.collection.stats()","keywords":"","body":" db.collection.stats（） 在本页面 定义 行为 例子 定义 db.collection. stats(选项) 返回有关集合的统计信息。 该方法包括以下参数： 参数 类型 描述 scale number 可选的。输出中使用的比例显示项目的大小。默认情况下，输出显示bytes中的大小。要显示千字节而不是字节，请指定1024 value 1024。 如果您指定非整数比例因子，则MongoDB将使用指定因子的整数部分。例如，如果将比例因子指定为1023.999，则MongoDB将使用1023该比例因子。从4.2版开始，输出包括scaleFactor 用于缩放大小值的输出。 indexDetails boolean 可选的。如果为true，则db.collection.stats()除收集统计信息外，还返回 index details仅适用于WiredTiger存储引擎。默认为false。 indexDetailsKey document 可选的。如果indexDetails是true，则可以使用indexDetailsKey通过指定索引 key 规范来过滤索引详细信息。只返回与indexDetailsKey完全匹配的索引。 如果找不到匹配项，indexDetails将显示所有索引的统计信息。 使用getIndexes()发现索引键。你不能将indexDetailsKey与indexDetailsName一起使用。 indexDetailsName string 可选的。如果indexDetails是true，则可以使用indexDetailsName通过指定索引name来过滤索引详细信息。只返回与indexDetailsName完全匹配的索引名称。 如果找不到匹配项，indexDetails将显示所有索引的统计信息。 使用getIndexes()来发现索引名称。你不能将indexDetailsName与indexDetailsField一起使用。 仅指定scale因素，MongoDB支持旧格式： db.collection.stats() 返回值： 包含有关指定集合的统计信息的文档。请参阅collStats以获取返回统计信息的细分。 该db.collection.stats()方法提供了围绕数据库命令的包装collStats。 行为 缩放大小 除非度量标准名称（例如\"bytes currently in the cache\" ）另外指定，与大小相关的值以字节为单位显示，可以按比例覆盖。。 比例因子将受影响的大小值四舍五入为整数。 存储引擎 根据存储引擎，返回的数据可能不同。有关字段的详细信息，请参阅输出详细信息。 意外关机后的准确性 使用Wired Tiger存储引擎不正常关闭mongod后，db.collection.stats()报告的计数和大小统计信息可能不准确。 偏移量取决于在最后检查站和不干净关闭之间执行的 insert，update 或 delete 操作的数量。检查点通常每 60 秒发生一次。但是，使用 non-default --syncdelay设置运行mongod实例可能会有更多或更少的检查点。 在mongod上的每个集合上运行验证以在不正常关闭后恢复正确的统计信息。 索引过滤器行为 使用indexDetailsKey或indexDetailsName过滤indexDetails将仅_return 单个匹配的索引。如果未找到确切的 match，indexDetails将显示有关集合的所有索引的信息。 indexDetailsKey字段采用以下形式的文档： { '' : , '' : , ... } 其中是索引的字段，是索引的方向，或特殊索引类型，如text或2dsphere。有关索引类型的完整列表，请参见索引类型。 意外停机和计数 对于使用WiredTiger存储引擎的 MongoDB 实例，在不正常关闭后，大小和计数的统计信息可能会被collStats，dbStats，计数报告最多 1000 个文档。要恢复集合的正确统计信息，请在集合上运行 run 验证。 进行中索引 从MongoDB 4.2开始，db.collection.stats包括有关当前正在构建的索引的信息。有关详细信息，请参见： collStats.nindexes collStats.indexDetails collStats.indexBuilds collStats.totalIndexSize collStats.indexSizes 例子 注意 您可以在入门指南中找到用于这些示例的集合数据 基本统计查询 以下操作返回restaurants集合上的统计信息： db.restaurants.stats() 操作返回： { \"ns\" : \"guidebook.restaurants\", \"count\" : 25359, \"size\" : 10630398, \"avgObjSize\" : 419, \"storageSize\" : 4104192 \"capped\" : false, \"wiredTiger\" : { \"metadata\" : { \"formatVersion\" : 1 }, \"creationString\" : \"allocation_size=4KB,app_metadata=(formatVersion=1),block_allocation=best,block_compressor=snappy,cache_resident=0,checksum=on,colgroups=,collator=,columns=,dictionary=0,encryption=(keyid=,name=),exclusive=0,extractor=,format=btree,huffman_key=,huffman_value=,immutable=0,internal_item_max=0,internal_key_max=0,internal_key_truncate=,internal_page_max=4KB,key_format=q,key_gap=10,leaf_item_max=0,leaf_key_max=0,leaf_page_max=32KB,leaf_value_max=64MB,log=(enabled=),lsm=(auto_throttle=,bloom=,bloom_bit_count=16,bloom_config=,bloom_hash_count=8,bloom_oldest=0,chunk_count_limit=0,chunk_max=5GB,chunk_size=10MB,merge_max=15,merge_min=0),memory_page_max=10m,os_cache_dirty_max=0,os_cache_max=0,prefix_compression=0,prefix_compression_min=4,source=,split_deepen_min_child=0,split_deepen_per_child=0,split_pct=90,type=file,value_format=u\", \"type\" : \"file\", \"uri\" : \"statistics:table:collection-2-7253336746667145592\", \"LSM\" : { \"bloom filters in the LSM tree\" : 0, \"bloom filter false positives\" : 0, \"bloom filter hits\" : 0, \"bloom filter misses\" : 0, \"bloom filter pages evicted from cache\" : 0, \"bloom filter pages read into cache\" : 0, \"total size of bloom filters\" : 0, \"sleep for LSM checkpoint throttle\" : 0, \"chunks in the LSM tree\" : 0, \"highest merge generation in the LSM tree\" : 0, \"queries that could have benefited from a Bloom filter that did not exist\" : 0, \"sleep for LSM merge throttle\" : 0 }, \"block-manager\" : { \"file allocation unit size\" : 4096, \"blocks allocated\" : 338, \"checkpoint size\" : 4096000, \"allocations requiring file extension\" : 338, \"blocks freed\" : 0, \"file magic number\" : 120897, \"file major version number\" : 1, \"minor version number\" : 0, \"file bytes available for reuse\" : 0, \"file size in bytes\" : 4104192 }, \"btree\" : { \"btree checkpoint generation\" : 15, \"column-store variable-size deleted values\" : 0, \"column-store fixed-size leaf pages\" : 0, \"column-store internal pages\" : 0, \"column-store variable-size leaf pages\" : 0, \"pages rewritten by compaction\" : 0, \"number of key/value pairs\" : 0, \"fixed-record size\" : 0, \"maximum tree depth\" : 3, \"maximum internal page key size\" : 368, \"maximum internal page size\" : 4096, \"maximum leaf page key size\" : 3276, \"maximum leaf page size\" : 32768, \"maximum leaf page value size\" : 67108864, \"overflow pages\" : 0, \"row-store internal pages\" : 0, \"row-store leaf pages\" : 0 }, \"cache\" : { \"bytes read into cache\" : 9309503, \"bytes written from cache\" : 10817368, \"checkpoint blocked page eviction\" : 0, \"unmodified pages evicted\" : 0, \"page split during eviction deepened the tree\" : 0, \"modified pages evicted\" : 1, \"data source pages selected for eviction unable to be evicted\" : 0, \"hazard pointer blocked page eviction\" : 0, \"internal pages evicted\" : 0, \"pages split during eviction\" : 1, \"in-memory page splits\" : 1, \"overflow values cached in memory\" : 0, \"pages read into cache\" : 287, \"overflow pages read into cache\" : 0, \"pages written from cache\" : 337 }, \"compression\" : { \"raw compression call failed, no additional data available\" : 0, \"raw compression call failed, additional data available\" : 0, \"raw compression call succeeded\" : 0, \"compressed pages read\" : 287, \"compressed pages written\" : 333, \"page written failed to compress\" : 0, \"page written was too small to compress\" : 4 }, \"cursor\" : { \"create calls\" : 1, \"insert calls\" : 25359, \"bulk-loaded cursor-insert calls\" : 0, \"cursor-insert key and value bytes inserted\" : 10697901, \"next calls\" : 76085, \"prev calls\" : 1, \"remove calls\" : 0, \"cursor-remove key bytes removed\" : 0, \"reset calls\" : 25959, \"restarted searches\" : 0, \"search calls\" : 0, \"search near calls\" : 594, \"update calls\" : 0, \"cursor-update value bytes updated\" : 0 }, \"reconciliation\" : { \"dictionary matches\" : 0, \"internal page multi-block writes\" : 1, \"leaf page multi-block writes\" : 2, \"maximum blocks required for a page\" : 47, \"internal-page overflow keys\" : 0, \"leaf-page overflow keys\" : 0, \"overflow values written\" : 0, \"pages deleted\" : 0, \"page checksum matches\" : 0, \"page reconciliation calls\" : 4, \"page reconciliation calls for eviction\" : 1, \"leaf page key bytes discarded using prefix compression\" : 0, \"internal page key bytes discarded using suffix compression\" : 333 }, \"session\" : { \"object compaction\" : 0, \"open cursor count\" : 1 }, \"transaction\" : { \"update conflicts\" : 0 } }, \"nindexes\" : 4, \"totalIndexSize\" : 626688, \"indexSizes\" : { \"_id_\" : 217088, \"borough_1_cuisine_1\" : 139264, \"cuisine_1\" : 131072, \"borough_1_address.zipcode_1\" : 139264 }, \"ok\" : 1 } 由于统计数据未给出比例参数，因此所有大小值都在bytes中。 带有比例的统计查询 以下操作通过指定scale的scale来更改从bytes到kilobytes的数据比例： db.restaurants.stats( { scale : 1024 } ) 操作返回： { \"ns\" : \"guidebook.restaurants\", \"count\" : 25359, \"size\" : 10381, \"avgObjSize\" : 419, \"storageSize\" : 4008, \"capped\" : false, \"wiredTiger\" : { ... }, \"nindexes\" : 4, \"totalIndexSize\" : 612, \"indexSizes\" : { \"_id_\" : 212, \"borough_1_cuisine_1\" : 136, \"cuisine_1\" : 128, \"borough_1_address.zipcode_1\" : 136 }, \"ok\" : 1 } 带索引详细信息的统计查找 以下操作将创建一个indexDetails文档，其中包含与集合中每个索引相关的信息： db.restaurant.stats( { indexDetails : true } ) 操作返回： { \"ns\" : \"guidebook.restaurants\", \"count\" : 25359, \"size\" : 10630398, \"avgObjSize\" : 419, \"storageSize\" : 4104192, \"capped\" : false, \"wiredTiger\" : { ... }, \"nindexes\" : 4, \"indexDetails\" : { \"_id_\" : { \"metadata\" : { \"formatVersion\" : 6, \"infoObj\" : \"{ \\\"v\\\" : 1, \\\"key\\\" : { \\\"_id\\\" : 1 }, \\\"name\\\" : \\\"_id_\\\", \\\"ns\\\" : \\\"blogs.posts\\\" }\" }, \"creationString\" : \"allocation_size=4KB,app_metadata=(formatVersion=6,infoObj={ \\\"v\\\" : 1, \\\"key\\\" : { \\\"_id\\\" : 1 }, \\\"name\\\" : \\\"_id_\\\", \\\"ns\\\" : \\\"blogs.posts\\\" }),block_allocation=best,block_compressor=,cache_resident=0,checksum=on,colgroups=,collator=,columns=,dictionary=0,encryption=(keyid=,name=),exclusive=0,extractor=,format=btree,huffman_key=,huffman_value=,immutable=0,internal_item_max=0,internal_key_max=0,internal_key_truncate=,internal_page_max=16k,key_format=u,key_gap=10,leaf_item_max=0,leaf_key_max=0,leaf_page_max=16k,leaf_value_max=0,log=(enabled=),lsm=(auto_throttle=,bloom=,bloom_bit_count=16,bloom_config=,bloom_hash_count=8,bloom_oldest=0,chunk_count_limit=0,chunk_max=5GB,chunk_size=10MB,merge_max=15,merge_min=0),memory_page_max=5MB,os_cache_dirty_max=0,os_cache_max=0,prefix_compression=true,prefix_compression_min=4,source=,split_deepen_min_child=0,split_deepen_per_child=0,split_pct=75,type=file,value_format=u\", \"type\" : \"file\", \"uri\" : \"statistics:table:index-3-7253336746667145592\", \"LSM\" : { ... }, \"block-manager\" : { ... }, \"btree\" : { ... }, \"cache\" : { ... }, \"compression\" : { ... }, \"cursor\" : { ... }, \"reconciliation\" : { ... }, \"session\" : { ... }, \"transaction\" : { ... } }, \"borough_1_cuisine_1\" : { \"metadata\" : { \"formatVersion\" : 6, \"infoObj\" : \"{ \\\"v\\\" : 1, \\\"key\\\" : { \\\"borough\\\" : 1, \\\"cuisine\\\" : 1 }, \\\"name\\\" : \\\"borough_1_cuisine_1\\\", \\\"ns\\\" : \\\"blogs.posts\\\" }\" }, \"creationString\" : \"allocation_size=4KB,app_metadata=(formatVersion=6,infoObj={ \\\"v\\\" : 1, \\\"key\\\" : { \\\"borough\\\" : 1, \\\"cuisine\\\" : 1 }, \\\"name\\\" : \\\"borough_1_cuisine_1\\\", \\\"ns\\\" : \\\"blogs.posts\\\" }),block_allocation=best,block_compressor=,cache_resident=0,checksum=on,colgroups=,collator=,columns=,dictionary=0,encryption=(keyid=,name=),exclusive=0,extractor=,format=btree,huffman_key=,huffman_value=,immutable=0,internal_item_max=0,internal_key_max=0,internal_key_truncate=,internal_page_max=16k,key_format=u,key_gap=10,leaf_item_max=0,leaf_key_max=0,leaf_page_max=16k,leaf_value_max=0,log=(enabled=),lsm=(auto_throttle=,bloom=,bloom_bit_count=16,bloom_config=,bloom_hash_count=8,bloom_oldest=0,chunk_count_limit=0,chunk_max=5GB,chunk_size=10MB,merge_max=15,merge_min=0),memory_page_max=5MB,os_cache_dirty_max=0,os_cache_max=0,prefix_compression=true,prefix_compression_min=4,source=,split_deepen_min_child=0,split_deepen_per_child=0,split_pct=75,type=file,value_format=u\", \"type\" : \"file\", \"uri\" : \"statistics:table:index-4-7253336746667145592\", \"LSM\" : { ... }, \"block-manager\" : { ... }, \"btree\" : { ... }, \"cache\" : { ... }, \"compression\" : { ... }, \"cursor\" : { ... }, \"reconciliation\" : { ... }, \"session\" : { \"object compaction\" : 0, \"open cursor count\" : 0 }, \"transaction\" : { \"update conflicts\" : 0 } }, \"cuisine_1\" : { \"metadata\" : { \"formatVersion\" : 6, \"infoObj\" : \"{ \\\"v\\\" : 1, \\\"key\\\" : { \\\"cuisine\\\" : 1 }, \\\"name\\\" : \\\"cuisine_1\\\", \\\"ns\\\" : \\\"blogs.posts\\\" }\" }, \"creationString\" : \"allocation_size=4KB,app_metadata=(formatVersion=6,infoObj={ \\\"v\\\" : 1, \\\"key\\\" : { \\\"cuisine\\\" : 1 }, \\\"name\\\" : \\\"cuisine_1\\\", \\\"ns\\\" : \\\"blogs.posts\\\" }),block_allocation=best,block_compressor=,cache_resident=0,checksum=on,colgroups=,collator=,columns=,dictionary=0,encryption=(keyid=,name=),exclusive=0,extractor=,format=btree,huffman_key=,huffman_value=,immutable=0,internal_item_max=0,internal_key_max=0,internal_key_truncate=,internal_page_max=16k,key_format=u,key_gap=10,leaf_item_max=0,leaf_key_max=0,leaf_page_max=16k,leaf_value_max=0,log=(enabled=),lsm=(auto_throttle=,bloom=,bloom_bit_count=16,bloom_config=,bloom_hash_count=8,bloom_oldest=0,chunk_count_limit=0,chunk_max=5GB,chunk_size=10MB,merge_max=15,merge_min=0),memory_page_max=5MB,os_cache_dirty_max=0,os_cache_max=0,prefix_compression=true,prefix_compression_min=4,source=,split_deepen_min_child=0,split_deepen_per_child=0,split_pct=75,type=file,value_format=u\", \"type\" : \"file\", \"uri\" : \"statistics:table:index-5-7253336746667145592\", \"LSM\" : { ... }, \"block-manager\" : { ... }, \"btree\" : { ... }, \"cache\" : { ... }, \"compression\" : { ... }, \"cursor\" : { ... }, \"reconciliation\" : { ... }, \"session\" : { ... }, \"transaction\" : { ... } }, \"borough_1_address.zipcode_1\" : { \"metadata\" : { \"formatVersion\" : 6, \"infoObj\" : \"{ \\\"v\\\" : 1, \\\"key\\\" : { \\\"borough\\\" : 1, \\\"address.zipcode\\\" : 1 }, \\\"name\\\" : \\\"borough_1_address.zipcode_1\\\", \\\"ns\\\" : \\\"blogs.posts\\\" }\" }, \"creationString\" : \"allocation_size=4KB,app_metadata=(formatVersion=6,infoObj={ \\\"v\\\" : 1, \\\"key\\\" : { \\\"borough\\\" : 1, \\\"address.zipcode\\\" : 1 }, \\\"name\\\" : \\\"borough_1_address.zipcode_1\\\", \\\"ns\\\" : \\\"blogs.posts\\\" }),block_allocation=best,block_compressor=,cache_resident=0,checksum=on,colgroups=,collator=,columns=,dictionary=0,encryption=(keyid=,name=),exclusive=0,extractor=,format=btree,huffman_key=,huffman_value=,immutable=0,internal_item_max=0,internal_key_max=0,internal_key_truncate=,internal_page_max=16k,key_format=u,key_gap=10,leaf_item_max=0,leaf_key_max=0,leaf_page_max=16k,leaf_value_max=0,log=(enabled=),lsm=(auto_throttle=,bloom=,bloom_bit_count=16,bloom_config=,bloom_hash_count=8,bloom_oldest=0,chunk_count_limit=0,chunk_max=5GB,chunk_size=10MB,merge_max=15,merge_min=0),memory_page_max=5MB,os_cache_dirty_max=0,os_cache_max=0,prefix_compression=true,prefix_compression_min=4,source=,split_deepen_min_child=0,split_deepen_per_child=0,split_pct=75,type=file,value_format=u\", \"type\" : \"file\", \"uri\" : \"statistics:table:index-6-7253336746667145592\", \"LSM\" : { ... }, \"block-manager\" : { ... }, \"btree\" : { ... }, \"cache\" : { ... }, \"compression\" : { ... }, \"cursor\" : { ... }, \"reconciliation\" : { ... }, \"session\" : { ... }, \"transaction\" : { ... } } }, \"totalIndexSize\" : 626688, \"indexSizes\" : { \"_id_\" : 217088, \"borough_1_cuisine_1\" : 139264, \"cuisine_1\" : 131072, \"borough_1_address.zipcode_1\" : 139264 }, \"ok\" : 1 } 带有过滤索引详细信息的统计信息查找 要过滤indexDetails字段中的索引，可以使用indexDetailsKey选项指定索引键，也可以使用indexDetailsName指定索引 name。要发现集合的索引键和名称，请使用db.collection.getIndexes()。 给定以下索引： { \"ns\" : \"guidebook.restaurants\", \"v\" : 1, \"key\" : { \"borough\" : 1, \"cuisine\" : 1 }, \"name\" : \"borough_1_cuisine_1\" } 以下操作将indexDetails文档过滤为indexDetailsKey文档定义的单个索引。 db.restaurants.stats( { 'indexDetails' : true, 'indexDetailsKey' : { 'borough' : 1, 'cuisine' : 1 } } ) 以下操作将indexDetails文档过滤为indexDetailsName文档定义的单个索引。 db.restaurants.stats( { 'indexDetails' : true, 'indexDetailsName' : 'borough_1_cuisine_1' } ) 两个操作都会 return 相同的输出： { \"ns\" : \"blogs.restaurants\", \"count\" : 25359, \"size\" : 10630398, \"avgObjSize\" : 419, \"storageSize\" : 4104192, \"capped\" : false, \"wiredTiger\" : { ... }, \"nindexes\" : 4, \"indexDetails\" : { \"borough_1_cuisine_1\" : { \"metadata\" : { \"formatVersion\" : 6, \"infoObj\" : \"{ \\\"v\\\" : 1, \\\"key\\\" : { \\\"borough\\\" : 1, \\\"cuisine\\\" : 1 }, \\\"name\\\" : \\\"borough_1_cuisine_1\\\", \\\"ns\\\" : \\\"blogs.posts\\\" }\" }, \"creationString\" : \"allocation_size=4KB,app_metadata=(formatVersion=6,infoObj={ \\\"v\\\" : 1, \\\"key\\\" : { \\\"borough\\\" : 1, \\\"cuisine\\\" : 1 }, \\\"name\\\" : \\\"borough_1_cuisine_1\\\", \\\"ns\\\" : \\\"blogs.posts\\\" }),block_allocation=best,block_compressor=,cache_resident=0,checksum=on,colgroups=,collator=,columns=,dictionary=0,encryption=(keyid=,name=),exclusive=0,extractor=,format=btree,huffman_key=,huffman_value=,immutable=0,internal_item_max=0,internal_key_max=0,internal_key_truncate=,internal_page_max=16k,key_format=u,key_gap=10,leaf_item_max=0,leaf_key_max=0,leaf_page_max=16k,leaf_value_max=0,log=(enabled=),lsm=(auto_throttle=,bloom=,bloom_bit_count=16,bloom_config=,bloom_hash_count=8,bloom_oldest=0,chunk_count_limit=0,chunk_max=5GB,chunk_size=10MB,merge_max=15,merge_min=0),memory_page_max=5MB,os_cache_dirty_max=0,os_cache_max=0,prefix_compression=true,prefix_compression_min=4,source=,split_deepen_min_child=0,split_deepen_per_child=0,split_pct=75,type=file,value_format=u\", \"type\" : \"file\", \"uri\" : \"statistics:table:index-4-7253336746667145592\", \"LSM\" : { ... }, \"block-manager\" : { ... }, \"btree\" : { ... }, \"cache\" : { ... }, \"compression\" : { ... }, \"cursor\" : { ... }, \"reconciliation\" : { ... }, \"session\" : { ... }, \"transaction\" : { ... } } }, \"totalIndexSize\" : 626688, \"indexSizes\" : { \"_id_\" : 217088, \"borough_1_cuisine_1\" : 139264, \"cuisine_1\" : 131072, \"borough_1_address.zipcode_1\" : 139264 }, \"ok\" : 1 } 有关输出的说明，请参阅输出细节。 也可以看看 $collStats Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-storageSize.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-storageSize.html","title":"db.collection.storageSize()","keywords":"","body":" db.collection.storageSize（） db.collection. storageSize () 返回： 分配给此集合以进行文档存储的总存储量。如果压缩了集合数据(即WiredTiger 的默认值)，则存储大小反映压缩大小，可能小于db.collection.dataSize()返回的 value。 在collStats(即：db.collection.stats())输出的storageSize字段周围提供 wrapper。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-totalIndexSize.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-totalIndexSize.html","title":"db.collection.totalIndexSize()","keywords":"","body":" db.collection.totalIndexSize（） db.collection. totalIndexSize () 返回： 集合的所有索引的总大小。如果索引使用前缀压缩(即WiredTiger 的默认值)，则返回的大小反映压缩大小。 此方法在collStats(即：db.collection.stats())操作的totalIndexSize输出周围提供包装。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-totalSize.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-totalSize.html","title":"db.collection.totalSize()","keywords":"","body":" db.collection.totalSize（） db.collection. totalSize () 返回： 集合中数据的总大小(以字节为单位)加上集合中每个索引的大小。如果压缩了集合数据(即WiredTiger 的默认值)，则返回的大小反映了集合数据的压缩大小。如果索引使用前缀压缩(即WiredTiger 的默认值)，则返回的大小反映索引的压缩大小。 返回的 value 是db.collection.storageSize()和db.collection.totalIndexSize()的总和(以字节为单位)。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-update.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-update.html","title":"db.collection.update()","keywords":"","body":" db.collection.update（） 在本页面 定义 语法 访问控制 行为 例子 写结果 定义 db.collection. update(查询，更新，选项) 修改集合中的现有文档。该方法可以修改现有文档的特定字段或完全替换现有文档，具体取决于更新参数。 默认情况下，update()方法更新单文档。设置多参数multi：true以更新 match 查询条件的所有文档。 语法 db.collection.update()方法具有以下形式： db.collection.update( , , { upsert: , multi: , writeConcern: , collation: , arrayFilters: [ , ... ] } ) 参数 该db.collection.update()方法采用以下参数： 参数 类型 描述 query document 更新的选择标准。提供与方法中相同的查询选择器find()。 当执行update()with 且查询不匹配任何现有文档时，如果查询使用点表示法在字段上指定条件，则MongoDB将拒绝插入新文档 。upsert: true _id update document or pipeline 要应用的修改。可以是以下之一：更新文件：仅包含更新运算符表达式更新文件：仅包含键值对: 聚合管道 （从MongoDB 4.2开始）：仅包含以下聚合阶段：a. $addFields及其别名 $setb. $project及其别名 $unsetc. $replaceRoot及其别名$replaceWith有关详细信息和示例，请参见示例。 upsert boolean 可选的。如果设置为true，则在没有文档与查询条件匹配时创建新文档。默认的 value 是false，当没有找到 match 时，它不会插入新文档。 multi boolean 可选的。如果设置为true，则更新符合query条件的多个文档。如果设置为false，则更新一个文档。默认的 value 是false。有关其他信息，请参阅多参数。 writeConcern document 可选的。表示写关注的文件。省略使用默认写入问题。w: 1 如果在事务中运行，请不要为操作明确设置写关注点。要对事务使用写关注，请参见 事务和写关注。有关使用的示例writeConcern，请参见 覆盖默认写问题。 collation document 可选的。 排序规则允许用户为字符串比较指定特定于语言的规则，例如字母大写和重音符号的规则。 有关使用的示例collation，请参见 指定排序规则。version 3.4 中的新内容。 arrayFilters array 可选的。过滤器文档数组，用于确定要在数组 字段上为更新操作修改的数组元素。 在更新文档中，使用$ []来定义标识符，仅更新那些与arrayFilters中相应的filter文档相匹配的数组元素。 注意 如果更新文档中未包含标识符，则不能具有数组过滤器文档作为标识符。 有关示例，请参阅为数组更新操作指定arrayFilters。version 3.6 中的新内容。 hint document or string 可选的。一个文档或字符串，它指定用于支持查询谓词的索引。该选项可以采用索引规范文档或索引名称字符串。如果指定的索引不存在，则操作错误。有关示例，请参见为更新操作指定提示。4.2版中的新功能。 返回： 该方法返回包含操作状态的WriteResult文档。 访问控制 在运行时authorization，用户必须具有包括以下特权的访问权限： update对指定集合的操作。 find对指定集合的操作。 insert如果操作导致更新，则对指定的集合执行操作。 内置角色readWrite提供所需的特权。 行为 分片集合 db.collection.update()要与分片集合一起使用，必须在 字段上包括完全匹配项或将目标设为单个分片（例如：通过包含分片键）。multi: false_id 当db.collection.update()执行更新操作（而不是文档替换操作）时， db.collection.update()可以针对多个分片。 也可以看看 findAndModify() 替换分片集合上的文档操作 从MongoDB 4.2开始，替换文档操作首先尝试使用查询过滤器来针对单个分片。如果该操作无法通过查询过滤器定位到单个分片，则它将尝试以替换文档定位。 在早期版本中，该操作尝试使用替换文档作为目标。 upsert在分片集合上 对于db.collection.update()包含 upsert：true且位于分片集合上的操作，您必须在中包含完整的分片键filter： 用于更新操作。 用于替换文档操作（从MongoDB 4.2开始）。 碎片键修改 从MongoDB 4.2开始，您可以更新文档的分片键值，除非分片键字段是不可变_id字段。有关更新分片键的详细信息，请参见更改文档的分片键值。 在MongoDB 4.2之前，文档的分片键字段值是不可变的。 要用于db.collection.update()更新分片键： 您必须指定。multi: false 您必须在运行mongos无论是在 事务或作为重试写。千万不能直接在碎片发布运行。 您必须在查询过滤器的完整分片键上包含相等条件。例如，如果一个集合messages 使用{ country : 1, userid : 1 }的片键，更新为一个文件的碎片关键，你必须包括country: , userid: 在查询过滤器。您可以根据需要在查询中包括其他字段。 事务 db.collection.update()可以在多文档交易中使用。 重要 在大多数情况下，与单文档写入相比，多文档事务产生的性能成本更高，并且多文档事务的可用性不应替代有效的架构设计。在许多情况下， 非规范化数据模型（嵌入式文档和数组）将继续是您的数据和用例的最佳选择。也就是说，在许多情况下，适当地对数据建模将最大程度地减少对多文档交易的需求。 有关其他事务使用方面的注意事项（例如：运行时限制和操作日志大小限制），另请参见 生产注意事项。 现有的集合和事务 在事务内部，您可以指定对现有集合的读/写操作。如果db.collection.update()导致upsert，则该集合必须已经存在。 如果该操作导致upsert，则该集合必须已经存在。 写关注和事务 如果在事务中运行，请不要为操作明确设置写关注点。要对事务使用写关注，请参见 事务和写关注。 例子 使用更新运算符表达式（$ inc，$ set） 在mongoshell中，创建一个books包含以下文档的集合。此命令首先从books集合中删除所有先前存在的文档： db.books.remove({}); db.books.insertMany([ { \"_id\" : 1, \"item\" : \"TBD\", \"stock\" : 0, \"info\" : { \"publisher\" : \"1111\", \"pages\" : 430 }, \"tags\" : [ \"technology\", \"computer\" ], \"ratings\" : [ { \"by\" : \"ijk\", \"rating\" : 4 }, { \"by\" : \"lmn\", \"rating\" : 5 } ], \"reorder\" : false }, { \"_id\" : 2, \"item\" : \"XYZ123\", \"stock\" : 15, \"info\" : { \"publisher\" : \"5555\", \"pages\" : 150 }, \"tags\" : [ ], \"ratings\" : [ { \"by\" : \"xyz\", \"rating\" : 5 } ], \"reorder\" : false } ]); 如果文档包含更新运算符修饰符（例如使用 $set修饰符的修饰符），则： 该文档必须仅 包含更新运算符表达式。 该db.collection.update()方法仅更新文档中的相应字段。 要整体更新嵌入式文档或数组，请为该字段指定替换值。 要更新嵌入式文档或数组中的特定字段，请使用点表示法 指定该字段。 您可以使用下面的Web Shell插入示例文档并执行示例更新操作： db.books.update( { _id: 1 }, { $inc: { stock: 5 }, $set: { item: \"ABC123\", \"info.publisher\": \"2222\", tags: [ \"software\" ], \"ratings.1\": { by: \"xyz\", rating: 3 } } } ) 在此操作中： 该参数指定更新哪个文档，{ _id: 1 } 在$inc操作递增stock字段， 在$set运算符替换值： item 字段， publisher info嵌入文档中的字段， tags 字段 ratings数组中的第二个元素。 更新后的文档如下： { \"_id\" : 1, \"item\" : \"ABC123\", \"stock\" : 5, \"info\" : { \"publisher\" : \"2222\", \"pages\" : 430 }, \"tags\" : [ \"software\" ], \"ratings\" : [ { \"by\" : \"ijk\", \"rating\" : 4 }, { \"by\" : \"xyz\", \"rating\" : 3 } ], \"reorder\" : false } 此操作对应于以下SQL语句： UPDATE books SET stock = stock + 5 item = \"ABC123\" publisher = 2222 pages = 430 tags = \"software\" rating_authors = \"ijk,xyz\" rating_values = \"4,3\" WHERE _id = 1 注意 如果query参数已匹配多个文档，则此操作将仅更新一个匹配的文档。要更新多个文档，必须将multi选项设置为true。 也可以看看 $set, $inc, Update运算符, 点符号 将元素添加到现有数组 在mongoshell中，创建一个books包含以下文档的集合。此命令首先从books集合中删除所有先前存在的文档： db.books.remove({}); db.books.insertMany([ { \"_id\" : 1, \"item\" : \"TBD\", \"stock\" : 0, \"info\" : { \"publisher\" : \"1111\", \"pages\" : 430 }, \"tags\" : [ \"technology\", \"computer\" ], \"ratings\" : [ { \"by\" : \"ijk\", \"rating\" : 4 }, { \"by\" : \"lmn\", \"rating\" : 5 } ], \"reorder\" : false }, { \"_id\" : 2, \"item\" : \"XYZ123\", \"stock\" : 15, \"info\" : { \"publisher\" : \"5555\", \"pages\" : 150 }, \"tags\" : [ ], \"ratings\" : [ { \"by\" : \"xyz\", \"rating\" : 5 } ], \"reorder\" : false } ]); 以下操作使用$pushupdate运算符将新对象附加到ratings数组。 您可以使用下面的Web Shell插入示例文档并执行示例更新操作： db.books.update( { _id: 2 }, { $push: { ratings: { \"by\" : \"jkl\", \"rating\" : 2 } } } ) 更新后的文档如下： { \"_id\" : 2, \"item\" : \"XYZ123\", \"stock\" : 15, \"info\" : { \"publisher\" : \"5555\", \"pages\" : 150 }, \"tags\" : [ ], \"ratings\" : [ { \"by\" : \"xyz\", \"rating\" : 5 }, { \"by\" : \"jkl\", \"rating\" : 2 } ], \"reorder\" : false } 也可以看看 $push 删除字段（$ unset） 在mongoshell中，创建一个books包含以下文档的集合。此命令首先从books集合中删除所有先前存在的文档： db.books.remove({}); db.books.insertMany([ { \"_id\" : 1, \"item\" : \"TBD\", \"stock\" : 0, \"info\" : { \"publisher\" : \"1111\", \"pages\" : 430 }, \"tags\" : [ \"technology\", \"computer\" ], \"ratings\" : [ { \"by\" : \"ijk\", \"rating\" : 4 }, { \"by\" : \"lmn\", \"rating\" : 5 } ], \"reorder\" : false }, { \"_id\" : 2, \"item\" : \"XYZ123\", \"stock\" : 15, \"info\" : { \"publisher\" : \"5555\", \"pages\" : 150 }, \"tags\" : [ ], \"ratings\" : [ { \"by\" : \"xyz\", \"rating\" : 5 } ], \"reorder\" : false } ]); 以下操作使用$unset操作符通过删除tags文档中的字段。{ _id: 1 } 您可以使用下面的Web Shell插入示例文档并执行示例更新操作： db.books.update( { _id: 1 }, { $unset: { tags: 1 } } ) 更新后的文档如下： { \"_id\" : 1, \"item\" : \"TBD\", \"stock\" : 0, \"info\" : { \"publisher\" : \"1111\", \"pages\" : 430 }, \"ratings\" : [ { \"by\" : \"ijk\", \"rating\" : 4 }, { \"by\" : \"lmn\", \"rating\" : 5 } ], \"reorder\" : false } 没有直接等效于$unset的SQL ，但是$unset类似于以下SQL命令，该命令tags从books 表中删除了该字段： ALTER TABLE books DROP COLUMN tags 也可以看看 $unset，$rename，update运算符 替换整个文件 在mongoshell中，创建一个books包含以下文档的集合。此命令首先从books集合中删除所有先前存在的文档： db.books.remove({}); db.books.insertMany([ { \"_id\" : 1, \"item\" : \"TBD\", \"stock\" : 0, \"info\" : { \"publisher\" : \"1111\", \"pages\" : 430 }, \"tags\" : [ \"technology\", \"computer\" ], \"ratings\" : [ { \"by\" : \"ijk\", \"rating\" : 4 }, { \"by\" : \"lmn\", \"rating\" : 5 } ], \"reorder\" : false }, { \"_id\" : 2, \"item\" : \"XYZ123\", \"stock\" : 15, \"info\" : { \"publisher\" : \"5555\", \"pages\" : 150 }, \"tags\" : [ ], \"ratings\" : [ { \"by\" : \"xyz\", \"rating\" : 5 } ], \"reorder\" : false } ]); 如果文档仅 包含field:value 表达式，则： 该db.collection.update()方法将匹配的文档替换为文档。该 db.collection.update()方法不会替换该 _id值。 db.collection.update()无法更新多个文档。 以下操作将传递仅包含字段和值对的文档。该文档将完全替换原始文档（_id字段除外）。 您可以使用下面的Web Shell插入示例文档并执行示例更新操作： db.books.update( { _id: 2 }, { item: \"XYZ123\", stock: 10, info: { publisher: \"2255\", pages: 150 }, tags: [ \"baking\", \"cooking\" ] } ) 更新的文档仅包含替换文档中的_id字段和该字段。这样，这些字段 ratings和reorder不再存在于更新的文档中，因为这些字段不在替换文档中。 { \"_id\" : 2, \"item\" : \"XYZ123\", \"stock\" : 10, \"info\" : { \"publisher\" : \"2255\", \"pages\" : 150 }, \"tags\" : [ \"baking\", \"cooking\" ] } 此操作对应于以下SQL语句： DELETE from books WHERE _id = 2 INSERT INTO books (_id, item, stock, publisher, pages, tags) VALUES (2, \"xyz123\", 10, \"2255\", 150, \"baking,cooking\") 更新多个文件 在mongoshell中，创建一个books包含以下文档的集合。此命令首先从books集合中删除所有先前存在的文档： db.books.remove({}); db.books.insertMany([ { \"_id\" : 1, \"item\" : \"TBD\", \"stock\" : 0, \"info\" : { \"publisher\" : \"1111\", \"pages\" : 430 }, \"tags\" : [ \"technology\", \"computer\" ], \"ratings\" : [ { \"by\" : \"ijk\", \"rating\" : 4 }, { \"by\" : \"lmn\", \"rating\" : 5 } ], \"reorder\" : false }, { \"_id\" : 2, \"item\" : \"XYZ123\", \"stock\" : 15, \"info\" : { \"publisher\" : \"5555\", \"pages\" : 150 }, \"tags\" : [ ], \"ratings\" : [ { \"by\" : \"xyz\", \"rating\" : 5 } ], \"reorder\" : false } ]); 如果multi设置为true，则该 db.collection.update()方法将更新所有符合条件的文档。该multi更新操作可以与其他的读/写操作交错。 以下操作将 所有小于或等于10的 文档的reorder字段设置true为。如果匹配的文档中不存在该字段，则运算符将使用指定的值添加该字段。 您可以使用下面的Web Shell插入示例文档并执行示例更新操作： db.books.update( { stock: { $lte: 10 } }, { $set: { reorder: true } }, { multi: true } ) 集合中的结果文档如下： [ { \"_id\" : 1, \"item\" : \"ABC123\", \"stock\" : 5, \"info\" : { \"publisher\" : \"2222\", \"pages\" : 430 }, \"ratings\" : [ { \"by\" : \"ijk\", \"rating\" : 4 }, { \"by\" : \"xyz\", \"rating\" : 3 } ], \"reorder\" : true } { \"_id\" : 2, \"item\" : \"XYZ123\", \"stock\" : 10, \"info\" : { \"publisher\" : \"2255\", \"pages\" : 150 }, \"tags\" : [ \"baking\", \"cooking\" ], \"reorder\" : true } ] 此操作对应于以下SQL语句： UPDATE books SET reorder=true WHERE stock 注意 您无法指定何时执行替换，即文档何时仅包含表达式：multi: true field:value 也可以看看 $set 如果不存在匹配项，则插入新文档（Upsert） 当您指定选项upsert：true时： 如果文档符合查询条件，请 db.collection.update()执行更新。 如果没有文件的查询条件匹配， db.collection.update()插入一个单一的文件。 如果在分片集合上指定upsert: true，则必须在filter 中包含完整的分片键。有关分片集合的其他 行为，请参见分片集合。 db.collection.update() 替换文件更新 如果没有文档符合查询条件，并且 参数是替换文档（即：仅包含字段和值的键值对），则更新将插入带有替换文档的字段和值的新文档。 如果您_id在查询参数或替换文档中指定字段，则MongoDB将_id在插入的文档中使用该字段。 如果您未_id在查询参数或替换文档中指定字段，则MongoDB生成的_id字段会添加带有随机生成的ObjectId值的 字段。 注意 您不能_id在查询参数和替换文档中指定其他字段值。如果这样做，则操作错误。 例如，以下更新将upsert选项设置为true： db.books.update( { item: \"ZZZ135\" }, // Query parameter { // Replacement document item: \"ZZZ135\", stock: 5, tags: [ \"database\" ] }, { upsert: true } // Options ) 如果没有文档与该参数匹配，则更新操作将插入仅包含替换文档的文档。由于_id在替换文档或查询文档中未指定任何字段，因此该操作ObjectId将为新文档的_id字段创建一个新的唯一性。您可以看到upsert反映在操作的WriteResult中： WriteResult({ \"nMatched\" : 0, \"nUpserted\" : 1, \"nModified\" : 0, \"_id\" : ObjectId(\"5da78973835b2f1c75347a83\") }) 该操作将以下文档插入books 集合中（您的ObjectId值将有所不同）： { \"_id\" : ObjectId(\"5da78973835b2f1c75347a83\"), \"item\" : \"ZZZ135\", \"stock\" : 5, \"tags\" : [ \"database\" ] } 带运算符表达式的Upsert 如果没有文档符合查询条件，并且 参数是带有update运算符expression的文档，则该操作根据参数中的equals子句创建基本文档，并应用参数中的表达式。 来自的比较操作将不会包含在新文档中。如果新文档不包含该_id字段，则MongoDB将_id使用ObjectId值添加该字段。 例如，以下更新将upsert选项设置为true： db.books.update( { item: \"BLP921\" }, // Query parameter { // Update document $set: { reorder: false }, $setOnInsert: { stock: 10 } }, { upsert: true } // Options ) 如果没有文档符合查询条件，则该操作将插入以下文档（您的ObjectId值将有所不同）： { \"_id\" : ObjectId(\"5da79019835b2f1c75348a0a\"), \"item\" : \"BLP921\", \"reorder\" : false, \"stock\" : 10 } 也可以看看 $setOnInsert 使用Upsert的聚合管道 如果参数是聚合管道，则更新将从 参数中的equals子句创建基础文档，然后将管道应用于文档以创建要插入的文档。如果新文档不包含该_id字段，则MongoDB将_id使用ObjectId值添加该字段。 例如，以下upsert：true操作指定使用以下内容的聚合管道 该$replaceRoot阶段可以提供与$setOnInsert更新运算符表达式类似的行为， $set可以提供与$set更新操作符表达式相似的行为的阶段， 聚合变量NOW，它解析为当前日期时间，并且可以提供与$currentDate更新运算符表达式类似的行为 。 db.books.update( { item: \"MRQ014\", ratings: [2, 5, 3] }, // Query parameter [ // Aggregation pipeline { $replaceRoot: { newRoot: { $mergeObjects: [ { stock: 0 }, \"$$ROOT\" ] } } }, { $set: { avgRating: { $avg: \"$ratings\" }, tags: [ \"fiction\", \"murder\" ], lastModified: \"$$NOW\" } } ], { upsert: true } // Options ) 如果没有文档与该参数匹配，则该操作会将以下文档插入到books 集合中（您的ObjectId值将有所不同）： { \"_id\" : ObjectId(\"5e2921e0b4c550aad59d1ba9\"), \"stock\" : 0, \"item\" : \"MRQ014\", \"ratings\" : [ 2, 5, 3 ], \"avgRating\" : 3.3333333333333335, \"tags\" : [ \"fiction\", \"murder\" ], \"lastModified\" : ISODate(\"2020-01-23T04:32:32.951Z\") } 也可以看看 有关使用聚合管道进行更新的其他示例，请参见使用聚合管道进行更新。 结合Upsert和多选项 结合使用Upsert和多选项（匹配） 在mongoshell中，将以下文档插入books集合中： db.books.insertMany([ { _id: 5, item: \"RQM909\", stock: 18, info: { publisher: \"0000\", pages: 170 }, reorder: true }, { _id: 6, item: \"EFG222\", stock: 15, info: { publisher: \"1111\", pages: 72 }, reorder: true } ]) 以下操作同时指定了multi选项和upsert选项。如果存在匹配的文档，则该操作将更新所有匹配的文档。如果不存在匹配的文档，则该操作将插入一个新文档。 db.books.update( { stock: { $gte: 10 } }, // Query parameter { // Update document $set: { reorder: false, tags: [ \"literature\", \"translated\" ] } }, { upsert: true, multi: true } // Options ) 该操作将更新所有匹配的文档，并产生以下结果： { \"_id\" : 5, \"item\" : \"RQM909\", \"stock\" : 18, \"info\" : { \"publisher\" : \"0000\", \"pages\" : 170 }, \"reorder\" : false, \"tags\" : [ \"literature\", \"translated\" ] } { \"_id\" : 6, \"item\" : \"EFG222\", \"stock\" : 15, \"info\" : { \"publisher\" : \"1111\", \"pages\" : 72 }, \"reorder\" : false, \"tags\" : [ \"literature\", \"translated\" ] } 结合使用Upsert和多选项（无匹配项） 如果集合中没有匹配的文档，则该操作将导致使用和 规范中的字段插入单个文档。例如，考虑以下操作： db.books.update( { \"info.publisher\": \"Self-Published\" }, // Query parameter { // Update document $set: { reorder: false, tags: [ \"literature\", \"hardcover\" ], stock: 25 } }, { upsert: true, multi: true } // Options ) 该操作将以下文档插入books 集合中（您的ObjectId值将有所不同）： { \"_id\" : ObjectId(\"5db337934f670d584b6ca8e0\"), \"info\" : { \"publisher\" : \"Self-Published\" }, \"reorder\" : false, \"stock\" : 25, \"tags\" : [ \"literature\", \"hardcover\" ] } 带Dotted_id查询的Upsert 当执行update()with 且查询不匹配任何现有文档时，如果查询使用点表示法在字段上指定条件，则MongoDB将拒绝插入新文档 。upsert: true _id 此限制可确保_id文档中嵌入的字段的顺序 定义明确，并且不与查询中指定的顺序绑定。 如果您尝试以这种方式插入文档，MongoDB将引发错误。例如，考虑以下更新操作。由于更新操作指定upsert:true了_id字段并且查询使用点符号指定了字段上的条件，因此在构建要插入的文档时，更新将导致错误。 db.collection.update( { \"_id.name\": \"Robert Frost\", \"_id.uid\": 0 }, { \"categories\": [\"poet\", \"playwright\"] }, { upsert: true } ) 该WriteResult操作将返回以下错误： WriteResult({ \"nMatched\" : 0, \"nUpserted\" : 0, \"nModified\" : 0, \"writeError\" : { \"code\" : 111, \"errmsg\" : \"field at '_id' must be exactly specified, field at sub-path '_id.name'found\" } }) 也可以看看 WriteResult() 使用唯一索引 警告 为避免多次插入同一文档，请仅在query字段是唯一索引时使用upsert: true 。 给定一个名为集合people，其中没有包含Andy值的name字段，考虑当多个客户端在同一时间使用upsert: true发出以下db.collection.update()时： db.people.update( { name: \"Andy\" }, // Query parameter { // Update document name: \"Andy\", rating: 1, score: 1 }, { upsert: true } // Options ) 如果所有db.collection.update()操作query在任何客户端成功插入数据之前完成了该 部分，并且 该name字段上没有唯一索引，则每个更新操作都可能导致插入。 为防止MongoDB多次插入同一文档，请在字段上创建唯一索引name。使用唯一索引，如果多个应用程序使用upsert: true发出相同的更新，则恰好一个db.collection.update()将成功插入新文档。 其余操作将是： 更新新插入的文档， 当他们尝试插入重复项时失败。 如果操作由于重复的索引键错误而失败，则应用程序可以重试该操作，该操作将作为更新操作成功。 也可以看看 $setOnInsert 使用聚合管道更新 从MongoDB 4.2开始，db.collection.update()方法可以接受指定要执行的修改的聚合管道。管道可以包括以下阶段：[ , , ... ] $addFields及其别名 $set $project及其别名 $unset $replaceRoot及其别名$replaceWith。 使用聚合管道可以实现更具表达力的更新语句，例如根据当前字段值表达条件更新，或使用另一个字段的值更新一个字段。 使用文档中其他字段的值修改字段 members使用以下文档创建一个集合： db.members.insertMany([ { \"_id\" : 1, \"member\" : \"abc123\", \"status\" : \"A\", \"points\" : 2, \"misc1\" : \"note to self: confirm status\", \"misc2\" : \"Need to activate\", \"lastUpdate\" : ISODate(\"2019-01-01T00:00:00Z\") }, { \"_id\" : 2, \"member\" : \"xyz123\", \"status\" : \"A\", \"points\" : 60, \"misc1\" : \"reminder: ping me at 100pts\", \"misc2\" : \"Some random comment\", \"lastUpdate\" : ISODate(\"2019-01-01T00:00:00Z\") } ]) 假设您希望将这些字段收集到一个新字段中，而不是使用单独的misc1和misc2字段comments。以下更新操作使用聚合管道执行以下操作： 添加新comments字段并设置该lastUpdate字段。 删除集合中所有文档的misc1和misc2字段。 db.members.update( { }, [ { $set: { status: \"Modified\", comments: [ \"$misc1\", \"$misc2\" ], lastUpdate: \"$$NOW\" } }, { $unset: [ \"misc1\", \"misc2\" ] } ], { multi: true } ) 注意 该$set和$unset在管道中是指聚合阶段$set，并$unset 分别，而不是更新的运营商$set和 $unset。 第一阶段 该$set阶段： 创建一个新的数组字段，comments其元素是misc1和misc2字段的当前内容， 并且将字段设置为lastUpdate聚合变量的值NOW。聚合变量 NOW解析为当前日期时间值，并且在整个管道中保持不变。要访问聚合变量，请在变量前加双美元符号$$ 并用引号引起来。 第二阶段 $unset阶段将删除misc1和misc2字段。 命令后，集合包含以下文档： { \"_id\" : 1, \"member\" : \"abc123\", \"status\" : \"Modified\", \"points\" : 2, \"lastUpdate\" : ISODate(\"2020-01-23T05:11:45.784Z\"), \"comments\" : [ \"note to self: confirm status\", \"Need to activate\" ] } { \"_id\" : 2, \"member\" : \"xyz123\", \"status\" : \"Modified\", \"points\" : 60, \"lastUpdate\" : ISODate(\"2020-01-23T05:11:45.784Z\"), \"comments\" : [ \"reminder: ping me at 100pts\", \"Some random comment\" ] } 也可以看看 Updates with Aggregation Pipeline 根据当前字段值执行条件更新 使用以下文档创建一个students3集合： db.students3.insert([ { \"_id\" : 1, \"tests\" : [ 95, 92, 90 ], \"lastUpdate\" : ISODate(\"2019-01-01T00:00:00Z\") }, { \"_id\" : 2, \"tests\" : [ 94, 88, 90 ], \"lastUpdate\" : ISODate(\"2019-01-01T00:00:00Z\") }, { \"_id\" : 3, \"tests\" : [ 70, 75, 82 ], \"lastUpdate\" : ISODate(\"2019-01-01T00:00:00Z\") } ]); 使用聚合管道，可以使用计算出的平均成绩和字母成绩更新文档。 db.students3.update( { }, [ { $set: { average : { $trunc: [ { $avg: \"$tests\" }, 0 ] }, lastUpdate: \"$$NOW\" } }, { $set: { grade: { $switch: { branches: [ { case: { $gte: [ \"$average\", 90 ] }, then: \"A\" }, { case: { $gte: [ \"$average\", 80 ] }, then: \"B\" }, { case: { $gte: [ \"$average\", 70 ] }, then: \"C\" }, { case: { $gte: [ \"$average\", 60 ] }, then: \"D\" } ], default: \"F\" } } } } ], { multi: true } ) 注意 $set管道中的使用是指聚合阶段 $set，而不是更新运算符$set。 第一阶段 $set阶段： 根据字段average的平均值 计算一个新tests字段。请参阅$avg有关 $avg聚合运算符$trunc的更多信息和有关$trunc截取聚合运算符的更多信息 。 将字段设置为lastUpdate聚合变量的值NOW。聚合变量 NOW解析为当前日期时间值，并且在整个管道中保持不变。要访问聚合变量，请在变量前加双美元符号$$ 并用引号引起来。 第二阶段 $set阶段根据前一阶段计算的平均成绩计算新的成绩等级。参见 $switch以获取有关$switch 聚合运算符的更多信息。 命令后，集合包含以下文档： { \"_id\" : 1, \"tests\" : [ 95, 92, 90 ], \"lastUpdate\" : ISODate(\"2020-01-24T17:29:35.340Z\"), \"average\" : 92, \"grade\" : \"A\" } { \"_id\" : 2, \"tests\" : [ 94, 88, 90 ], \"lastUpdate\" : ISODate(\"2020-01-24T17:29:35.340Z\"), \"average\" : 90, \"grade\" : \"A\" } { \"_id\" : 3, \"tests\" : [ 70, 75, 82 ], \"lastUpdate\" : ISODate(\"2020-01-24T17:29:35.340Z\"), \"average\" : 75, \"grade\" : \"C\" } 也可以看看 Updates with Aggregation Pipeline 指定arrayFilters数组更新操作 在更新文档中，使用$[]过滤后的位置运算符定义一个标识符，然后在数组过滤器文档中引用该标识符。如果更新文档中未包含标识符，则不能具有数组过滤器文档作为标识符。 注意 在必须以小写字母开头，并且只包含字母数字字符。 您可以在更新文档中多次包含相同的标识符；但是，对于$[identifier]更新文档中的每个不同的标识符，必须精确地指定一个 对应的数组过滤器文档。即：您不能为同一标识符指定多个数组过滤器文档。例如：如果update语句包含标识符x （可能多次），则不能为以下内容指定以下内容 arrayFilters：包括2个单独的过滤器文档x： // INVALID [ { \"x.a\": { $gt: 85 } }, { \"x.b\": { $gt: 80 } } ] 但是，可以在单个过滤器文档中的相同标识符上指定复合条件，例如以下示例： // Example 1 [ { $or: [{\"x.a\": {$gt: 85}}, {\"x.b\": {$gt: 80}}] } ] // Example 2 [ { $and: [{\"x.a\": {$gt: 85}}, {\"x.b\": {$gt: 80}}] } ] // Example 3 [ { \"x.a\": { $gt: 85 }, \"x.b\": { $gt: 80 } } ] arrayFilters 不适用于使用聚合管道的更新。 更新元素匹配arrayFilters条件 要更新所有符合指定条件的数组元素，请使用 arrayFilters参数。 在mongoshell程序中，students 使用以下文档创建一个集合： db.students.insertMany([ { \"_id\" : 1, \"grades\" : [ 95, 92, 90 ] }, { \"_id\" : 2, \"grades\" : [ 98, 100, 102 ] }, { \"_id\" : 3, \"grades\" : [ 95, 110, 100 ] } ]) 要更新grades阵列中大于或等于100的所有元素 ，使用过滤的位置操作符 $[]与所述arrayFilters选项： db.students.update( { grades: { $gte: 100 } }, { $set: { \"grades.$[element]\" : 100 } }, { multi: true, arrayFilters: [ { \"element\": { $gte: 100 } } ] } ) 操作后，集合包含以下文档： { \"_id\" : 1, \"grades\" : [ 95, 92, 90 ] } { \"_id\" : 2, \"grades\" : [ 98, 100, 100 ] } { \"_id\" : 3, \"grades\" : [ 95, 100, 100 ] } 更新文档数组的特定元素 您还可以使用arrayFilters参数更新文档数组中的特定文档字段。 在mongoshell程序中，students2 使用以下文档创建一个集合： db.students2.insertMany([ { \"_id\" : 1, \"grades\" : [ { \"grade\" : 80, \"mean\" : 75, \"std\" : 6 }, { \"grade\" : 85, \"mean\" : 90, \"std\" : 4 }, { \"grade\" : 85, \"mean\" : 85, \"std\" : 6 } ] } { \"_id\" : 2, \"grades\" : [ { \"grade\" : 90, \"mean\" : 75, \"std\" : 6 }, { \"grade\" : 87, \"mean\" : 90, \"std\" : 3 }, { \"grade\" : 85, \"mean\" : 85, \"std\" : 4 } ] } ]) 要修改mean的grades数组中grade大于或等于85的所有元素的字段 值，请使用$[]带有过滤条件的位置运算符和arrayFilters： db.students2.update( { }, { $set: { \"grades.$[elem].mean\" : 100 } }, { multi: true, arrayFilters: [ { \"elem.grade\": { $gte: 85 } } ] } ) 操作后，集合具有以下文档： { \"_id\" : 1, \"grades\" : [ { \"grade\" : 80, \"mean\" : 75, \"std\" : 6 }, { \"grade\" : 85, \"mean\" : 100, \"std\" : 4 }, { \"grade\" : 85, \"mean\" : 100, \"std\" : 6 } ] } { \"_id\" : 2, \"grades\" : [ { \"grade\" : 90, \"mean\" : 100, \"std\" : 6 }, { \"grade\" : 87, \"mean\" : 100, \"std\" : 3 }, { \"grade\" : 85, \"mean\" : 100, \"std\" : 4 } ] } 指定hint更新操作 4.2版中的新功能。 mongoshell程序中，members 使用以下文档创建一个集合： db.members.insertMany([ { \"_id\" : 1, \"member\" : \"abc123\", \"status\" : \"P\", \"points\" : 0, \"misc1\" : null, \"misc2\" : null }, { \"_id\" : 2, \"member\" : \"xyz123\", \"status\" : \"A\", \"points\" : 60, \"misc1\" : \"reminder: ping me at 100pts\", \"misc2\" : \"Some random comment\" }, { \"_id\" : 3, \"member\" : \"lmn123\", \"status\" : \"P\", \"points\" : 0, \"misc1\" : null, \"misc2\" : null }, { \"_id\" : 4, \"member\" : \"pqr123\", \"status\" : \"D\", \"points\" : 20, \"misc1\" : \"Deactivated\", \"misc2\" : null }, { \"_id\" : 5, \"member\" : \"ijk123\", \"status\" : \"P\", \"points\" : 0, \"misc1\" : null, \"misc2\" : null }, { \"_id\" : 6, \"member\" : \"cde123\", \"status\" : \"A\", \"points\" : 86, \"misc1\" : \"reminder: ping me at 100pts\", \"misc2\" : \"Some random comment\" } ]) 在集合上创建以下索引： db.members.createIndex( { status: 1 } ) db.members.createIndex( { points: 1 } ) 以下更新操作hints明确指出要使用索引：{status: 1 } 注意 如果指定的索引不存在，则操作错误。 db.members.update( { points: { $lte: 20 }, status: \"P\" }, // Query parameter { $set: { misc1: \"Need to activate\" } }, // Update document { multi: true, hint: { status: 1 } } // Options ) update命令返回以下内容： WriteResult({ \"nMatched\" : 3, \"nUpserted\" : 0, \"nModified\" : 3 }) 要查看使用的索引，请运行explain以下操作： db.members.explain().update( { \"points\": { $lte: 20 }, \"status\": \"P\" }, { $set: { \"misc1\": \"Need to activate\" } }, { multi: true, hint: { status: 1 } } ) db.collection.explain().update()不修改文件。 覆盖默认写问题 对副本集的以下操作指定5,000毫秒的写关注时间\"w: majority\"，以 使该方法在写传送到大多数有表决权的副本集成员之后返回，或者该方法在5秒钟后超时。 db.books.update( { stock: { $lte: 10 } }, { $set: { reorder: true } }, { multi: true, writeConcern: { w: \"majority\", wtimeout: 5000 } } ) 指定排序规则 指定 用于操作的排序规则。 排序规则允许用户为字符串比较指定特定于语言的规则，例如字母大写和重音符号的规则。 排序规则选项具有以下语法： collation: { locale: , caseLevel: , caseFirst: , strength: , numericOrdering: , alternate: , maxVariable: , backwards: } 指定排序规则时，该locale字段为必填字段；所有其他排序规则字段都是可选的。有关字段的说明，请参见整理文档。 如果未指定排序规则，但是集合具有默认排序规则（请参阅参考资料db.createCollection()），则该操作将使用为集合指定的排序规则。 如果没有为集合或操作指定排序规则，则MongoDB会将以前版本中使用的简单二进制比较用于字符串比较。 您不能为一个操作指定多个排序规则。例如，您不能为每个字段指定不同的排序规则，或者如果对排序执行查找，则不能对查找使用一种排序规则，而对排序使用另一种排序规则。 3.4版的新功能。 在mongoshell程序中，创建一个myColl包含以下文档的集合 ： db.myColl.insertMany( [ { _id: 1, category: \"café\", status: \"A\" }, { _id: 2, category: \"cafe\", status: \"a\" }, { _id: 3, category: \"cafE\", status: \"a\" } ]) 下面的操作包括排序选项和设置multi，以true更新所有匹配的文档： db.myColl.update( { category: \"cafe\" }, { $set: { status: \"Updated\" } }, { collation: { locale: \"fr\", strength: 1 }, multi: true } ); 该操作的写入结果返回以下文档，指示集合中的所有三个文档均已更新： WriteResult({ \"nMatched\" : 3, \"nUpserted\" : 0, \"nModified\" : 3 }) 操作后，集合包含以下文档： { \"_id\" : 1, \"category\" : \"café\", \"status\" : \"Updated\" } { \"_id\" : 2, \"category\" : \"cafe\", \"status\" : \"Updated\" } { \"_id\" : 3, \"category\" : \"cafE\", \"status\" : \"Updated\" } 写结果 成功的结果 db.collection.update()方法返回一个 WriteResult包含操作状态的对象。成功后，WriteResult对象包含符合查询条件的文档数，更新插入的文档数以及修改的文档数： WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) 注意 WriteResult.nMatched，WriteResult.nUpserted，WriteResult.nModified 写关注错误 如果该db.collection.update()方法遇到写关注错误，则结果包括以下 WriteResult.writeConcernError字段： WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1, \"writeConcernError\" : { \"code\" : 64, \"errmsg\" : \"waiting for replication timed out at shard-a\" } }) 也可以看看 WriteResult.hasWriteConcernError() 与写关注无关的错误 如果db.collection.update()方法遇到非写关注错误，则结果包括以下WriteResult.writeError字段： WriteResult({ \"nMatched\" : 0, \"nUpserted\" : 0, \"nModified\" : 0, \"writeError\" : { \"code\" : 7, \"errmsg\" : \"could not contact primary for replica set shard-a\" } }) 也可以看看 WriteResult.hasWriteError() Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-updateOne.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-updateOne.html","title":"db.collection.updateOne()","keywords":"","body":" db.collection.updateOne（） 在本页面 定义 语法 访问控制 行为 例子 定义 db.collection. updateOne(过滤，更新，选项) version 3.2 中的新内容。 根据过滤器更新集合中的单个文档。 语法 updateOne()方法具有以下形式： db.collection.updateOne( , , { upsert: , writeConcern: , collation: , arrayFilters: [ , ... ] } ) 参数 db.collection.updateOne()方法采用以下参数： 参数 类型 描述 filter document 更新的选择标准。可以使用与find()方法相同的query selectors。 指定一个空文档{ }以更新集合中的所有文档。 update document 要应用的修改。可以是以下之一： 1. 更新文件：仅包含更新运算符表达式。有关更多信息，请参见 使用更新运算符表达式文档进行更新。2. 聚合管道（从MongoDB 4.2开始）：仅包含以下聚合阶段：a. $addFields及其别名 $setb. $project及其别名 $unsetc. replaceRoot及其别名$replaceWith。有关更多信息，请参见 使用聚合管道更新。要使用替换文档进行更新，请参阅 db.collection.replaceOne()。 upsert boolean 可选的。当true，updateOne()时：1. 如果没有文档匹配filter，则创建一个新文档。有关详细信息，请参阅upsert 行为。 2. 更新匹配filter的文档。 要避免多次 upsert，请确保filter字段为唯一索引。 默认为false。 writeConcern document 可选的。表示写关注的文件。省略使用默认写入问题。如果在事务中运行，请不要为操作明确设置写关注点。要对事务使用写关注，请参见 事务和写关注。 collation document 可选的。 指定要用于操作的排序规则。 排序规则允许用户为字符串比较指定特定于语言的规则，例如字母大写和重音符号的规则。排序规则选项具有以下语法：collation：{ locale：， caseLevel：， caseFirst：， strength：， numericOrdering：， alternate：， maxVariable：， backwards ： } 指定排序规则时，locale字段是必填字段;所有其他排序规则字段都是可选的。有关字段的说明，请参阅整理文件。 如果未指定排序规则但集合具有默认排序规则(请参阅db.createCollection())，则操作将使用为集合指定的排序规则。 如果没有为集合或操作指定排序规则，则MongoDB会将以前版本中使用的简单二进制比较用于字符串比较。 您不能为一个操作指定多个排序规则。例如，您不能为每个字段指定不同的排序规则，或者如果对排序执行查找，则不能对查找使用一种排序规则，而对排序使用另一种排序规则。 3.4版的新功能。 arrayFilters array 可选的。过滤器文档的 array，用于确定要在 array 字段上为更新操作修改哪些 array 元素。 在更新文档中，使用$[]过滤后的位置运算符定义一个标识符，然后在数组过滤器文档中引用该标识符。如果更新文档中未包含标识符，则不能具有数组过滤器文档作为标识符。 注意必须以小写字母开头，并且只包含字母数字字符。 您可以在更新文档中多次包含相同的标识符;但是，对于更新文档中的每个不同标识符($[identifier])，您必须指定恰好一个对应的 array 过滤器文档。也就是说，您不能为同一标识符指定多个 array 过滤器文档。对于 example，如果 update 语句包含标识符x(可能多次)，则不能为arrayFilters指定以下内容，其中包含 2 个单独的x过滤器文档：[ { \"x.a\": { $gt: 85 } }, { \"x.b\": { $gt: 80 } } ]但是，您可以在同一标识符上指定复合条件单个过滤器文档，例如以下示例：[ {$or：[{\"x.a\": {$gt: 85}}, {\"x.b\": {$gt: 80}}]} ] [ {$and：[{\"x.a\": {$gt: 85}}, {\"x.b\": {$gt: 80}}]} ] [ { \"x.a\": { $gt: 85 }, \"x.b\": { $gt: 80 } }] 有关示例，请参阅为数组更新操作指定arrayFilters。 version 3.6 中的新内容。 hint Document or string 可选的。一个文档或字符串，它指定用于支持查询谓词的索引。该选项可以采用索引规范文档或索引名称字符串。如果指定的索引不存在，则操作错误。有关示例，请参见为更新操作指定提示。4.2.1版中的新功能。 返回： 包含以下内容的文档：一个布尔值acknowledged，就好像该操作在运行时带有 写关注关系true或是否禁用了写关注关系false matchedCount包含匹配文档数 modifiedCount包含已修改文档数 upsertedId包含_id 要提交的文档 访问控制 在运行authorization时，用户必须具有包括以下特权的访问权限： update 对指定集合的操作。 find对指定集合的操作。 insert如果操作导致更新，则对指定的集合执行操作。 内置角色readWrite提供所需的特权。 行为 更新单个文件 db.collection.updateOne()查找与过滤器匹配的第一个文档，并应用指定的 更新修改。 使用更新运算符表达式文档进行更新 对于更新规范，db.collection.updateOne()方法可以接受仅包含更新运算符表达式的文档。 例如： db.collection.updateOne( , { $set: { status: \"D\" }, $inc: { quantity: 2 } }, ... ) 使用聚合管道进行更新 从MongoDB 4.2开始，db.collection.updateOne()方法可以接受指定要执行的修改的聚合管道 。管道可以包括以下阶段：[ , , ... ] $addFields及其别名 $set $project及其别名 $unset $replaceRoot及其别名$replaceWith。 使用聚合管道可以实现更具表达力的更新语句，例如根据当前字段值表达条件更新，或使用另一个字段的值更新一个字段。 例如： db.collection.updateOne( , [ { $set: { status: \"Modified\", comments: [ \"$misc1\", \"$misc2\" ] } }, { $unset: [ \"misc1\", \"misc2\" ] } ] ... ) 注意 该$set和$unset在管道中是指聚集阶段$set，并$unset分别，而不是更新的运算符$set和$unset。 有关示例，请参见使用聚合管道更新。 UPSERT 如果upsert: true和filter没有文档匹配，则 db.collection.updateOne()根据条件filter和update修改创建一个新文档。请参阅 使用Upsert更新。 如果在分片集合上指定upsert: true，则必须在filter中包括完整的分片键。有关分片集合db.collection.updateOne()的其他行为，请参见分片集合。 固定集合 如果更新操作更改了文档大小，则该操作将失败。 分片集合 要db.collection.updateOne()在分片集合上使用： 如果未指定upsert: true，则必须在字段_id上包含完全匹配项或将目标指定为单个分片（例如，通过在过滤器中包含分片键）。 如果指定upsert: true，则过滤器 必须包含分片键。 碎片键修改 从MongoDB 4.2开始，您可以更新文档的分片键值，除非分片键字段是不可变_id字段。有关更新分片键的详细信息，请参见更改文档的分片键值。 在MongoDB 4.2之前，文档的分片键字段值是不可变的。 要用于db.collection.updateOne()更新分片键： 您必须在运行mongos无论是在事务或作为重试写。千万不能直接在碎片颁发运行。 您必须在查询过滤器的完整分片键上包含相等条件。例如，如果一个集合messages 使用{ country : 1, userid : 1 }的片键，更新为一个文件的碎片关键，你必须包括在country: , userid: 查询过滤器。您可以根据需要在查询中包括其他字段。 可解释性 updateOne()与不兼容 db.collection.explain()。 使用update()代替。 事务 db.collection.updateOne()可以在多文档事务中使用。 重要 在大多数情况下，与单文档写入相比，多文档事务产生的性能成本更高，并且多文档事务的可用性不应替代有效的架构设计。在许多情况下， 非规范化数据模型（嵌入式文档和数组）将继续是您的数据和用例的最佳选择。也就是说，在许多情况下，适当地对数据建模将最大程度地减少对多文档交易的需求。 有关其他事务使用方面的注意事项（例如运行时限制和操作日志大小限制），另请参见 生产注意事项。 现有的集合和事务 在事务内部，您可以指定对现有集合的读/写操作。如果db.collection.updateOne()导致upsert，则该集合必须已经存在。 写关注和事务 如果在事务中运行，请不要为操作明确设置写关注点。要对事务使用写关注，请参见 事务和写关注。 例子 更新 restaurant集合包含以下文档： { \"_id\" : 1, \"name\" : \"Central Perk Cafe\", \"Borough\" : \"Manhattan\" }, { \"_id\" : 2, \"name\" : \"Rock A Feller Bar and Grill\", \"Borough\" : \"Queens\", \"violations\" : 2 }, { \"_id\" : 3, \"name\" : \"Empire State Pub\", \"Borough\" : \"Brooklyn\", \"violations\" : 0 } 以下操作使用violations字段更新name: \"Central Perk Cafe\"的单个文档： try { db.restaurant.updateOne( { \"name\" : \"Central Perk Cafe\" }, { $set: { \"violations\" : 3 } } ); } catch (e) { print(e); } 操作返回： { \"acknowledged\" : true, \"matchedCount\" : 1, \"modifiedCount\" : 1 } 如果未找到匹配项，则操作将返回： { \"acknowledged\" : true, \"matchedCount\" : 0, \"modifiedCount\" : 0 } 如果未找到 match，则设置upsert: true将插入文档。见使用 Upsert 更新 使用聚合管道更新 从MongoDB 4.2开始，db.collection.updateOne()可以使用聚合管道进行更新。管道可以包括以下阶段： $addFields及其别名 $set $project及其别名 $unset $replaceRoot及其别名$replaceWith。 使用聚合管道可以实现更具表达力的更新语句，例如根据当前字段值表达条件更新，或使用另一个字段的值更新一个字段。 实施例1 以下示例使用聚合管道文档中其他字段的值来修改字段。 members使用以下文档创建一个集合： db.members.insertMany([ { \"_id\" : 1, \"member\" : \"abc123\", \"status\" : \"A\", \"points\" : 2, \"misc1\" : \"note to self: confirm status\", \"misc2\" : \"Need to activate\", \"lastUpdate\" : ISODate(\"2019-01-01T00:00:00Z\") }, { \"_id\" : 2, \"member\" : \"xyz123\", \"status\" : \"A\", \"points\" : 60, comments: [ \"reminder: ping me at 100pts\", \"Some random comment\" ], \"lastUpdate\" : ISODate(\"2019-01-01T00:00:00Z\") } ]) 假设您希望将这些字段收集到一个新字段中，而不是使用单独的misc1和misc2字段comments。以下更新操作使用聚合管道执行以下操作： 添加新comments字段并设置该lastUpdate字段。 删除集合中所有文档的misc1和misc2字段。 db.members.updateOne( { _id: 1 }, [ { $set: { status: \"Modified\", comments: [ \"$misc1\", \"$misc2\" ], lastUpdate: \"$$NOW\" } }, { $unset: [ \"misc1\", \"misc2\" ] } ] ) 注意 该$set和$unset在管道中是指聚合阶段$set，并$unset分别，而不是更新的运营商$set和$unset。 第一阶段 $set阶段： 创建一个新的数组字段，comments其元素是misc1和misc2字段的当前内容 将字段设置为lastUpdate聚合变量的值NOW。聚合变量 NOW解析为当前日期时间值，并且在整个管道中保持不变。要访问聚合变量，请在变量前加双美元符号$$ 并用引号引起来。 第二阶段 该$unset阶段将删除misc1和misc2字段。 命令后，集合包含以下文档： { \"_id\" : 1, \"member\" : \"abc123\", \"status\" : \"Modified\", \"points\" : 2, \"lastUpdate\" : ISODate(\"2020-01-23T05:21:59.321Z\"), \"comments\" : [ \"note to self: confirm status\", \"Need to activate\" ] } { \"_id\" : 2, \"member\" : \"xyz123\", \"status\" : \"A\", \"points\" : 60, \"comments\" : [ \"reminder: ping me at 100pts\", \"Some random comment\" ], \"lastUpdate\" : ISODate(\"2019-01-01T00:00:00Z\") } 示例 聚合管道允许基于当前字段值执行条件更新，以及使用当前字段值来计算单独的字段值。 例如，students3使用以下文档创建一个集合： db.students3.insert([ { \"_id\" : 1, \"tests\" : [ 95, 92, 90 ], \"average\" : 92, \"grade\" : \"A\", \"lastUpdate\" : ISODate(\"2020-01-23T05:18:40.013Z\") }, { \"_id\" : 2, \"tests\" : [ 94, 88, 90 ], \"average\" : 91, \"grade\" : \"A\", \"lastUpdate\" : ISODate(\"2020-01-23T05:18:40.013Z\") }, { \"_id\" : 3, \"tests\" : [ 70, 75, 82 ], \"lastUpdate\" : ISODate(\"2019-01-01T00:00:00Z\") } ]); 第三个文档_id: 3缺少average和 grade 字段。使用聚合管道，可以使用计算出的平均成绩和字母成绩更新文档。 db.students3.updateOne( { _id: 3 }, [ { $set: { average: { $trunc: [ { $avg: \"$tests\" }, 0 ] }, lastUpdate: \"$$NOW\" } }, { $set: { grade: { $switch: { branches: [ { case: { $gte: [ \"$average\", 90 ] }, then: \"A\" }, { case: { $gte: [ \"$average\", 80 ] }, then: \"B\" }, { case: { $gte: [ \"$average\", 70 ] }, then: \"C\" }, { case: { $gte: [ \"$average\", 60 ] }, then: \"D\" } ], default: \"F\" } } } } ] ) 注意 该$set管道中的使用是指聚合阶段 $set，而不是更新运算符$set。 第一阶段 $set阶段： 根据字段average的平均值 计算一个新tests字段。请参阅$avg有关 $avg聚合运算符$trunc的更多信息和有关$trunc截断聚合运算符的更多信息。 将字段设置为lastUpdate聚合变量的值NOW。聚合变量 NOW解析为当前日期时间值，并且在整个管道中保持不变。要访问聚合变量，请在变量前加双美元符号$$ 并用引号引起来。 第二阶段 $set阶段计算新字段grade基础上，average在前一阶段计算。参见 $switch以获取有关$switch 聚合运算符的更多信息。 命令后，集合包含以下文档： { \"_id\" : 1, \"tests\" : [ 95, 92, 90 ], \"average\" : 92, \"grade\" : \"A\", \"lastUpdate\" : ISODate(\"2020-01-23T05:18:40.013Z\") } { \"_id\" : 2, \"tests\" : [ 94, 88, 90 ], \"average\" : 91, \"grade\" : \"A\", \"lastUpdate\" : ISODate(\"2020-01-23T05:18:40.013Z\") } { \"_id\" : 3, \"tests\" : [ 70, 75, 82 ], \"lastUpdate\" : ISODate(\"2020-01-24T17:33:30.674Z\"), \"average\" : 75, \"grade\" : \"C\" } 也可以看看 聚合管道更新 使用 Upsert 更新 restaurant集合包含以下文档： { \"_id\" : 1, \"name\" : \"Central Perk Cafe\", \"Borough\" : \"Manhattan\", \"violations\" : 3 }, { \"_id\" : 2, \"name\" : \"Rock A Feller Bar and Grill\", \"Borough\" : \"Queens\", \"violations\" : 2 }, { \"_id\" : 3, \"name\" : \"Empire State Pub\", \"Borough\" : \"Brooklyn\", \"violations\" : \"0\" } 以下操作尝试使用name : \"Pizza Rat's Pizzaria\"更新文档，而upsert: true： try { db.restaurant.updateOne( { \"name\" : \"Pizza Rat's Pizzaria\" }, { $set: {\"_id\" : 4, \"violations\" : 7, \"borough\" : \"Manhattan\" } }, { upsert: true } ); } catch (e) { print(e); } 从upsert:true开始，文档基于filter和update标准inserted。操作返回： { \"acknowledged\" : true, \"matchedCount\" : 0, \"modifiedCount\" : 0, \"upsertedId\" : 4 } 该集合现在包含以下文档： { \"_id\" : 1, \"name\" : \"Central Perk Cafe\", \"Borough\" : \"Manhattan\", \"violations\" : 3 }, { \"_id\" : 2, \"name\" : \"Rock A Feller Bar and Grill\", \"Borough\" : \"Queens\", \"violations\" : 2 }, { \"_id\" : 3, \"name\" : \"Empire State Pub\", \"Borough\" : \"Brooklyn\", \"violations\" : 4 }, { \"_id\" : 4, \"name\" : \"Pizza Rat's Pizzaria\", \"Borough\" : \"Manhattan\", \"violations\" : 7 } name字段使用filter条件填充，而update operators 用于创建文档的 rest。 以下操作使用violations更新大于10的第一个文档： try { db.restaurant.updateOne( { \"violations\" : { $gt: 10} }, { $set: { \"Closed\" : true } }, { upsert: true } ); } catch (e) { print(e); } 操作返回： { \"acknowledged\" : true, \"matchedCount\" : 0, \"modifiedCount\" : 0, \"upsertedId\" : ObjectId(\"56310c3c0c5cbb6031cafaea\") } 该集合现在包含以下文档： { \"_id\" : 1, \"name\" : \"Central Perk Cafe\", \"Borough\" : \"Manhattan\", \"violations\" : 3 }, { \"_id\" : 2, \"name\" : \"Rock A Feller Bar and Grill\", \"Borough\" : \"Queens\", \"violations\" : 2 }, { \"_id\" : 3, \"name\" : \"Empire State Pub\", \"Borough\" : \"Brooklyn\", \"violations\" : 4 }, { \"_id\" : 4, \"name\" : \"Pizza Rat's Pizzaria\", \"Borough\" : \"Manhattan\", \"grade\" : 7 } { \"_id\" : ObjectId(\"56310c3c0c5cbb6031cafaea\"), \"Closed\" : true } 由于没有文档与过滤器匹配，并且upsert是true，updateOne仅使用生成的_id和update条件插入文档。 写关注更新 给定三个成员副本集，以下操作指定majority wtimeout，wtimeout 100： try { db.restaurant.updateOne( { \"name\" : \"Pizza Rat's Pizzaria\" }, { $inc: { \"violations\" : 3}, $set: { \"Closed\" : true } }, { w: \"majority\", wtimeout: 100 } ); } catch (e) { print(e); } 如果主要和至少一个辅助设备在 100 毫秒内确认每个写入操作，则返回： { \"acknowledged\" : true, \"matchedCount\" : 1, \"modifiedCount\" : 1 } 如果确认时间超过wtimeout限制，则抛出以下 exception： WriteConcernError({ \"code\" : 64, \"errInfo\" : { \"wtimeout\" : true }, \"errmsg\" : \"waiting for replication timed out\" }): 指定排序规则 version 3.4 中的新内容。 整理允许用户为 string 比较指定 language-specific 规则，例如字母和重音标记的规则。 集合myColl具有以下文档： { _id: 1, category: \"cafe\", status: \"A\" } { _id: 2, category: \"cafe\", status: \"a\" } { _id: 3, category: \"cafE\", status: \"a\" } 以下操作包括整理选项： db.myColl.updateOne( { category: \"cafe\" }, { $set: { status: \"Updated\" } }, { collation: { locale: \"fr\", strength: 1 } } ); 为 Array Update Operations 指定 arrayFilters version 3.6 中的新内容。 从 MongoDB 3.6 开始，在更新 array 字段时，您可以指定arrayFilters来确定要更新的 array 元素。 更新元素 Match arrayFilters Criteria 使用以下文档创建集合students： db.students.insert([ { \"_id\" : 1, \"grades\" : [ 95, 92, 90 ] }, { \"_id\" : 2, \"grades\" : [ 98, 100, 102 ] }, { \"_id\" : 3, \"grades\" : [ 95, 110, 100 ] } ]) 要修改grades array 中大于或等于100的所有元素，请使用过滤后的位置 operator $ []和db.collection.updateOne方法中的arrayFilters选项： db.students.updateOne( { grades: { $gte: 100 } }, { $set: { \"grades.$[element]\" : 100 } }, { arrayFilters: [ { \"element\": { $gte: 100 } } ] } ) 该操作更新单个文档的grades字段，在操作之后，该集合具有以下文档： { \"_id\" : 1, \"grades\" : [ 95, 92, 90 ] } { \"_id\" : 2, \"grades\" : [ 98, 100, 100 ] } { \"_id\" : 3, \"grades\" : [ 95, 110, 100 ] } 要修改是大于或等于所有元素100中 grades阵列中，使用过滤的位置操作者 $[]与arrayFilters在选项 db.collection.updateOne方法： db.students.updateOne( { grades: { $gte: 100 } }, { $set: { \"grades.$[element]\" : 100 } }, { arrayFilters: [ { \"element\": { $gte: 100 } } ] } ) 该操作将更新grades单个文档的字段，并且在操作之后，集合具有以下文档： { \"_id\" : 1, \"grades\" : [ 95, 92, 90 ] } { \"_id\" : 2, \"grades\" : [ 98, 100, 100 ] } { \"_id\" : 3, \"grades\" : [ 95, 110, 100 ] } 更新 Array 文档的特定元素 使用以下文档创建集合students2： db.students2.insert([ { \"_id\" : 1, \"grades\" : [ { \"grade\" : 80, \"mean\" : 75, \"std\" : 6 }, { \"grade\" : 85, \"mean\" : 90, \"std\" : 4 }, { \"grade\" : 85, \"mean\" : 85, \"std\" : 6 } ] }, { \"_id\" : 2, \"grades\" : [ { \"grade\" : 90, \"mean\" : 75, \"std\" : 6 }, { \"grade\" : 87, \"mean\" : 90, \"std\" : 3 }, { \"grade\" : 85, \"mean\" : 85, \"std\" : 4 } ] } ]) 要修改grades array 中等级大于或等于85的所有元素的mean字段的 value，请使用过滤后的位置 operator $ []和db.collection.updateOne方法中的arrayFilters： db.students2.updateOne( { }, { $set: { \"grades.$[elem].mean\" : 100 } }, { arrayFilters: [ { \"elem.grade\": { $gte: 85 } } ] } ) 该操作更新单个文档的 array，并且在操作之后，该集合具有以下文档： { \"_id\" : 1, \"grades\" : [ { \"grade\" : 80, \"mean\" : 75, \"std\" : 6 }, { \"grade\" : 85, \"mean\" : 100, \"std\" : 4 }, { \"grade\" : 85, \"mean\" : 100, \"std\" : 6 } ] } { \"_id\" : 2, \"grades\" : [ { \"grade\" : 90, \"mean\" : 75, \"std\" : 6 }, { \"grade\" : 87, \"mean\" : 90, \"std\" : 3 }, { \"grade\" : 85, \"mean\" : 85, \"std\" : 4 } ] } 也可以看看 要更新多个文档，请参阅db.collection.updateMany()。 指定hint更新操作 4.2.1版中的新功能。 members使用以下文档创建样本集合： db.members.insertMany([ { \"_id\" : 1, \"member\" : \"abc123\", \"status\" : \"P\", \"points\" : 0, \"misc1\" : null, \"misc2\" : null }, { \"_id\" : 2, \"member\" : \"xyz123\", \"status\" : \"A\", \"points\" : 60, \"misc1\" : \"reminder: ping me at 100pts\", \"misc2\" : \"Some random comment\" }, { \"_id\" : 3, \"member\" : \"lmn123\", \"status\" : \"P\", \"points\" : 0, \"misc1\" : null, \"misc2\" : null }, { \"_id\" : 4, \"member\" : \"pqr123\", \"status\" : \"D\", \"points\" : 20, \"misc1\" : \"Deactivated\", \"misc2\" : null }, { \"_id\" : 5, \"member\" : \"ijk123\", \"status\" : \"P\", \"points\" : 0, \"misc1\" : null, \"misc2\" : null }, { \"_id\" : 6, \"member\" : \"cde123\", \"status\" : \"A\", \"points\" : 86, \"misc1\" : \"reminder: ping me at 100pts\", \"misc2\" : \"Some random comment\" } ]) 在集合上创建以下索引： db.members.createIndex( { status: 1 } ) db.members.createIndex( { points: 1 } ) 以下更新操作明确暗示要使用索引：{ status: 1 } 注意 如果指定的索引不存在，则操作错误。 db.members.updateOne( { \"points\": { $lte: 20 }, \"status\": \"P\" }, { $set: { \"misc1\": \"Need to activate\" } }, { hint: { status: 1 } } ) update命令返回以下内容： { \"acknowledged\" : true, \"matchedCount\" : 1, \"modifiedCount\" : 1 } 要查看使用的索引，可以使用$indexStats管道： db.members.aggregate( [ { $indexStats: { } }, { $sort: { name: 1 } } ] ) Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-updateMany.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-updateMany.html","title":"db.collection.updateMany()","keywords":"","body":" db.collection.updateMany（） 在本页面 定义 语法 访问控制 行为 例子 定义 db.collection. updateMany(过滤，更新，选项) version 3.2 中的新内容。 更新与集合的指定过滤器匹配的所有文档。 语法 updateMany()方法具有以下形式： db.collection.updateMany( , , { upsert: , writeConcern: , collation: , arrayFilters: [ , ... ], hint: // Available starting in MongoDB 4.2.1 } ) 参数 updateMany()方法采用以下参数： 参数 类型 描述 filter document 更新的选择标准。可以使用与find()方法相同的query selectors。 指定一个空文档{ }以更新集合中的所有文档。 update document 要应用的修改。可以是以下之一： 1. 更新文件：仅包含更新运算符表达式。有关更多信息，请参见 使用更新运算符表达式文档进行更新。2. 聚合管道（从MongoDB 4.2开始）：仅包含以下聚合阶段：a. $addFields及其别名 $setb. $project及其别名 $unsetc. replaceRoot及其别名$replaceWith。有关更多信息，请参见 使用聚合管道更新。要使用替换文档进行更新，请参阅 db.collection.replaceOne()。 upsert boolean 可选的。当true，updateMany()时：1. 如果没有文档匹配filter，则创建一个新文档。有关详细信息，请参阅upsert 行为。 2. 更新匹配filter的文档。 要避免多次 upsert，请确保filter字段为唯一索引。 默认为false。 writeConcern document 可选的。表示写关注的文件。省略使用默认写入问题。如果在事务中运行，请不要为操作明确设置写关注点。要对事务使用写关注，请参见 事务和写关注。 collation document 可选的。 指定要用于操作的排序规则。 排序规则允许用户为字符串比较指定特定于语言的规则，例如字母大写和重音符号的规则。排序规则选项具有以下语法：collation：{ locale：， caseLevel：， caseFirst：， strength：， numericOrdering：， alternate：， maxVariable：， backwards ： } 指定排序规则时，locale字段是必填字段;所有其他排序规则字段都是可选的。有关字段的说明，请参阅整理文件。 如果未指定排序规则但集合具有默认排序规则(请参阅db.createCollection())，则操作将使用为集合指定的排序规则。 如果没有为集合或操作指定排序规则，则MongoDB会将以前版本中使用的简单二进制比较用于字符串比较。 您不能为一个操作指定多个排序规则。例如，您不能为每个字段指定不同的排序规则，或者如果对排序执行查找，则不能对查找使用一种排序规则，而对排序使用另一种排序规则。 3.4版的新功能。 arrayFilters array 可选的。过滤器文档的 array，用于确定要在 array 字段上为更新操作修改哪些 array 元素。 在更新文档中，使用$[]过滤后的位置运算符定义一个标识符，然后在数组过滤器文档中引用该标识符。如果更新文档中未包含标识符，则不能具有数组过滤器文档作为标识符。 注意必须以小写字母开头，并且只包含字母数字字符。 您可以在更新文档中多次包含相同的标识符;但是，对于更新文档中的每个不同标识符($[identifier])，您必须指定恰好一个对应的 array 过滤器文档。也就是说，您不能为同一标识符指定多个 array 过滤器文档。对于 example，如果 update 语句包含标识符x(可能多次)，则不能为arrayFilters指定以下内容，其中包含 2 个单独的x过滤器文档：[ { \"x.a\": { $gt: 85 } }, { \"x.b\": { $gt: 80 } } ]但是，您可以在同一标识符上指定复合条件单个过滤器文档，例如以下示例：[ {$or：[{\"x.a\": {$gt: 85}}, {\"x.b\": {$gt: 80}}]} ] [ {$and：[{\"x.a\": {$gt: 85}}, {\"x.b\": {$gt: 80}}]} ] [ { \"x.a\": { $gt: 85 }, \"x.b\": { $gt: 80 } }] 有关示例，请参阅为数组更新操作指定arrayFilters。 version 3.6 中的新内容。 hint Document or string 可选的。一个文档或字符串，它指定用于支持查询谓词的索引。该选项可以采用索引规范文档或索引名称字符串。如果指定的索引不存在，则操作错误。有关示例，请参见为更新操作指定提示。4.2.1版中的新功能。 返回： 包含以下内容的文档：一个布尔值acknowledged，就好像该操作在运行时带有 写关注关系true或是否禁用了写关注关系false matchedCount包含匹配文档数 modifiedCount包含已修改文档数 upsertedId包含_id 要提交的文档 访问控制 在运行authorization时，用户必须具有包括以下特权的访问权限： update 对指定集合的操作。 find对指定集合的操作。 insert如果操作导致更新，则对指定的集合执行操作。 内置角色readWrite提供所需的特权。 行为 updateMany()使用update条件应用修改更新匹配filter的集合中的所有匹配文档。 UPSERT 如果upsert: true和没有与filter文档匹配，则db.collection.updateMany()根据filter和update参数创建一个新文档。 如果在分片集合上指定upsert: true，则必须在 filter 中包含完整的分片键。有关其他db.collection.updateMany()行为，请参见分片集合。 请参阅 使用Upsert更新多个文档。 使用更新运算符表达式文档进行更新 对于修改规范，该 db.collection.updateMany()方法可以接受仅包含要执行的更新操作符表达式的文档。 例如： db.collection.updateMany( , { $set: { status: \"D\" }, $inc: { quantity: 2 } }, ... ) 使用聚合管道进行更新 从MongoDB 4.2开始，db.collection.updateMany()方法可以接受指定要执行修改的聚合管道 。管道可以包括以下阶段：[ , , ... ] $addFields及其别名 $set $project及其别名 $unset $replaceRoot及其别名$replaceWith。 使用聚合管道可以实现更具表达力的更新语句，例如根据当前字段值表达条件更新，或使用另一个字段的值更新一个字段。 例如： db.collection.updateMany( , [ { $set: { status: \"Modified\", comments: [ \"$misc1\", \"$misc2\" ] } }, { $unset: [ \"misc1\", \"misc2\" ] } ] ... ) 注意 管道中使用的$set和$unset分别指向聚合阶段$set和$unset，而不是更新操作符$set和$unset。 有关示例，请参见使用聚合管道更新。 固定集合 如果更新操作更改了文档大小，则该操作将失败。 分片集合 对于db.collection.updateMany()包含分片集合并包含upsert: true在分片集合中的操作，必须在filter中包含完整的分片键。 可解释性 updateMany()与 db.collection.explain()不兼容。 使用update()代替。 事务 db.collection.updateMany()可以在多文档事务中使用。 如果该操作导致upsert，则该集合必须已经存在。 如果在事务中运行，请不要为操作明确设置写关注点。要对事务使用写关注，请参见 事务和写关注。 重要 在大多数情况下，与单文档写入相比，多文档事务产生的性能成本更高，并且多文档事务的可用性不应替代有效的架构设计。在许多情况下， 非规范化数据模型（嵌入式文档和数组）将继续是您的数据和用例的最佳选择。也就是说，在许多情况下，适当地对数据建模将最大程度地减少对多文档交易的需求。 有关其他事务使用方面的注意事项（例如运行时限制和操作日志大小限制），另请参见 生产注意事项。 例子 更新多个文档 restaurant集合包含以下文档： { \"_id\" : 1, \"name\" : \"Central Perk Cafe\", \"violations\" : 3 } { \"_id\" : 2, \"name\" : \"Rock A Feller Bar and Grill\", \"violations\" : 2 } { \"_id\" : 3, \"name\" : \"Empire State Sub\", \"violations\" : 5 } { \"_id\" : 4, \"name\" : \"Pizza Rat's Pizzaria\", \"violations\" : 8 } 下面的操作更新，所有文件violations都大于4和$set审核标志： try { db.restaurant.updateMany( { violations: { $gt: 4 } }, { $set: { \"Review\" : true } } ); } catch (e) { print(e); } 操作返回： { \"acknowledged\" : true, \"matchedCount\" : 2, \"modifiedCount\" : 2 } 该集合现在包含以下文档： { \"_id\" : 1, \"name\" : \"Central Perk Cafe\", \"violations\" : 3 } { \"_id\" : 2, \"name\" : \"Rock A Feller Bar and Grill\", \"violations\" : 2 } { \"_id\" : 3, \"name\" : \"Empire State Sub\", \"violations\" : 5, \"Review\" : true } { \"_id\" : 4, \"name\" : \"Pizza Rat's Pizzaria\", \"violations\" : 8, \"Review\" : true } 如果未找到匹配项，则操作将返回： { \"acknowledged\" : true, \"matchedCount\" : 0, \"modifiedCount\" : 0 } 如果未找到匹配项，则设置upsert: true将插入文档。 使用聚合管道更新 从MongoDB 4.2开始，db.collection.updateMany()可以使用聚合管道进行更新。管道可以包括以下阶段： $addFields及其别名 $set $project及其别名 $unset $replaceRoot及其别名$replaceWith。 使用聚合管道可以实现更具表达力的更新语句，例如根据当前字段值表达条件更新，或使用另一个字段的值更新一个字段。 实施例1 以下示例使用聚合管道文档中其他字段的值来修改字段。 members使用以下文档创建一个集合： db.members.insertMany([ { \"_id\" : 1, \"member\" : \"abc123\", \"status\" : \"A\", \"points\" : 2, \"misc1\" : \"note to self: confirm status\", \"misc2\" : \"Need to activate\", \"lastUpdate\" : ISODate(\"2019-01-01T00:00:00Z\") }, { \"_id\" : 2, \"member\" : \"xyz123\", \"status\" : \"A\", \"points\" : 60, \"misc1\" : \"reminder: ping me at 100pts\", \"misc2\" : \"Some random comment\", \"lastUpdate\" : ISODate(\"2019-01-01T00:00:00Z\") } ]) 假设您希望将这些字段收集到一个新字段中，而不是使用单独的misc1和misc2字段comments。以下更新操作使用聚合管道执行以下操作： 添加新comments字段并设置该lastUpdate字段。 删除集合中所有文档的misc1和misc2字段。 db.members.updateMany( { }, [ { $set: { status: \"Modified\", comments: [ \"$misc1\", \"$misc2\" ], lastUpdate: \"$$NOW\" } }, { $unset: [ \"misc1\", \"misc2\" ] } ] ) 注意 该$set和$unset在管道中是指聚合阶段$set，并$unset分别，而不是更新的运营商$set和$unset。 第一阶段 $set阶段： 创建一个新的数组字段，comments其元素是misc1和misc2字段的当前内容 将字段设置为lastUpdate聚合变量的值NOW。聚合变量 NOW解析为当前日期时间值，并且在整个管道中保持不变。要访问聚合变量，请在变量前加双美元符号$$ 并用引号引起来。 第二阶段 该$unset阶段将删除misc1和misc2字段。 命令后，集合包含以下文档： { \"_id\" : 1, \"member\" : \"abc123\", \"status\" : \"Modified\", \"points\" : 2, \"lastUpdate\" : ISODate(\"2020-01-23T05:50:49.247Z\"), \"comments\" : [ \"note to self: confirm status\", \"Need to activate\" ] } { \"_id\" : 2, \"member\" : \"xyz123\", \"status\" : \"Modified\", \"points\" : 60, \"lastUpdate\" : ISODate(\"2020-01-23T05:50:49.247Z\"), \"comments\" : [ \"reminder: ping me at 100pts\", \"Some random comment\" ] } 示例 聚合管道允许基于当前字段值执行条件更新，以及使用当前字段值来计算单独的字段值。 例如，students3使用以下文档创建一个集合： db.students3.insert([ { \"_id\" : 1, \"tests\" : [ 95, 92, 90 ], \"lastUpdate\" : ISODate(\"2019-01-01T00:00:00Z\") }, { \"_id\" : 2, \"tests\" : [ 94, 88, 90 ], \"lastUpdate\" : ISODate(\"2019-01-01T00:00:00Z\") }, { \"_id\" : 3, \"tests\" : [ 70, 75, 82 ], \"lastUpdate\" : ISODate(\"2019-01-01T00:00:00Z\") } ]); 使用聚合管道，可以使用计算出的平均成绩和字母成绩更新文档。 db.students3.updateMany( { }, [ { $set: { average : { $trunc: [ { $avg: \"$tests\" }, 0 ] } , lastUpdate: \"$$NOW\" } }, { $set: { grade: { $switch: { branches: [ { case: { $gte: [ \"$average\", 90 ] }, then: \"A\" }, { case: { $gte: [ \"$average\", 80 ] }, then: \"B\" }, { case: { $gte: [ \"$average\", 70 ] }, then: \"C\" }, { case: { $gte: [ \"$average\", 60 ] }, then: \"D\" } ], default: \"F\" } } } } ] ) 注意 该$set管道中的使用是指聚合阶段 $set，而不是更新运算符$set。 第一阶段 该$set阶段： 根据字段average的平均值 计算一个新tests字段。请参阅$avg有关 $avg聚合运算符$trunc的更多信息和有关$trunc截断聚合运算符的更多信息。 将字段设置为lastUpdate聚合变量的值NOW。聚合变量 NOW解析为当前日期时间值，并且在整个管道中保持不变。要访问聚合变量，请在变量前加双美元符号$$ 并用引号引起来。 第二阶段 该$set阶段计算新字段grade基础上，average在前一阶段计算。参见 $switch以获取有关$switch 聚合运算符的更多信息。 命令后，集合包含以下文档： { \"_id\" : 1, \"tests\" : [ 95, 92, 90 ], \"lastUpdate\" : ISODate(\"2020-01-24T17:31:01.670Z\"), \"average\" : 92, \"grade\" : \"A\" } { \"_id\" : 2, \"tests\" : [ 94, 88, 90 ], \"lastUpdate\" : ISODate(\"2020-01-24T17:31:01.670Z\"), \"average\" : 90, \"grade\" : \"A\" } { \"_id\" : 3, \"tests\" : [ 70, 75, 82 ], \"lastUpdate\" : ISODate(\"2020-01-24T17:31:01.670Z\"), \"average\" : 75, \"grade\" : \"C\" } 也可以看看 聚合管道更新 使用 Upsert 更新多个文档 inspectors集合包含以下文档： { \"_id\" : 92412, \"inspector\" : \"F. Drebin\", \"Sector\" : 1, \"Patrolling\" : true }, { \"_id\" : 92413, \"inspector\" : \"J. Clouseau\", \"Sector\" : 2, \"Patrolling\" : false }, { \"_id\" : 92414, \"inspector\" : \"J. Clouseau\", \"Sector\" : 3, \"Patrolling\" : true }, { \"_id\" : 92415, \"inspector\" : \"R. Coltrane\", \"Sector\" : 3, \"Patrolling\" : false } 以下操作更新Sector大于 4 且inspector等于\"R. Coltrane\"的所有文档： try { db.inspectors.updateMany( { \"Sector\" : { $gt : 4 }, \"inspector\" : \"R. Coltrane\" }, { $set: { \"Patrolling\" : false } }, { upsert: true } ); } catch (e) { print(e); } 操作返回： { \"acknowledged\" : true, \"matchedCount\" : 0, \"modifiedCount\" : 0, \"upsertedId\" : ObjectId(\"56fc5dcb39ee682bdc609b02\") } 该集合现在包含以下文档： { \"_id\" : 92412, \"inspector\" : \"F. Drebin\", \"Sector\" : 1, \"Patrolling\" : true }, { \"_id\" : 92413, \"inspector\" : \"J. Clouseau\", \"Sector\" : 2, \"Patrolling\" : false }, { \"_id\" : 92414, \"inspector\" : \"J. Clouseau\", \"Sector\" : 3, \"Patrolling\" : true }, { \"_id\" : 92415, \"inspector\" : \"R. Coltrane\", \"Sector\" : 3, \"Patrolling\" : false }, { \"_id\" : ObjectId(\"56fc5dcb39ee682bdc609b02\"), \"inspector\" : \"R.Coltrane\", \"Patrolling\" : false } 由于没有文档与过滤器匹配，并且upsert是true，updateMany插入了生成_id的文档，filter和update修饰符的等式条件。 写关注更新 给定三个成员副本集，以下操作指定majority majority和wtimeout 100： try { db.restaurant.updateMany( { \"name\" : \"Pizza Rat's Pizzaria\" }, { $inc: { \"violations\" : 3}, $set: { \"Closed\" : true } }, { w: \"majority\", wtimeout: 100 } ); } catch (e) { print(e); } 如果确认时间超过wtimeout限制，则抛出以下 exception： WriteConcernError({ \"code\" : 64, \"errInfo\" : { \"wtimeout\" : true }, \"errmsg\" : \"waiting for replication timed out\" }) : undefined wtimeout错误仅表示操作未在 time 完成。写操作本身仍然可以在 set time 限制之外成功。 指定排序规则 version 3.4 中的新内容。 整理允许用户为 string 比较指定 language-specific 规则，例如字母和重音标记的规则。 集合myColl具有以下文档： { _id: 1, category: \"cafe\", status: \"A\" } { _id: 2, category: \"cafe\", status: \"a\" } { _id: 3, category: \"cafE\", status: \"a\" } 以下操作包括整理选项： db.myColl.updateMany( { category: \"cafe\" }, { $set: { status: \"Updated\" } }, { collation: { locale: \"fr\", strength: 1 } } ); 为 Array Update Operations 指定 arrayFilters version 3.6 中的新内容。 从 MongoDB 3.6 开始，在更新 array 字段时，您可以指定arrayFilters来确定要更新的 array 元素。 更新元素 Match arrayFilters Criteria 使用以下文档创建集合students： db.students.insert([ { \"_id\" : 1, \"grades\" : [ 95, 92, 90 ] }, { \"_id\" : 2, \"grades\" : [ 98, 100, 102 ] }, { \"_id\" : 3, \"grades\" : [ 95, 110, 100 ] } ]) 要更新grades array 中大于或等于100的所有元素，请使用带有arrayFilters选项的已过滤位置 operator $ []： db.students.updateMany( { grades: { $gte: 100 } }, { $set: { \"grades.$[element]\" : 100 } }, { arrayFilters: [ { \"element\": { $gte: 100 } } ] } ) 操作后，该集合包含以下文档： { \"_id\" : 1, \"grades\" : [ 95, 92, 90 ] } { \"_id\" : 2, \"grades\" : [ 98, 100, 100 ] } { \"_id\" : 3, \"grades\" : [ 95, 100, 100 ] } 更新 Array 文档的特定元素 使用以下文档创建集合students2： db.students2.insert([ { \"_id\" : 1, \"grades\" : [ { \"grade\" : 80, \"mean\" : 75, \"std\" : 6 }, { \"grade\" : 85, \"mean\" : 90, \"std\" : 4 }, { \"grade\" : 85, \"mean\" : 85, \"std\" : 6 } ] }, { \"_id\" : 2, \"grades\" : [ { \"grade\" : 90, \"mean\" : 75, \"std\" : 6 }, { \"grade\" : 87, \"mean\" : 90, \"std\" : 3 }, { \"grade\" : 85, \"mean\" : 85, \"std\" : 4 } ] } ]) 要修改grades array 中等级大于或等于85的所有元素的mean字段的 value，请使用已过滤的位置 operator $ []和arrayFilters： db.students2.updateMany( { }, { $set: { \"grades.$[elem].mean\" : 100 } }, { arrayFilters: [ { \"elem.grade\": { $gte: 85 } } ] } ) 操作后，该集合包含以下文件： { \"_id\" : 1, \"grades\" : [ { \"grade\" : 80, \"mean\" : 75, \"std\" : 6 }, { \"grade\" : 85, \"mean\" : 100, \"std\" : 4 }, { \"grade\" : 85, \"mean\" : 100, \"std\" : 6 } ] } { \"_id\" : 2, \"grades\" : [ { \"grade\" : 90, \"mean\" : 100, \"std\" : 6 }, { \"grade\" : 87, \"mean\" : 100, \"std\" : 3 }, { \"grade\" : 85, \"mean\" : 100, \"std\" : 4 } ] } 指定hint更新操作 4.2.1版中的新功能。 members使用以下文档创建样本集合： db.members.insertMany([ { \"_id\" : 1, \"member\" : \"abc123\", \"status\" : \"P\", \"points\" : 0, \"misc1\" : null, \"misc2\" : null }, { \"_id\" : 2, \"member\" : \"xyz123\", \"status\" : \"A\", \"points\" : 60, \"misc1\" : \"reminder: ping me at 100pts\", \"misc2\" : \"Some random comment\" }, { \"_id\" : 3, \"member\" : \"lmn123\", \"status\" : \"P\", \"points\" : 0, \"misc1\" : null, \"misc2\" : null }, { \"_id\" : 4, \"member\" : \"pqr123\", \"status\" : \"D\", \"points\" : 20, \"misc1\" : \"Deactivated\", \"misc2\" : null }, { \"_id\" : 5, \"member\" : \"ijk123\", \"status\" : \"P\", \"points\" : 0, \"misc1\" : null, \"misc2\" : null }, { \"_id\" : 6, \"member\" : \"cde123\", \"status\" : \"A\", \"points\" : 86, \"misc1\" : \"reminder: ping me at 100pts\", \"misc2\" : \"Some random comment\" } ]) 在集合上创建以下索引： db.members.createIndex( { status: 1 } ) db.members.createIndex( { points: 1 } ) 以下更新操作明确暗示要使用索引：{ status: 1 } 注意 如果指定的索引不存在，则操作错误。 db.members.updateMany( { \"points\": { $lte: 20 }, \"status\": \"P\" }, { $set: { \"misc1\": \"Need to activate\" } }, { hint: { status: 1 } } ) update命令返回以下内容： { \"acknowledged\" : true, \"matchedCount\" : 3, \"modifiedCount\" : 3 } 要查看使用的索引，可以使用$indexStats管道： db.members.aggregate( [ { $indexStats: { } }, { $sort: { name: 1 } } ] ) Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-watch.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-watch.html","title":"db.collection.watch()","keywords":"","body":" db.collection.watch（） 在本页面 定义 可用性 部署方式 存储引擎 阅读关注majority支持 行为 可恢复 完整文档查找和更新操作 访问控制 例子 打开更改流 使用完整文档更新查找更改流 使用聚合管道过滤器更改流 恢复变更流 定义 db.collection. watch(管道，选项) 仅适用于副本集和分片群集 在集合上打开改变流游标。 参数 类型 描述 pipeline array 以下一个或多个聚合阶段的序列： $match $project $addFields $replaceRoot $replaceWith（从MongoDB 4.2开始可用） $redact$set（从MongoDB 4.2开始可用）$unset（从MongoDB 4.2开始可用）指定管道以过滤/修改变更事件输出。从MongoDB 4.2开始，如果更改流聚合管道修改了事件的_id字段，则更改流将引发异常。 options document 可选的。修改watch()行为的其他选项。 如果未指定管道但传递options文档，则必须将空 array []传递给pipeline参数。 options文档可以包含以下字段和值： 字段 类型 描述 resumeAfter document 可选的。指示watch尝试在恢复令牌中指定的操作之后重新开始通知。 每个更改流 event 文档都包含一个恢复标记作为_id字段。传递 change event 文档的整个_id字段，该字段表示您要在之后恢复的操作。resumeAfter与startAfter和 互斥startAtOperationTime。 startAfter document 可选的。指示watch在恢复令牌中指定的操作之后尝试启动新的更改流。允许在事件无效后恢复通知。每个变更流事件文档都包括一个恢复令牌作为 _id字段。传递更改事件文档的整个 _id字段，该字段代表您要恢复的操作。startAfter与resumeAfter和 互斥startAtOperationTime。4.2版中的新功能。 fullDocument string 可选的。默认情况下，watch()返回由更新操作修改的字段的增量，而不是整个更新的文档。 设置fullDocument为“ \"updateLookup\"直接” watch()以查找更新文档的最新多数批准版本。 watch()返回一个fullDocument字段，其中包含除了updateDescription增量以外的文档查找。 batchSize int 可选的。指定 MongoDB集群的每批响应中返回的最大更改次数。 具有与cursor.batchSize()的功能相同。 maxAwaitTimeMS int 可选的。服务器等待新数据更改以在返回空批处理之前向更改流游标报告的最大时间(以毫秒为单位)。 默认为1000毫秒。 collation document 可选的。传递排序规则文件为更改流游标指定排序。从MongoDB 4.2开始，simple如果省略，默认为二进制比较。在早期版本中，在单个集合上打开的更改流将继承该集合的默认排序规则。 startAtOperationTime Timestamp 可选的。变更流的起点。如果指定的起点是过去的时间，则必须在操作日志的时间范围内。要查看操作日志的时间范围，请参阅 rs.printReplicationInfo()。startAtOperationTime与resumeAfter 和互斥startAfter。版本4.0中的新功能。 返回值： 一个游标是保持被打开，以MongoDB的部署的连接保持打开状态，并收集存在。有关变更事件文档的示例，请参见变更事件。 也可以看看 db.watch() 和 Mongo.watch() 可用性 部署 db.collection.watch()可用于副本集和分片群集部署： 对于副本集，您可以db.collection.watch()在任何数据承载成员上发行。 对于分片群集，必须db.collection.watch()在mongos实例上发出。 存储引擎 您只能db.collection.watch()与Wired Tiger存储引擎一起使用。 阅读关注majority支持 从MongoDB 4.2开始，无论是否支持读关注，更改流都可用\"majority\"。也就是说，majority可以启用（默认）读取关注支持或禁用 以使用更改流。 在MongoDB 4.0和更早版本中，更改流仅在\"majority\"启用了阅读关注支持后才可用（默认）。 行为 db.collection.watch()仅通知持续存在于大多数 data-bearing 成员的数据更改。 改变流游标保持打开状态，直到出现以下情况之一： 游标显式关闭。 发生无效事件；例如：集合删除或重命名。 与 MongoDB 部署的连接已关闭。 如果部署是分片集群，则删除分片可能会导致打开更改流游标关闭，并且关闭的更改流游标可能无法完全恢复。 可恢复 与 MongoDB 驱动程序不同，mongo shell 在发生错误后不会自动尝试恢复更改流游标。 MongoDB 驱动程序尝试在某些错误后自动恢复更改流游标。 db.collection.watch()使用存储在 oplog 中的信息来生成更改 event 描述并生成与该操作关联的恢复标记。如果由传递给resumeAfteror startAfter选项的恢复令牌标识的操作已经从oplog中删除，db.collection.watch()则无法恢复更改流。 有关恢复更改流的更多信息，请参阅恢复变更流。 注意 resumeAfter在无效事件（例如，集合删除或重命名）关闭流之后，您不能用来恢复更改 流。从MongoDB 4.2开始，您可以使用 startAfter在invalidate事件之后启动新的更改流。 如果部署是分片集群，则分片删除可能会导致打开的更改流游标关闭，并且关闭的更改流游标可能无法完全恢复。 恢复令牌 恢复令牌_data类型取决于MongoDB版本，在某些情况下，取决于更改流打开/恢复时的功能兼容性版本（fcv）（即，fcv值的更改不会影响已打开的更改流的恢复令牌。 ）： MongoDB版本 功能兼容版本 恢复令牌_data类型 MongoDB 4.2及更高版本 “ 4.2”或“ 4.0” 十六进制编码的字符串（v1） MongoDB 4.0.7及更高版本 “ 4.0”或“ 3.6” 十六进制编码的字符串（v1） MongoDB 4.0.6及更早版本 “ 4.0” 十六进制编码的字符串（v0） MongoDB 4.0.6及更早版本 “ 3.6” BinData MongoDB 3.6 “ 3.6” BinData 使用十六进制编码的字符串恢复令牌，您可以对恢复令牌进行比较和排序。 无论fcv值如何，4.0部署都可以使用BinData恢复令牌或十六进制字符串恢复令牌来恢复更改流。这样，4.0部署可以使用在3.6部署的集合中打开的更改流中的恢复令牌。 MongoDB版本中引入的新的恢复令牌格式不能被早期MongoDB版本使用。 完整文档查找和更新操作 默认情况下，更改流游标返回用于更新操作的特定字段更改/增量。您还可以配置更改流以查找并返回更改文档的当前多数提交版本。根据更新和查找之间可能发生的其他写入操作，返回的文档可能与更新时的文档有很大不同。 根据更新操作期间应用的更改数量和整个文档的大小，存在更新操作的更改事件文档的大小大于16MB BSON文档限制的风险。如果发生这种情况，服务器将关闭更改流游标并返回错误。 访问控制 使用访问控制运行时，用户必须对集合资源具有 find和changeStream特权操作。也就是说，用户必须具有授予以下特权的角色： { resource: { db: , collection: }, actions: [ \"find\", \"changeStream\" ] } 内置read角色提供适当的特权。 例子 打开更改流 以下操作将针对data.sensors集合打开更改流游标： watchCursor = db.getSiblingDB(\"data\").sensors.watch() 迭代光标以检查新的 events。使用cursor.isExhausted()方法确保循环仅在更改流游标关闭且最新批次中没有 objects 时退出： while (!watchCursor.isExhausted()){ if (watchCursor.hasNext()){ watchCursor.next(); } } 有关更改流输出的完整文档，请参阅变更事件。 使用完整文档更新查找更改流 设置fullDocument选项以\"updateLookup\"指示更改流游标查找与更新更改流事件相关联的文档的最新的多数提交版本。 以下操作data.sensors使用该选项针对集合 打开更改流游标。fullDocument : \"updateLookup\" watchCursor = db.getSiblingDB(\"data\").sensors.watch( [], { fullDocument : \"updateLookup\" } ) 迭代光标以检查新的 events。使用cursor.isExhausted()方法确保循环仅在更改流游标关闭且最新批次中没有 objects 时退出： while (!watchCursor.isExhausted()){ if (watchCursor.hasNext()){ watchCursor.next(); } } 对于任何更新操作，change事件都会在fullDocument字段中返回文档查找的结果。 有关完整文档更新输出的示例，请参阅更改流更新事件。 有关更改流输出的完整文档，请参阅改变事件。 使用聚合管道过滤器更改流 注意 从MongoDB 4.2开始，如果更改流聚合管道修改了事件的_id字段，则更改流将引发异常。 以下操作使用聚合管道打开针对data.sensors集合的更改流游标： watchCursor = db.getSiblingDB(\"data\").sensors.watch( [ { $match : {\"operationType\" : \"insert\" } } ] ) 迭代光标以检查新的事件。使用cursor.isExhausted()方法确保循环仅在更改流游标关闭且最新批次中没有 objects 时退出： while (!watchCursor.isExhausted()){ if (watchCursor.hasNext()){ watchCursor.next(); } } 更改流游标仅返回为insert的 change events。有关更改流输出的完整文档，请参阅变更事件。 恢复变更流 更改流游标返回的每个文档都包含一个恢复标记作为_id字段。要恢复更改流，请将要恢复的更改事件的整个_id文档传递给watch()的resumeAfter或startAfter选项。 以下操作data.sensors使用恢复令牌恢复针对集合的更改流游标 。假设生成恢复令牌的操作尚未脱离集群的操作日志。 let watchCursor = db.getSiblingDB(\"data\").sensors.watch(); let firstChange; while (!watchCursor.isExhausted()) { if (watchCursor.hasNext()) { firstChange = watchCursor.next(); break; } } watchCursor.close(); let resumeToken = firstChange._id; resumedWatchCursor = db.getSiblingDB(\"data\").sensors.watch( [], { resumeAfter : resumeToken } ) 迭代光标以检查新的事件。使用cursor.isExhausted()方法确保循环仅在更改流游标关闭且最新批次中没有 objects 时退出： while (!resumedWatchCursor.isExhausted()){ if (resumedWatchCursor.hasNext()){ resumedWatchCursor.next(); } } 有关恢复更改流的完整文档，请参阅恢复变更流。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-validate.html":{"url":"docs/Reference/mongo-Shell-Methods/Collection-Methods/db-collection-validate.html","title":"db.collection.validate()","keywords":"","body":" db.collection.validate（） 在本页面 定义 行为 例子 定义 db.collection. validate(true) 验证集合。该方法扫描集合数据和索引的正确性并返回结果。有关输出的详细信息，请参阅验证输出。 db.collection.validate()方法具有以下语法： db.collection.validate( { full: // Optional } ) 要指定full选项，您还可以使用： db.collection.validate( ) // full option db.collection.validate()方法可以使用以下可选文档参数： 字段 类型 描述 full boolean 可选的。一个标志，用于确定命令是执行较慢但更彻底的检查还是更快但不太彻底的检查。 1. 如果true，则执行更彻底的检查。 2. 如果false，省略一些检查，但不太彻底的检查。 默认为false。 从 MongoDB 3.6 开始，对于 WiredTiger 存储引擎，只有full 验证过程将强制检查点并将所有内存中数据刷新到磁盘，然后再验证磁盘上的数据。 在以前的版本中，WT 存储引擎的数据验证 process 总是强制检查点。 db.collection.validate()方法是验证 数据库命令的包装。 行为 db.collection.validate()方法可能会占用大量资源，并且可能会影响MongoDB实例的性能。 db.collection.validate()方法获取集合的排他锁。这将阻止对集合的所有读取和写入，直到操作完成。当运行在辅助节点上时，该操作可以阻止该辅助节点上的所有其他操作，直到它完成。 db.collection.validate()方法可能很慢，特别是在较大的数据集上。 注意 由于验证扫描数据结构的方式，即使完整的集合验证也无法检测到 MMAPv1 存储引擎数据 files 上的所有形式的损坏。 例子 使用默认设置(即：full: false)验证集合myCollection db.myCollection.validate() 要对集合进行完整验证myCollection db.myCollection.validate( { full: true } ) db.myCollection.validate(true) 有关输出的详细信息，请参阅验证输出。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Glossary.html":{"url":"docs/Reference/Glossary.html","title":"Glossary","keywords":"","body":"词汇表 $cmd 一个特殊的虚拟集合，它公开MongoDB的数据库命令。要使用数据库命令，请参见Issue commands。 _id 每个MongoDB文档中都需要的字段。_id字段必须有一个唯一的值。您可以将 _id 字段看作文档的主键。如果您创建一个没有_id字段的新文档，MongoDB将自动创建该字段并分配一个唯一的BSON ObjectId。 accumulator 聚合框架中的一种表达式，用于维护聚合管道中文档之间的状态 。有关accumulator操作的列表，请参见 。$group action 用户可以对资源执行的操作。Actions和资源组合创建特权。看行动。 admin database 一个数据库特权。用户必须能够访问 admin 数据库才能运行某些管理命令。有关管理命令的列表，请参见管理命令。 aggregation 减少和汇总大量数据的各种操作中的任何一种。MongoDB aggregate()和 mapReduce()方法是聚合操作的两个示例。有关更多信息，请参见 聚合。 aggregation framework 一组MongoDB操作符，让您不必使用map-reduce就可以计算聚合值。有关操作符的列表，请参见Aggregation Reference。 arbiter 一个复制集的成员，该成员仅存在于elections中投票。仲裁器不复制数据。查看Replica Set仲裁者。 Atlas MongoDB Atlas是云托管的数据库即服务。 authentication 验证用户身份。请看authentication。 authorization 提供对数据库和操作的访问。参见基于角色的访问控制。 B-tree 数据库管理系统通常用于存储索引的数据结构。MongoDB使用B-trees为其索引。 balancer 一个内部的MongoDB进程，运行在一个分片集群的上下文中，并管理chunk的迁移。管理员必须为分片集群上的所有维护操作禁用平衡器。参见Sharded Cluster Balancer。 BSON 一种用于在MongoDB中存储文档和进行远程过程调用的序列化格式。“BSON”是“二进制”和“JSON”的合成词。可以将BSON视为JSON（JavaScript对象表示法）文档的二进制表示形式。请参阅 BSON类型和 MongoDB扩展JSON(v2)。 BSON types BSON序列化格式支持的类型集。有关BSON类型的列表，请参见BSON types。 CAP Theorem 给定计算系统的三个属性，一致性，可用性和分区容限，分布式计算系统可以提供这些功能中的任何两个，但不能提供全部三个。 capped collection 一个固定大小的集合，当其达到最大大小时会自动覆盖其最早的条目。在复制中使用的MongoDB oplog是一个有上限的集合。。请参阅限制集合。 cardinality 对一组值中元素数量的度量。例如，集合 A ={2,4,6} 包含3个元素，基数为3。参见分片键基数。 checksum 用于确保数据完整性的计算值。有时使用md5算法作为checksum。 chunk 一个连续范围的分片键的特定内的值分片。块范围包括下边界，不包括上边界。当MongoDB超出配置的块大小（默认为64兆字节）时，MongoDB将对其进行拆分。当一个分片相对于其他分片包含一个集合的太多分块时，MongoDB会迁移这些分块。请参见 使用块和分片群集平衡器进行数据分区。 client 使用数据库进行数据持久性和存储的应用层。Drivers提供了应用程序层和数据库服务器之间的接口级别。客户端也可以引用单个线程或进程。 cluster 请看 sharded cluster. collection MongoDB 文档的分组。集合等效于RDBMS表。集合存在于单个数据库中。集合不强制执行架构。集合中的文档可以具有不同的字段。通常，集合中的所有文档都具有相似或相关的目的。请参阅命名空间。 collection scan 集合扫描是一种查询执行策略，MongoDB必须检查集合中的每个文档，以确定它是否符合查询条件。这些查询效率非常低，并且不使用索引。有关查询执行策略的详细信息，请参阅查询优化。 compound index 由两个或多个键组成的索引。请看复合索引。 concurrency control 并发控制可确保数据库操作可以并发执行而不会影响正确性。悲观并发控制，例如在带锁的系统中使用的，将阻止任何可能发生冲突的操作，即使它们可能最终并未真正冲突。乐观并发控制，即WiredTiger使用的方法将延迟检查，直到可能发生冲突之后，终止并重试任何出现 写冲突的操作。 config database 一个内部数据库，保存与分片集群相关联的元数据。应用程序和管理员不应该在正常操作过程中修改config数据库。请看配置数据库。 config server 一个mongod实例，存储与分片集群相关联的所有元数据。看到配置服务器。 container 打包在一起的一组软件及其从属库可以简化在计算环境之间的传输。容器在您的操作系统上作为分隔的进程运行，并且可以赋予它们自己的资源限制。常见的容器技术是Docker和Kubernetes。 CRUD 数据库基本操作的缩写:创建、读取、更新和删除。查看MongoDB CRUD操作。 CSV 一种基于文本的数据格式，由逗号分隔的值组成。由于该格式非常适合表格数据，因此通常用于在关系数据库之间交换数据。您可以使用导入CSV文件mongoimport。 cursor 一个指向查询结果集的指针。客户端可以遍历游标来检索结果。默认情况下，游标在不活动10分钟后超时。参见在mongo Shell中迭代游标。 daemon 后台、非交互进程的传统名称。 data directory mongod存储数据文件的文件系统位置。dbPath选项指定数据目录。 data partition 将数据划分为范围的分布式系统体系结构。 分片使用分区。请参见 使用块进行数据分区。 data-center awareness 一种属性，允许客户端根据其位置来寻址系统中的成员。复制集 使用标签实现数据中心感知。请参阅 数据中心意识。 database 集合的物理容器。每个数据库在文件系统上有自己的一组文件。一个MongoDB服务器通常有多个数据库。 database command MongoDB操作，而不是插入、更新、删除或查询。有关数据库命令的列表，请参见数据库命令。要使用数据库命令，请参见Issue commands。 database profiler 一种工具，当它被启用时，它在数据库的“系统”中保存所有长时间运行的操作的记录。概要文件的集合。分析器最常用来诊断慢速查询。请看数据库分析。 dbpath MongoDB的数据文件存储位置。请看dbPath。 delayed member 一个replica set成员，该成员不能成为主成员并在指定的延迟下应用操作。延迟对于保护数据不受人为错误(即无意中删除的数据库)或对生产数据库有不可预见影响的更新的影响非常有用。参见Delayed Replica Set Members。 document MongoDB集合中的一条记录和MongoDB中的基本数据单元。文档类似于JSON对象，但是以一种更丰富类型的格式存在于数据库中，称为BSON。请看document。 dot notation MongoDB使用点表示法来访问数组的元素和访问嵌入文档的字段。看到Dot Notation。 draining 从一个分片到另一个分片的移除或“shedding”chunks的过程。管理员必须在将分片从集群中删除之前将其排干。参见从现有分片集群中删除分片。 driver 用特定语言与MongoDB交互的客户端库。见 /drivers. durable 当一个或多个服务器进程关闭(或崩溃)和重新启动时，写操作是持久的。对于单个' mongod '服务器，当写入服务器的journal文件时，写操作被认为是持久的。对于复制集，一旦写入操作在大多数投票节点上是持久的，那么写入操作就被认为是持久的;即写给大多数投票节点的日志。 election 在启动和失败时，replica set的成员选择一个primary的进程。查看Replica Set Elections。 eventual consistency 分布式系统的一种属性，允许对系统的更改逐渐传播。在数据库系统中，这意味着可读成员不需要随时反映最新的写操作。 expression 在聚合框架的上下文中，表达式是对通过管道的数据进行操作的无状态转换。请看聚合管道。 failover 在发生故障时允许副本集的辅助成员成为主要成员 的过程。请参阅自动故障转移。 field A name-value pair in a document. A document has zero or more fields. Fields are analogous to columns in relational databases. See Document Structure. 文档中的名称-值对。一个文档有零个或多个字段。字段类似于关系数据库中的列。请看文档结构。 field path 文档中某个字段的路径。要指定字段路径，请使用一个字符串在字段名前加上美元符号(' $ ')。 firewall 一种基于IP地址限制访问的系统级网络过滤器。防火墙是有效网络安全策略的一部分。请看防火墙. fsync 将内存中所有脏页面刷新到磁盘的系统调用。MongoDB至少每60秒对其数据库文件调用 fsync() 。请看fsync。 geohash geohash值是坐标网格中位置的二进制表示。参见计算2d索引的Geohash值。 GeoJSON 基于JavaScript对象符号的数据交换格式(JSON)。GeoJSON用于地理空间查询。有关受支持的GeoJSON对象，请参见地理空间数据。有关GeoJSON格式规范，请参见https://tools.ietf.org/html/rfc7946#section-3.1。 geospatial 与地理位置有关的。看到地理空间查询。 GridFS 在MongoDB数据库中存储大文件的约定。所有官方的MongoDB驱动程序都支持这个约定，就像mongofiles程序一样。参见GridFS。 hashed shard key 一种特殊类型的分片键,使用一个hash值的分片键字段成员之间分发文件的分片集群。请看Hashed索引。 haystack index 一个geospatial索引，该索引通过创建根据第二个标准分组的对象的“buckets”来增强搜索。看到geoHaystack索引。 hidden member 一个replica set成员，不能成为primary并且对客户端应用程序不可见。参见Hidden Replica Set Members。 high availability 高可用性指的是为持久性、冗余和自动故障转移而设计的系统，这样系统所支持的应用程序就可以连续运行，而不会在很长一段时间内停机。MongoDB复制集复制支持高可用性部署时根据我们的记录最佳实践 。有关复制集部署架构的指导，请参阅副本集部署架构。 idempotent 在相同的输入下产生相同结果的操作的质量，无论运行一次还是多次。 index 优化查询的数据结构。请看索引。 init script Linux平台的init系统使用的一个简单的shell脚本，用于启动、重启或停止一个daemon进程。如果您通过包管理器安装了MongoDB，那么作为安装的一部分，会为您的系统提供一个init脚本。请参阅相应的安装指南来了解您的操作系统。 init system init系统是内核启动后在Linux平台上启动的第一个进程，它管理系统上的所有其他进程。init系统使用一个init脚本开始,重新启动,或停止一个守护进程过程,如mongod或mongos。Linux的最新版本倾向于使用systemd init系统，它使用systemctl命令，而旧版本倾向于使用system V init系统，它使用service命令。请参阅相应的安装指南来了解您的操作系统。 initial sync 复制集操作，该操作将数据从现有的复制集成员复制到新的复制集成员。请看初始同步。 intent lock lock资源,表明锁的持有人将读(intent shared)或写(intent exclusive)资源使用并发控制 比资源更细粒度的概念与意图锁。意图锁允许并发读取和写入资源。查看MongoDB使用什么类型的锁?。 interrupt point 操作生命周期中可以安全中止的点。MongoDB只在指定的中断点终止操作。参见终止运行操作。 IPv6 对IP(Internet协议)标准的修订，提供更大的地址空间，以更有效地支持当代Internet上的主机数量。 ISODate mongo使用的国际日期格式来显示日期。格式是:YYYY-MM-DD HH:MM.SS.millis。 JavaScript 一种最初为web浏览器设计的流行脚本语言。MongoDB shell和某些服务器端函数使用JavaScript解释器。更多信息请参见服务器端JavaScript。 journal 一种顺序的二进制事务日志，用于在发生硬关闭时使数据库进入有效状态。日志记录首先将数据写入日志，然后写入核心数据文件。MongoDB 2.0及更新版本的64位版本默认允许日志记录。日志文件是预先分配的，并作为文件存在于data目录中。请看日志。 JSON JavaScript对象表示法。一种人类可读的纯文本格式，用于表示结构化数据，支持多种编程语言。更多信息，请参见http://www.json.org。某些MongoDB工具以JSON格式呈现MongoDB BSON文档的近似值。参见MongoDB Extended JSON (v2)。 JSON document 一个JSON文档是结构化格式的字段和值的集合。对于示例JSON文档，请参见http://json.org/example.html。 JSONP JSON填充。引用一种将JSON注入应用程序的方法。表示潜在的安全问题。 least privilege 一种授权策略，只向用户提供对该用户的工作至关重要的访问权限，而不提供其他权限。 legacy coordinate pairs 该格式用于MongoDB 2.4版本之前的geospatial数据。这种格式将地理空间数据存储为平面坐标系统上的点(例如。[x, y])。参见地理空间查询。 LineString LineString是由两个或多个位置组成的数组定义的。具有四个或更多位置的封闭LineString称为线性环，如GeoJSON LineString规范所述:https://tools.ietf.org/html/rfc7946#section-3.1.4。要在MongoDB中使用LineString，请参见[GeoJSON Objects](https://docs.mongodb.com/master/reference/geojson/#geospatial-indexes-store-geojson)。 lock MongoDB使用锁来确保并发不会影响正确性。MongoDB使用read locks、write locks和intent locks。更多信息，请参见MongoDB使用什么类型的锁定?。 LVM 逻辑卷管理器。LVM是一个从物理设备提取磁盘映像的程序，它提供了许多对系统管理有用的原始磁盘操作和快照功能。有关LVM和MongoDB的信息，请参见在Linux上使用LVM进行备份和恢复。 map-reduce 数据处理和聚合范例由选择数据的“映射”阶段和转换数据的“减少”阶段组成。在MongoDB中，您可以使用map-reduce在数据上运行任意的聚合。对于map-reduce实现，请参见map-reduce。对于所有的聚合方法，请参见aggregation。 mapping type 一种将键与值相关联的编程语言结构，其中键可以嵌套其他键和值对(例如字典、hash表、映射和关联数组)。这些结构的属性取决于语言规范和实现。通常，映射类型中的键的顺序是任意的，不能保证。 md5 一种hashing算法，用于有效地提供可重现的惟一字符串来识别和校验和数据。MongoDB使用md5为GridFS识别数据块。参见filemd5。 MIB 管理信息基础。MongoDB在MongoDB企业版中使用MIB文件定义SNMP跟踪的数据类型。 MIME 多用途因特网邮件扩展。一组标准的类型和编码定义，用于在多个数据存储、传输和电子邮件上下文中声明数据的编码和类型。mongofiles工具提供了一个选项来指定MIME类型来描述插入到GridFS存储中的文件。 mongo MongoDB shell。mongo流程启动MongoDB shell守护进程连接到一个mongod或mongos实例。shell有一个JavaScript接口。参见mongo和mongo Shell方法。 mongod MongoDB数据库服务器。mongod进程启动MongoDB服务器作为一个守护进程。MongoDB服务器管理数据请求和格式，并管理后台操作。参见mongod。 mongos MongoDB分片集群查询路由器。mongos进程启动MongoDB路由器作为一个daemon。MongoDB路由器充当应用程序和MongoDB sharded集群之间的接口，并在集群中处理所有路由和负载平衡。参见mongos。 namespace MongoDB中集合或索引的规范名称。命名空间是数据库名称和集合或索引名称的组合，如[database-name].[collection-or-index]。所有文档都属于一个名称空间。参见名称空间。 natural order 数据库引用磁盘上文档的顺序。这是默认的排序顺序。查看$natural和以自然顺序返回。 network partition 一种网络故障，它将分布式系统分割为多个分区，使得一个分区中的节点无法与另一个分区中的节点通信。有时，分区是部分的或不对称的。部分分区的一个例子将是一个网络的节点分成三组,第一组内的成员不能与第二组的成员,反之亦然,但所有节点可以与第三组的成员交流。在一个不对称的分区,沟通可能只有当它源自某些节点。例如，分区一端的节点只有在它们启动通信通道时才能与另一端通信。 ObjectId 一个特殊的12字节BSON类型，它保证了集合中的唯一性。ObjectId是基于时间戳、机器ID、进程ID和进程本地增量计数器生成的。MongoDB使用ObjectId值作为_id字段的默认值。 operator 以$开头的关键字，用于表示更新、复杂查询或数据转换。例如，$gt是查询语言的\" greater than \"操作符。有关可用的操作符，请参见operators。 oplog 一个capped collection，它将逻辑写入的有序历史存储到MongoDB数据库中。oplog是在MongoDB中启用复制的基本机制。参见Replica Set Oplog。 optime 以下描述了MongoDB 3.2：中引入的protocolVersion: 1使用的optime格式。对复制oplog中位置的引用。optime值是一个文档，其中包含:ts、操作的时间戳。t， term，该操作最初在主服务器上生成。 ordered query plan 一个查询计划，它以与sort()顺序一致的顺序返回结果。查询计划。 orphaned document 在分片集群中，孤立文档是指某个分片上的文档，由于迁移失败或由于异常关机而导致迁移清理不完整，这些文档也存在于其他分片上的块中。从MongoDB 4.4开始，在块迁移完成后，孤立的文档会被自动清理。删除孤立文档不再需要运行cleanuporphaned。 passive member 一个replica set的成员不能成为主元素，因为它的members[n].priority是0。参见Priority 0 Replica Set Members。 PID 一个进程标识符。类unix系统为每个正在运行的进程分配一个唯一的整数PID。可以使用PID检查正在运行的进程并向其发送信号。参见/proc文件系统。 pipe 类unix系统中的一种通信通道，允许独立进程发送和接收数据。在UNIX shell中，管道操作允许用户将一个命令的输出定向到另一个命令的输入。 pipeline 一个聚合流程中的一系列操作。看到聚合管道。 Point GeoJSON点规范中描述的单个坐标对:https://tools.ietf.org/html/rfc7946#section-3.1.2。要在MongoDB中使用一个点，请参见[GeoJSON Objects](https://docs.mongodb.com/master/reference/geojson/#geospatial-indexes-store-geojson)。 Polygon 一个LinearRing坐标数组，正如在GeoJSON多边形规范中描述的:https://tools.ietf.org/html/rfc7946#section-3.1.6。对于有多个环的多边形，第一个必须是外环，其他必须是内环或孔。MongoDB不允许外环自交。内环必须完全包含在外环内，不能相互交叉或重叠。参见[GeoJSON对象](https://docs.mongodb.com/master/reference/geojson/ # geospatial-indexes-store-geojson)。 powerOf2Sizes 每个集合设置改变和规范MongoDB为每个文档分配空间的方式，以最大化存储重用和减少碎片。这是TTL集合的默认值。查看collMod和usepowerof2size。 pre-splitting 在插入数据之前执行的一种操作，它将可能的切分键值范围划分为块，以方便插入和高写吞吐量。在某些情况下预加速文件的初始分布分片集群通过手动划分集而不是等待MongoDB均衡器。参见在分片集群中创建块。 prefix compression 通过在每一页内存中只存储一次相同的索引键前缀，减少内存和磁盘消耗。参见:压缩了解更多关于WiredTiger的压缩行为。 primary 在复制集中，主元素是接收所有写操作的成员。参见Primary。 primary key 记录的唯一不可变标识符。在RDBMS中，主键通常是存储在每行' id '字段中的整数。在MongoDB中，_id字段持有文档的主键，通常是BSON ObjectId。 primary shard shard，它包含所有未分片的集合。参见Primary Shard。 priority 一个可配置的值，帮助确定replica set中的哪些成员最有可能成为primary。参见 members[n].priority. privilege 资源上允许的指定的资源和actions的组合。参见privilege。 projection 一个给查询的文档，它指定MongoDB在结果集中返回哪些字段。有关投影操作符的列表，请参见投影操作符。 query 读请求。MongoDB使用JSON类似的查询语言，包括各种各样的查询操作符，名称以“$”字符开头。mongoshell,你可以发出查询使用db.collection.find()和db.collection.findOne()方法。参见查询文件。 query optimizer 生成查询计划的流程。对于每个查询，优化器都会生成一个计划，将查询与尽可能高效地返回结果的索引相匹配。优化器在每次运行查询时重用查询计划。如果一个集合发生重大变化，优化器将创建一个新的查询计划。参见查询计划。 query shape 查询谓词、排序和投影的组合。对于查询谓词，只有谓词的结构(包括字段名)是重要的;查询谓词中的值不重要。因此，查询谓词{type: 'food'}等价于查询形状的查询谓词{type: 'utensil'}。来帮助识别相同的慢速查询查询形状,开始在MongoDB 4.2中,每个查询形状是与queryHash。queryHash是一个十六进制字符串，表示查询形状的散列，并且只依赖于查询形状。对于任何散列函数，两个不同的查询形状可能会导致相同的散列值。但是，不同查询形状之间不太可能出现哈希冲突。 RDBMS 关系数据库管理系统。基于关系模型的数据库管理系统，通常使用SQL作为查询语言。 read concern 指定读操作的隔离级别。例如，您可以使用read concern来只读已经传播到replica set中的大多数节点的数据。参见读问题。 read lock 资源上的一个共享锁，该资源(比如集合或数据库)在持有时允许并发读取但不允许写入。查看MongoDB使用什么类型的锁?。 read preference 决定客户端如何直接读取操作的设置。读取首选项影响所有副本集，包括分片副本集。默认情况下，MongoDB将读取定向到初选。但是，您也可以为最终一致读取直接将读取指向二级。参见阅读偏好。 recovering replica set成员状态，表示成员还没有准备好开始辅助或主成员的正常活动。正在恢复的成员不可用于读取。 replica pairs MongoDB的前身replica set.自1.6版本以来已被弃用. replica set 实现复制和自动故障转移的MongoDB服务器集群。MongoDB推荐的复制策略。参见复制。 replication 允许多个数据库服务器共享相同数据的特性，从而确保冗余和促进负载平衡。参见复制。 replication lag 最后一个操作之间的时间长度primary’s oplog和最后一个操作应用于一个特定的二级。通常，您希望将复制延迟保持得尽可能小。参见复制延迟。 resident memory 当前存储在物理RAM中的应用程序内存的子集。常驻内存是虚拟内存的一个子集，其中包括映射到物理RAM和磁盘的内存。 resource 数据库、集合、集合集或集群。一个特权允许在指定的资源上执行动作。参见资源。 role 在指定的资源上允许操作的一组特权。分配给用户的角色决定了用户对资源和操作的访问。参见安全。 rollback 恢复写操作以确保所有复制集成员的一致性的进程。参见复制集故障转移期间回滚。 secondary 复制主数据库内容的replica set成员。辅助成员可以处理读请求，但是只有主成员可以处理写操作。参见Secondaries。 secondary index 一个数据库索引，通过最小化查询引擎执行查询时必须执行的工作来提高查询性能。参见索引。 set name 任意的名字给一个复制集。复制集的所有成员必须具有相同的名称指定的replSetName设置或——replSet选项。 shard 一个mongod实例或复制集存储的分片集群的一部分数据集。在生产中,所有分片都应该复制集。参见分片。 shard key MongoDB用于在分片集群的成员之间分发文档的字段。参见分片键。 sharded cluster 包含sharded MongoDB部署的节点集。分片集群由配置服务器、分片和一个或多个mongos路由进程组成。参见分片集群组件。 sharding 按键范围划分数据并将数据分布在两个或多个数据库实例之间的数据库体系结构。切分允许水平伸缩。参见分片。 shell helper mongoshell中的一个方法，它为数据库命令提供了更简洁的语法。Shell helper改善了一般的交互体验。参见mongo Shell方法。 single-master replication 一个replication topology ，其中只有一个数据库实例接受写操作。单主复制确保了一致性，是MongoDB使用的复制topology 。参见Replica Set Primary。 snappy 一个压缩/解压缩库，设计来平衡有效的计算需求与合理的压缩率。Snappy是MongoDB使用WiredTiger的默认压缩库。更多信息，请参见Snappy和WiredTiger压缩文档。 split 分片集群中的chunks的划分。参见使用块进行数据分区。 SQL 结构化查询语言(Structured Query Language, SQL)是一种通用的特殊用途编程语言，用于与关系数据库进行交互，包括访问控制、插入、更新、查询和删除。不同数据库供应商支持的基本SQL语法中有一些类似的元素，但是大多数实现都有自己的方言、数据类型和对提议的SQL标准的解释。复杂的SQL通常不能在主要的RDBMS产品之间直接移植。“SQL”经常被用作关系数据库的转喻。 SSD 固态磁盘。一种高性能的磁盘驱动器，使用固态电子器件来保持性能，与传统机械硬盘驱动器所使用的旋转磁盘和可移动读写磁头不同。 standalone 一个mongod的实例，它作为一个单独的服务器运行，而不是作为replica set的一部分。要将独立转换为复制集，请参见将独立转换为复制集。 storage engine 数据库中负责管理如何在内存和磁盘中存储和访问数据的部分。对于特定的工作负载，不同的存储引擎执行得更好。请参阅Storage Engines了解MongoDB中内置存储引擎的具体细节。 storage order 参见natural order. strict consistency 分布式系统的一种属性，要求所有成员始终反映系统的最新更改。在数据库系统中，这意味着任何能够提供数据的系统都必须始终反映最新的写操作。 sync replica set操作，其中成员从primary复制数据。同步首先发生在MongoDB创建或恢复一个成员时，该成员被称为initial Sync。然后持续进行同步，以通过复制集数据的更改更新成员。查看Replica Set Data Synchronization。 syslog 在类unix系统上，为服务器和进程提供提交日志信息的统一标准的日志过程。MongoDB提供了一个将输出发送到主机的syslog系统的选项。参见' syslogFacility '。 tag 应用于复制集成员的标签，由客户端用于发出感知数据中心的操作。使用标签复制集的更多信息,参见本手册的以下部分:阅读偏好标记集。 3.4版本中改变:在MongoDB 3.4中,分片集群zones term-zone取代tags。 tag set 包含零个或多个标签的文档。 tailable cursor 对于一个capped集合，一个可tailable游标是一个在客户端在初始游标中查看完结果后保持打开的游标。当客户端向有上限的集合插入新文档时，可定制游标将继续检索文档。 term 对于一个复制集的成员，一种单调递增的数目，对应于一次选举尝试。 topology 部署的MongoDB实例的状态,包括部署的类型(即独立、复制集,或分片集群),以及服务器的可用性,和每个服务器的角色(例如主要,二级,配置服务器,或mongos)。 TSV 一种基于文本的数据格式，由制表符分隔的值组成。这种格式通常用于在关系数据库之间交换数据，因为这种格式非常适合表格数据。您可以使用mongoimport导入TSV文件。 TTL 表示“生存时间”，表示给定信息在缓存或其他临时存储中保留的过期时间或期间，然后系统将其删除或老化。MongoDB有一个TTL集合特性。查看通过设置TTL从集合过期数据。 unique index 一种索引，强制跨单个集合的特定字段具有唯一性。参见独特的索引。 unix epoch 1970年1月1日00时。通常用于表示时间，其中从这个点开始计算的秒数或毫秒数。 unordered query plan 返回的查询计划的顺序与sort()顺序不一致。参见查询计划。 upsert 更新操作的选项;例如db.collection.update (), db.collection.findAndModify ()。如果设置为true，更新操作将更新指定查询匹配的文档，如果没有文档匹配，则插入一个新文档。新文档将在操作中指示字段。参见如果不存在匹配，插入新文档(Upsert)。 virtual memory 应用程序的工作内存，通常驻留在磁盘和物理RAM中。 WGS84 默认的参考系统和大地基准，MongoDB使用它来计算类似地球的球体上的几何图形，用于在GeoJSON对象上的地理空间查询。请参阅“EPSG:4326: WGS 84”规范:http://spatialreference.org/ref/epsg/4326/。 working set MongoDB最常用的数据。 write concern 指定写操作是否成功。Write concern允许您的应用程序检测插入错误或不可用mongod实例。对于replica sets，您可以配置write concern来确认复制到指定数量的成员。请看写问题。 write conflict 在这种情况下，两个并发操作(其中至少一个是写操作)试图以违反使用乐观并发控制的存储引擎施加的约束的方式使用资源。MongoDB将透明地中止并重试其中一个冲突的操作。 write lock 资源(比如集合或数据库)上的独占锁。当一个进程写入一个资源时，它采用独占写锁来防止其他进程写入或读取该资源。有关锁的更多信息，请参见FAQ: Concurrency。 writeBacks 切分系统内的进程确保向shard发出的不负责相关块的写被应用到适当的切分。有关信息，请参见writebacklisten在日志中的意思是什么?和writeBacksQueued。 zlib 与MongoDB使用的snappy相比，这个数据压缩库提供了更高的压缩率，但占用了更多的CPU。您可以配置WiredTiger来使用zlib作为其压缩库。更多信息请参见http://www.zlib.net和WiredTiger压缩文档。 zone 3.4版本中的新特性:给定分片集合的基于范围分片键值的文档分组。分片集群中的每个碎片可以与一个或多个区域关联。在一个平衡的集群中，MongoDB只将一个区域覆盖的读和写定向到该区域内的那些碎片。有关更多信息，请参阅zone手册页。 在MongoDB 3.2中，区域取代了标签所描述的功能。 zstd 4.2版中的新功能。 与zlib相比，该数据压缩库提供更高的压缩率和更低的CPU使用率。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Default-MongoDB-Port.html":{"url":"docs/Reference/Default-MongoDB-Port.html","title":"Default MongoDB Port","keywords":"","body":"默认的MongoDB端口 下表列出了MongoDB使用的默认TCP端口: Default Port Description 27017 mongod和mongos实例的默认端口。您可以使用port或——port来更改该端口。 27018 默认端口为mongod运行——shardsvr命令行选项或 shardsvr 值clusterRole设置在配置文件中。 27019 默认端口为mongod运行——configsvr命令行选项或 configsvr 值clusterRole设置在配置文件中。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Default-MongoDB-Read-Concerns-and-Write-Concerns.html":{"url":"docs/Reference/Default-MongoDB-Read-Concerns-and-Write-Concerns.html","title":"Default MongoDB Read Concerns Write Concerns","keywords":"","body":"默认的MongoDB读/写关注 在本页面 阅读关注 写关注 因果一致性保证 阅读关注 默认读取问题 默认的 read concern如下: 操作 默认读取问题 针对主要的读取 \"local\"注意，这个读取的关注点可以返回可能被回滚的数据。此读取关注点不保证因果一致性。 如果读操作与因果一致的会话相关联，则读取二级会话。 \"local\"注意这个读关注可以返回可能回滚的数据。此读取关注点不保证因果一致性。 如果读操作与因果一致的会话没有关联，则对辅助会话进行读取。 \"available\"注意这个读关注可以返回可能回滚的数据这种已读关注点不能保证因果关系的一致性。对于分片集合，这个读关注也可以返回孤立的文档。 指定读取关注:MongoDB驱动程序 外部事务操作 注意 以下内容适用于在事务外部发出的操作。 要阅读与事务内部发出的操作相关的关注信息，请单击事务中的操作选项卡。 使用MongoDB 驱动，您可以覆盖默认的read concern，并设置以下级别的操作的read concern: 水平 描述 客户级别 应用于操作，除非在数据库/集合/操作级别设置了更细致的读取关注。否则将应用于操作。 数据库级别 应用于数据库集合上的操作(即覆盖客户端读关注)，除非已在集合级别或操作级别设置了读关注。注意：不适用于事务内部的操作。 集合级别 应用对集合的读操作(即覆盖数据库/客户端读关注)，除非已在操作级别设置了读关注。注意：不适用于事务内部的操作。 操作级别 应用特定的读操作(例如，覆盖数据库/客户端/集合读关注)。在操作中设置read concern的能力取决于驱动程序。请参考您的驱动程序文档。注意：不适用于事务内部的操作。 事务中的操作 注意 以下内容适用于在事务内部发出的操作。 要阅读与发出外部事务的操作相关的关注信息，请单击“外部事务的操作”选项卡。 使用MongoDB 驱动，您可以覆盖默认的read concern，并设置以下级别的操作的read concern: 水平 描述 客户级别 应用于事务，除非在会话/事务级别设置了更细致的读取关注。注意事务中的所有操作都使用事务读关注;即,在事务内部忽略在操作/集合/数据库级别设置的任何读关注。 会话级别 应用于在会话中启动的事务(即覆盖客户端读取关注)，除非在特定事务级别上设置了更细致的读取关注级别。注意事务中的所有操作都使用事务读关注;即,在事务内部忽略在操作/集合/数据库级别设置的任何读关注。有关更多信息，请参阅事务的阅和读关注。 事务级别 应用于特定的事务。事务写关注应用于提交操作和事务内部的操作。注意事务中的所有操作都使用事务读关注;即,在事务内部忽略在操作/集合/数据库级别设置的任何读关注。 额外的信息 有关可用的读取关注点的更多信息，请参见read Concern。 写关注 默认写问题 默认的 write concern是 w: 1 。 请注意 使用默认的写关注，数据可以回滚。 此写关注点不保证因果一致性。 指定写关注:MongoDB驱动程序 外部事务操作 注意 以下内容适用于在transactions外部发出的操作。 要阅读与事务内部发布的操作相关的关注信息，请单击“事务中的操作”选项卡。 使用MongoDB drivers，您可以覆盖默认的write concern，并在以下级别设置操作的write concern: Level Description 客户级别 除非在操作/数据库/集合中为操作设置了更细的写关注点，否则将应用于操作。 数据库级别 应用于数据库集合上的写操作(即覆盖客户端写关注点)，除非在集合级别或操作级别上设置了写关注点注意不适用于事务内部的操作。 集合级别 应用于集合上的写操作(即覆盖数据库和客户端写关注点)，除非在操作级别上设置了写关注点。注意不适用于事务内部的操作。 操作级别 应用于特定的写操作。在操作中设置写关注点的能力取决于驱动程序。请参考您的驱动程序文档。注意不适用于事务内部的操作。 事务中的操作 注意 以下内容适用于在事务内部发出的操作。 要阅读与发出外部事务的操作相关的关注信息，请单击“外部事务的操作”选项卡。 水平 描述 客户级别 应用于事务，除非在会话/事务级别设置了更细致的读取关注。事务写关注点适用于提交操作和事务内部的操作。注意事务中的所有操作都使用事务读关注;即,在事务内部忽略在操作/集合/数据库级别设置的任何读关注。 会话级别 应用于在会话中启动的事务(即覆盖客户端读取关注)，除非在特定事务级别上设置了更细致的读取关注级别。事务写关注点适用于提交操作和事务内部的操作。注意事务中的所有操作都使用事务读关注;即,在事务内部忽略在操作/集合/数据库级别设置的任何读关注。有关更多信息，请参阅事务的阅和读关注。 事务级别 应用于特定的事务。事务写关注应用于提交操作和事务内部的操作。注意事务中的所有操作都使用事务读关注;即,在事务内部忽略在操作/集合/数据库级别设置的任何读关注。 使用MongoDB驱动程序，你可以覆盖默认的写关注和设置写关注为以下级别的事务: 额外的信息 有关可用的写关注点的更多信息，请参见写关注点。 因果一致性的保证 使用因果一致的客户端会话，客户端会话仅在以下情况下保证因果一致: 相关的读取操作使用 \"majority\" 读取concern， 相关的写操作使用 \"majority\" 写关注。 Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "},"docs/Reference/Server-Sessions.html":{"url":"docs/Reference/Server-Sessions.html","title":"Server Sessions","keywords":"","body":"服务器会话 在本页面 概述 命令选项 会话命令 会话和访问控制 新增3.6版 概述 MongoDB的服务器会话或逻辑会话是客户端会话用来支持因果一致性和可重试写入的基础框架。 重要 应用程序使用客户端会话与服务器会话进行接口。 服务器会话仅可用于复制集和分片集群。 命令选项 从3.6开始，MongoDB驱动程序将所有操作与一个服务器会话关联起来，除了未确认的写操作。以下选项可用于所有命令，以支持与服务器会话的关联: 重要 mongo shell和驱动程序在会话中将这些选项分配给命令。 选项 类型 描述 lsid 文档 指定与命令关联的会话的唯一id的文档。如果指定了 txnNumber ，则需要 lsid 。 txnNumber 64位整数 一个严格递增的非负数，用于在命令的会话中唯一标识该命令。如果指定了该命令，则该命令还必须包含 lsid 选项。 删除,插入,和更新命令,采取一系列的语句,也可用以下选择: 对于delete，insert和update 命令,采取一系列的语句，以下选项也可： 重要 不要手动设置 stmtIds 。MongoDB将 stmtIds 设置为严格的非负数递增。 选项 Type Description stmtIds 32位整数的数组 在写命令中唯一标识其各自写操作的数字数组。 会话命令 The following commands can be used to list, manage, and kill server sessions throughout MongoDB clusters: 命令 描述 endSessions 指定的服务器会话过期。 killAllSessions 终止所有服务器会话。 killAllSessionsByPattern 终止与指定模式匹配的所有服务器会话。 killSessions 终止指定的服务器会话。 refreshSessions 刷新空闲服务器会话。 startSession 启动一个新的服务器会话。 会话和访问控制 如果部署强制执行身份验证/授权，则必须对用户进行身份验证才能启动会话，并且只有该用户才能使用该会话 在版本3.6.3中更改:使用 $external 身份验证用户(例如，Kerberos、LDAP、x.509个用户)，用户名不能大于10k字节。 如果部署不强制执行身份验证/授权，则创建的会话没有所有者，并且可以由任何用户在任何连接上使用。如果用户对不执行身份验证/授权的部署进行身份验证并创建会话，则该用户将拥有该会话。但是，任何连接上的任何用户都可以使用该会话。 如果部署在没有任何停机的情况下转换到身份验证，则不能使用任何没有所有者的会话。 另请参阅： maxSessions Copyright © 上海锦木信息技术有限公司 all right reserved，powered by Gitbook文件修订时间： 2020-08-05 18:42:26 "}}